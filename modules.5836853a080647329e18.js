/*! For license information please see modules.5836853a080647329e18.js.LICENSE.txt */
(self.webpackChunkcryptopro_cades_example=self.webpackChunkcryptopro_cades_example||[]).push([[54],{220:(e,t,s)=>{"use strict";s.d(t,{$:()=>Ge,BD:()=>et,EI:()=>Qe,FC:()=>me,GM:()=>Me,Gh:()=>ct,HQ:()=>Ze,Hk:()=>Xe,IK:()=>ot,Lv:()=>lt,NI:()=>Ye,Ox:()=>qe,SZ:()=>We,T9:()=>Te,Tz:()=>je,WC:()=>Ve,WV:()=>le,Yw:()=>tt,ZD:()=>ut,_K:()=>Se,eN:()=>ht,fi:()=>ve,gF:()=>ze,ge:()=>we,kE:()=>_e,l4:()=>Pe,p2:()=>ge,qU:()=>Ke,rP:()=>He,sc:()=>ce,z8:()=>Be});var r=s(656),a=s(422);function n(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function i(e){let t=0,s=0;for(let s=0;s<e.length;s++){t+=e[s].byteLength}const r=new Uint8Array(t);for(let t=0;t<e.length;t++){const a=e[t];r.set(new Uint8Array(a),s),s+=a.byteLength}return r.buffer}function o(e,t,s,r){return t instanceof Uint8Array?t.byteLength?s<0?(e.error="Wrong parameter: inputOffset less than zero",!1):r<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-s-r<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class l{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return i(this.items)}}const u=[new Uint8Array([1])],c="0123456789",h="name",m="valueHexView",f="",d=new ArrayBuffer(0),g=new Uint8Array(0),p="EndOfContent",w="OCTET STRING",y="BIT STRING";function v(e){var t;return(t=class extends e{constructor(...e){var t;super(...e);const s=e[0]||{};this.isHexOnly=null!==(t=s.isHexOnly)&&void 0!==t&&t,this.valueHexView=s.valueHex?r.vJ.toUint8Array(s.valueHex):g}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}fromBER(e,t,s){const r=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!o(this,r,t,s))return-1;const a=t+s;return this.valueHexView=r.subarray(t,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",d)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:r.ep.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class b{constructor({blockLength:e=0,error:t="",warnings:s=[],valueBeforeDecode:a=g}={}){this.blockLength=e,this.error=t,this.warnings=s,this.valueBeforeDecodeView=r.vJ.toUint8Array(a)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:r.ep.ToHex(this.valueBeforeDecodeView)}}}b.NAME="baseBlock";class S extends b{fromBER(e,t,s){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}S.NAME="valueBlock";class A extends(v(b)){constructor({idBlock:e={}}={}){var t,s,a,n;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?r.vJ.toUint8Array(e.valueHex):g,this.tagClass=null!==(s=e.tagClass)&&void 0!==s?s:-1,this.tagNumber=null!==(a=e.tagNumber)&&void 0!==a?a:-1,this.isConstructed=null!==(n=e.isConstructed)&&void 0!==n&&n):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",d}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const s=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,s[0]=t}return s.buffer}if(!this.isHexOnly){const s=a.lL(this.tagNumber,7),r=new Uint8Array(s),n=s.byteLength,i=new Uint8Array(n+1);if(i[0]=31|t,!e){for(let e=0;e<n-1;e++)i[e+1]=128|r[e];i[n]=r[n-1]}return i.buffer}const s=new Uint8Array(this.valueHexView.byteLength+1);if(s[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)s[t+1]=128|e[t];s[this.valueHexView.byteLength]=e[e.length-1]}return s.buffer}fromBER(e,t,s){const n=r.vJ.toUint8Array(e);if(!o(this,n,t,s))return-1;const i=n.subarray(t,t+s);if(0===i.length)return this.error="Zero buffer length",-1;switch(192&i[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&i[0]),this.isHexOnly=!1;const l=31&i[0];if(31!==l)this.tagNumber=l,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),s=255;for(;128&i[e];){if(t[e-1]=127&i[e],e++,e>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(e===s){s+=255;const e=new Uint8Array(s);for(let s=0;s<t.length;s++)e[s]=t[s];t=this.valueHexView=new Uint8Array(s)}}this.blockLength=e+1,t[e-1]=127&i[e];const r=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=t[s];t=this.valueHexView=new Uint8Array(e),t.set(r),this.blockLength<=9?this.tagNumber=a.r9(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}A.NAME="identificationBlock";class k extends b{constructor({lenBlock:e={}}={}){var t,s,r;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(s=e.longFormUsed)&&void 0!==s&&s,this.length=null!==(r=e.length)&&void 0!==r?r:0}fromBER(e,t,s){const n=r.vJ.toUint8Array(e);if(!o(this,n,t,s))return-1;const i=n.subarray(t,t+s);if(0===i.length)return this.error="Zero buffer length",-1;if(255===i[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===i[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&i[0]),!1===this.longFormUsed)return this.length=i[0],this.blockLength=1,t+this.blockLength;const l=127&i[0];if(l>8)return this.error="Too big integer",-1;if(l+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const u=t+1,c=n.subarray(u,u+l);return 0===c[l-1]&&this.warnings.push("Needlessly long encoded length"),this.length=a.r9(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=l+1,t+this.blockLength}toBER(e=!1){let t,s;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(s=new Uint8Array(t),s[0]=128),t;if(this.longFormUsed){const r=a.lL(this.length,8);if(r.byteLength>127)return this.error="Too big length",d;if(t=new ArrayBuffer(r.byteLength+1),e)return t;const n=new Uint8Array(r);s=new Uint8Array(t),s[0]=128|r.byteLength;for(let e=0;e<r.byteLength;e++)s[e+1]=n[e];return t}return t=new ArrayBuffer(1),!1===e&&(s=new Uint8Array(t),s[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}k.NAME="lengthBlock";const N={};class C extends b{constructor({name:e="",optional:t=!1,primitiveSchema:s,...r}={},a){super(r),this.name=e,this.optional=t,s&&(this.primitiveSchema=s),this.idBlock=new A(r),this.lenBlock=new k(r),this.valueBlock=a?new a(r):new S(r)}fromBER(e,t,s){const r=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),r)}toBER(e,t){const s=t||new l;t||B(this);const r=this.idBlock.toBER(e);if(s.write(r),this.lenBlock.isIndefiniteForm)s.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,s),s.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const r=this.lenBlock.toBER(e);s.write(r),s.write(t)}return t?d:s.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():r.ep.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${r.ep.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),s=e.toBER();return a.dN(t,s)}}function B(e){if(e instanceof N.Constructed)for(const t of e.valueBlock.value)B(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!e.lenBlock.isIndefiniteForm}C.NAME="BaseBlock";class V extends C{constructor({value:e="",...t}={},s){super(t,s),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,s){const r=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),r)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}V.NAME="BaseStringBlock";class I extends(v(S)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var E,H,x,D,O,T,P,U,$,L,R,K,J,_,F,M,j,q,z,W,G,Z,Y,Q,X,ee,te,se,re,ae,ne,ie,oe;I.NAME="PrimitiveValueBlock";class le extends C{constructor(e={}){super(e,I),this.idBlock.isConstructed=!1}}function ue(e,t=0,s=e.length){const r=t;let a=new C({},S);const n=new b;if(!o(n,e,t,s))return a.error=n.error,{offset:-1,result:a};if(!e.subarray(t,t+s).length)return a.error="Zero buffer length",{offset:-1,result:a};let i=a.idBlock.fromBER(e,t,s);if(a.idBlock.warnings.length&&a.warnings.concat(a.idBlock.warnings),-1===i)return a.error=a.idBlock.error,{offset:-1,result:a};if(t=i,s-=a.idBlock.blockLength,i=a.lenBlock.fromBER(e,t,s),a.lenBlock.warnings.length&&a.warnings.concat(a.lenBlock.warnings),-1===i)return a.error=a.lenBlock.error,{offset:-1,result:a};if(t=i,s-=a.lenBlock.blockLength,!a.idBlock.isConstructed&&a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let l=C;if(1===a.idBlock.tagClass){if(a.idBlock.tagNumber>=37&&!1===a.idBlock.isHexOnly)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};l=N.EndOfContent;break;case 1:l=N.Boolean;break;case 2:l=N.Integer;break;case 3:l=N.BitString;break;case 4:l=N.OctetString;break;case 5:l=N.Null;break;case 6:l=N.ObjectIdentifier;break;case 10:l=N.Enumerated;break;case 12:l=N.Utf8String;break;case 13:l=N.RelativeObjectIdentifier;break;case 14:l=N.TIME;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:l=N.Sequence;break;case 17:l=N.Set;break;case 18:l=N.NumericString;break;case 19:l=N.PrintableString;break;case 20:l=N.TeletexString;break;case 21:l=N.VideotexString;break;case 22:l=N.IA5String;break;case 23:l=N.UTCTime;break;case 24:l=N.GeneralizedTime;break;case 25:l=N.GraphicString;break;case 26:l=N.VisibleString;break;case 27:l=N.GeneralString;break;case 28:l=N.UniversalString;break;case 29:l=N.CharacterString;break;case 30:l=N.BmpString;break;case 31:l=N.DATE;break;case 32:l=N.TimeOfDay;break;case 33:l=N.DateTime;break;case 34:l=N.Duration;break;default:{const e=a.idBlock.isConstructed?new N.Constructed:new N.Primitive;e.idBlock=a.idBlock,e.lenBlock=a.lenBlock,e.warnings=a.warnings,a=e}}}else l=a.idBlock.isConstructed?N.Constructed:N.Primitive;return a=function(e,t){if(e instanceof t)return e;const s=new t;return s.idBlock=e.idBlock,s.lenBlock=e.lenBlock,s.warnings=e.warnings,s.valueBeforeDecodeView=e.valueBeforeDecodeView,s}(a,l),i=a.fromBER(e,t,a.lenBlock.isIndefiniteForm?s:a.lenBlock.length),a.valueBeforeDecodeView=e.subarray(r,r+a.blockLength),{offset:i,result:a}}function ce(e){if(!e.byteLength){const e=new C({},S);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ue(r.vJ.toUint8Array(e).slice(),0,e.byteLength)}E=le,N.Primitive=E,le.NAME="PRIMITIVE";class he extends S{constructor({value:e=[],isIndefiniteForm:t=!1,...s}={}){super(s),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,s){const a=r.vJ.toUint8Array(e);if(!o(this,a,t,s))return-1;if(this.valueBeforeDecodeView=a.subarray(t,t+s),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let n=t;for(;i=this.isIndefiniteForm,l=s,(i?1:l)>0;){const e=ue(a,n,s);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(n=e.offset,this.blockLength+=e.result.blockLength,s-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===p)break}var i,l;return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===p?this.value.pop():this.warnings.push("No EndOfContent block encoded")),n}toBER(e,t){const s=t||new l;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,s);return t?d:s.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}he.NAME="ConstructedValueBlock";class me extends C{constructor(e={}){super(e,he),this.idBlock.isConstructed=!0}fromBER(e,t,s){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const r=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?s:this.lenBlock.length);return-1===r?(this.error=this.valueBlock.error,r):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),r)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map((e=>`  ${e}`)).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}H=me,N.Constructed=H,me.NAME="CONSTRUCTED";class fe extends S{fromBER(e,t,s){return t}toBER(e){return d}}fe.override="EndOfContentValueBlock";class de extends C{constructor(e={}){super(e,fe),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}x=de,N.EndOfContent=x,de.NAME=p;class ge extends C{constructor(e={}){super(e,S),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,s){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=s,t+s>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+s}toBER(e,t){const s=new ArrayBuffer(2);if(!e){const e=new Uint8Array(s);e[0]=5,e[1]=0}return t&&t.write(s),s}onAsciiEncoding(){return`${this.constructor.NAME}`}}D=ge,N.Null=D,ge.NAME="NULL";class pe extends(v(S)){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=r.vJ.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,s){const n=r.vJ.toUint8Array(e);return o(this,n,t,s)?(this.valueHexView=n.subarray(t,t+s),s>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,a.Gc.call(this),this.blockLength=s,t+s):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}pe.NAME="BooleanValueBlock";class we extends C{constructor(e={}){super(e,pe),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}O=we,N.Boolean=O,we.NAME="BOOLEAN";class ye extends(v(he)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,s){let r=0;if(this.isConstructed){if(this.isHexOnly=!1,r=he.prototype.fromBER.call(this,e,t,s),-1===r)return r;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===p){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==w)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,r=super.fromBER(e,t,s),this.blockLength=s;return r}toBER(e,t){return this.isConstructed?he.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}ye.NAME="OctetStringValueBlock";class ve extends C{constructor({idBlock:e={},lenBlock:t={},...s}={}){var r,a;null!==(r=s.isConstructed)&&void 0!==r||(s.isConstructed=!!(null===(a=s.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:s.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!s.isIndefiniteForm},...s},ye),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,s){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===s)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const r=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+s);try{if(r.byteLength){const e=ue(r,0,r.byteLength);-1!==e.offset&&e.offset===s&&(this.valueBlock.value=[e.result])}}catch(e){}}return super.fromBER(e,t,s)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?me.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${r.ep.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof ve&&e.push(t.valueBlock.valueHexView);return r.vJ.concat(e)}}T=ve,N.OctetString=T,ve.NAME=w;class be extends(v(he)){constructor({unusedBits:e=0,isConstructed:t=!1,...s}={}){super(s),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,s){if(!s)return t;let a=-1;if(this.isConstructed){if(a=he.prototype.fromBER.call(this,e,t,s),-1===a)return a;for(const e of this.value){const t=e.constructor.NAME;if(t===p){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==y)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const s=e.valueBlock;if(this.unusedBits>0&&s.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=s.unusedBits}return a}const n=r.vJ.toUint8Array(e);if(!o(this,n,t,s))return-1;const i=n.subarray(t,t+s);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=ue(e,0,e.byteLength);-1!==t.offset&&t.offset===s-1&&(this.value=[t.result])}}catch(e){}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+s}toBER(e,t){if(this.isConstructed)return he.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return d;const s=new Uint8Array(this.valueHexView.length+1);return s[0]=this.unusedBits,s.set(this.valueHexView,1),s.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}be.NAME="BitStringValueBlock";class Se extends C{constructor({idBlock:e={},lenBlock:t={},...s}={}){var r,a;null!==(r=s.isConstructed)&&void 0!==r||(s.isConstructed=!!(null===(a=s.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:s.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!s.isIndefiniteForm},...s},be),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,s){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,s)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return me.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const s of t)e.push(s.toString(2).padStart(8,"0"));const s=e.join("");return`${this.constructor.NAME} : ${s.substring(0,s.length-this.valueBlock.unusedBits)}`}}}function Ae(e,t){const s=new Uint8Array([0]),r=new Uint8Array(e),n=new Uint8Array(t);let i=r.slice(0);const o=i.length-1,l=n.slice(0),u=l.length-1;let c=0;let h=0;for(let e=u<o?o:u;e>=0;e--,h++){if(!0==h<l.length)c=i[o-h]+l[u-h]+s[0];else c=i[o-h]+s[0];if(s[0]=c/10,!0==h>=i.length)i=a.Ir(new Uint8Array([c%10]),i);else i[o-h]=c%10}return s[0]>0&&(i=a.Ir(s,i)),i}function ke(e){if(e>=u.length)for(let t=u.length;t<=e;t++){const e=new Uint8Array([0]);let s=u[t-1].slice(0);for(let t=s.length-1;t>=0;t--){const r=new Uint8Array([(s[t]<<1)+e[0]]);e[0]=r[0]/10,s[t]=r[0]%10}e[0]>0&&(s=a.Ir(e,s)),u.push(s)}return u[e]}function Ne(e,t){let s=0;const r=new Uint8Array(e),a=new Uint8Array(t),n=r.slice(0),i=n.length-1,o=a.slice(0),l=o.length-1;let u,c=0;for(let e=l;e>=0;e--,c++)if(u=n[i-c]-o[l-c]-s,!0==u<0)s=1,n[i-c]=u+10;else s=0,n[i-c]=u;if(s>0)for(let e=i-l+1;e>=0;e--,c++){if(u=n[i-c]-s,!(u<0)){s=0,n[i-c]=u;break}s=1,n[i-c]=u+10}return n.slice()}P=Se,N.BitString=P,Se.NAME=y;class Ce extends(v(S)){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=a.Gc.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(a.qE(e))}get valueDec(){return this._valueDec}fromDER(e,t,s,r=0){const a=this.fromBER(e,t,s);if(-1===a)return a;const n=this.valueHexView;return 0===n[0]&&0!=(128&n[1])?this.valueHexView=n.subarray(1):0!==r&&n.length<r&&(r-n.length>1&&(r=n.length+1),this.valueHexView=n.subarray(r-n.length)),a}toDER(e=!1){const t=this.valueHexView;switch(!0){case 0!=(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&0==(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,s){const r=super.fromBER(e,t,s);return-1===r||this.setValueHex(),r}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,s=new Uint8Array(8*this.valueHexView.length/3),r=0;const a=this.valueHexView;let n="",i=!1;for(let i=a.byteLength-1;i>=0;i--){t=a[i];for(let a=0;a<8;a++){if(1==(1&t))if(r===e)s=Ne(ke(r),s),n="-";else s=Ae(s,ke(r));r++,t>>=1}}for(let e=0;e<s.length;e++)s[e]&&(i=!0),i&&(n+=c.charAt(s[e]));return!1===i&&(n+=c.charAt(0)),n}}U=Ce,Ce.NAME="IntegerValueBlock",Object.defineProperty(U.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class Be extends C{constructor(e={}){super(e,Ce),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return n(),BigInt(this.valueBlock.toString())}static fromBigInt(e){n();const t=BigInt(e),s=new l,a=t.toString(16).replace(/^-/,""),i=new Uint8Array(r.ep.FromHex(a));if(t<0){const e=new Uint8Array(i.length+(128&i[0]?1:0));e[0]|=128;const a=BigInt(`0x${r.ep.ToHex(e)}`)+t,n=r.vJ.toUint8Array(r.ep.FromHex(a.toString(16)));n[0]|=128,s.write(n)}else 128&i[0]&&s.write(new Uint8Array([0])),s.write(i);return new Be({valueHex:s.final()})}convertToDER(){const e=new Be({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new Be({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}$=Be,N.Integer=$,Be.NAME="INTEGER";class Ve extends Be{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}L=Ve,N.Enumerated=L,Ve.NAME="ENUMERATED";class Ie extends(v(S)){constructor({valueDec:e=-1,isFirstSid:t=!1,...s}={}){super(s),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,s){if(!s)return t;const n=r.vJ.toUint8Array(e);if(!o(this,n,t,s))return-1;const i=n.subarray(t,t+s);this.valueHexView=new Uint8Array(s);for(let e=0;e<s&&(this.valueHexView[e]=127&i[e],this.blockLength++,0!=(128&i[e]));e++);const l=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)l[e]=this.valueHexView[e];return this.valueHexView=l,0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a.r9(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){n();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const s=new Uint8Array(t.length/7);for(let e=0;e<s.length;e++)s[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<s.length?128:0);this.fromBER(s.buffer,0,s.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,s=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)s[e]=128|t[e];return s[this.blockLength-1]=t[this.blockLength-1],s.buffer}const t=a.lL(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",d;const s=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),r=t.byteLength-1;for(let t=0;t<r;t++)s[t]=128|e[t];s[r]=e[r]}return s}toString(){let e="";if(this.isHexOnly)e=r.ep.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Ie.NAME="sidBlock";class Ee extends S{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,s){let r=t;for(;s>0;){const t=new Ie;if(r=t.fromBER(e,r,s),-1===r)return this.blockLength=0,this.error=t.error,r;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,s-=t.blockLength,this.value.push(t)}return r}toBER(e){const t=[];for(let s=0;s<this.value.length;s++){const r=this.value[s].toBER(e);if(0===r.byteLength)return this.error=this.value[s].error,d;t.push(r)}return i(t)}fromString(e){this.value=[];let t=0,s=0,r="",a=!1;do{if(s=e.indexOf(".",t),r=-1===s?e.substring(t):e.substring(t,s),t=s+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const s=parseInt(r,10);if(isNaN(s))return;e.valueDec=s+t,a=!1}else{const e=new Ie;if(r>Number.MAX_SAFE_INTEGER){n();const t=BigInt(r);e.valueBigInt=t}else if(e.valueDec=parseInt(r,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==s)}toString(){let e="",t=!1;for(let s=0;s<this.value.length;s++){t=this.value[s].isHexOnly;let r=this.value[s].toString();0!==s&&(e=`${e}.`),t?(r=`{${r}}`,this.value[s].isFirstSid?e=`2.{${r} - 80}`:e+=r):e+=r}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Ee.NAME="ObjectIdentifierValueBlock";class He extends C{constructor(e={}){super(e,Ee),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}R=He,N.ObjectIdentifier=R,He.NAME="OBJECT IDENTIFIER";class xe extends(v(b)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,s){if(0===s)return t;const n=r.vJ.toUint8Array(e);if(!o(this,n,t,s))return-1;const i=n.subarray(t,t+s);this.valueHexView=new Uint8Array(s);for(let e=0;e<s&&(this.valueHexView[e]=127&i[e],this.blockLength++,0!=(128&i[e]));e++);const l=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)l[e]=this.valueHexView[e];return this.valueHexView=l,0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a.r9(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,s=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)s[e]=128|t[e];return s[this.blockLength-1]=t[this.blockLength-1],s.buffer}const t=a.lL(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",d;const s=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),r=t.byteLength-1;for(let t=0;t<r;t++)s[t]=128|e[t];s[r]=e[r]}return s.buffer}toString(){let e="";return e=this.isHexOnly?r.ep.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}xe.NAME="relativeSidBlock";class De extends S{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,s){let r=t;for(;s>0;){const t=new xe;if(r=t.fromBER(e,r,s),-1===r)return this.blockLength=0,this.error=t.error,r;this.blockLength+=t.blockLength,s-=t.blockLength,this.value.push(t)}return r}toBER(e,t){const s=[];for(let t=0;t<this.value.length;t++){const r=this.value[t].toBER(e);if(0===r.byteLength)return this.error=this.value[t].error,d;s.push(r)}return i(s)}fromString(e){this.value=[];let t=0,s=0,r="";do{s=e.indexOf(".",t),r=-1===s?e.substring(t):e.substring(t,s),t=s+1;const a=new xe;if(a.valueDec=parseInt(r,10),isNaN(a.valueDec))return!0;this.value.push(a)}while(-1!==s);return!0}toString(){let e="",t=!1;for(let s=0;s<this.value.length;s++){t=this.value[s].isHexOnly;let r=this.value[s].toString();0!==s&&(e=`${e}.`),t?(r=`{${r}}`,e+=r):e+=r}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}De.NAME="RelativeObjectIdentifierValueBlock";class Oe extends C{constructor(e={}){super(e,De),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}K=Oe,N.RelativeObjectIdentifier=K,Oe.NAME="RelativeObjectIdentifier";class Te extends me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}J=Te,N.Sequence=J,Te.NAME="SEQUENCE";class Pe extends me{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}_=Pe,N.Set=_,Pe.NAME="SET";class Ue extends(v(S)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=f}toJSON(){return{...super.toJSON(),value:this.value}}}Ue.NAME="StringValueBlock";class $e extends Ue{}$e.NAME="SimpleStringValueBlock";class Le extends V{constructor({...e}={}){super(e,$e)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,r.vJ.toUint8Array(e))}fromString(e){const t=e.length,s=this.valueBlock.valueHexView=new Uint8Array(t);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);this.valueBlock.value=e}}Le.NAME="SIMPLE STRING";class Re extends Le{fromBuffer(e){this.valueBlock.valueHexView=r.vJ.toUint8Array(e);try{this.valueBlock.value=r.ep.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=r.ep.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(r.ep.FromUtf8String(e)),this.valueBlock.value=e}}Re.NAME="Utf8StringValueBlock";class Ke extends Re{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}F=Ke,N.Utf8String=F,Ke.NAME="UTF8String";class Je extends Le{fromBuffer(e){this.valueBlock.value=r.ep.ToUtf16String(e),this.valueBlock.valueHexView=r.vJ.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(r.ep.FromUtf16String(e))}}Je.NAME="BmpStringValueBlock";class _e extends Je{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}M=_e,N.BmpString=M,_e.NAME="BMPString";class Fe extends Le{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),s=new Uint8Array(t);for(let e=0;e<s.length;e+=4)s[e]=s[e+3],s[e+1]=s[e+2],s[e+2]=0,s[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,s=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let r=0;r<t;r++){const t=a.lL(e.charCodeAt(r),8),n=new Uint8Array(t);if(n.length>4)continue;const i=4-n.length;for(let e=n.length-1;e>=0;e--)s[4*r+e+i]=n[e]}this.valueBlock.value=e}}Fe.NAME="UniversalStringValueBlock";class Me extends Fe{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}j=Me,N.UniversalString=j,Me.NAME="UniversalString";class je extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}q=je,N.NumericString=q,je.NAME="NumericString";class qe extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}z=qe,N.PrintableString=z,qe.NAME="PrintableString";class ze extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}W=ze,N.TeletexString=W,ze.NAME="TeletexString";class We extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}G=We,N.VideotexString=G,We.NAME="VideotexString";class Ge extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Z=Ge,N.IA5String=Z,Ge.NAME="IA5String";class Ze extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}Y=Ze,N.GraphicString=Y,Ze.NAME="GraphicString";class Ye extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Q=Ye,N.VisibleString=Q,Ye.NAME="VisibleString";class Qe extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}X=Qe,N.GeneralString=X,Qe.NAME="GeneralString";class Xe extends Le{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}ee=Xe,N.CharacterString=ee,Xe.NAME="CharacterString";class et extends Ye{constructor({value:e,valueDate:t,...s}={}){if(super(s),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,r.vJ.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),s=new Uint8Array(t);for(let t=0;t<e.length;t++)s[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const s=parseInt(t[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=a.vX(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=a.vX(this.month,2),e[2]=a.vX(this.day,2),e[3]=a.vX(this.hour,2),e[4]=a.vX(this.minute,2),e[5]=a.vX(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}te=et,N.UTCTime=te,et.NAME="UTCTime";class tt extends et{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,s=!1,r="",a="",n=0,i=0,o=0;if("Z"===e[e.length-1])r=e.substring(0,e.length-1),s=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(s){if(-1!==r.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==r.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=r.indexOf("+"),s="";if(-1===t&&(t=r.indexOf("-"),e=-1),-1!==t){if(s=r.substring(t+1),r=r.substring(0,t),2!==s.length&&4!==s.length)throw new Error("Wrong input string for conversion");let a=parseInt(s.substring(0,2),10);if(isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");if(i=e*a,4===s.length){if(a=parseInt(s.substring(2,4),10),isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");o=e*a}}}let l=r.indexOf(".");if(-1===l&&(l=r.indexOf(",")),-1!==l){const e=new Number(`0${r.substring(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");n=e.valueOf(),a=r.substring(0,l)}else a=r;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for conversion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const u=t.exec(a);if(null===u)throw new Error("Wrong input string for conversion");for(let e=1;e<u.length;e++)switch(e){case 1:this.year=parseInt(u[e],10);break;case 2:this.month=parseInt(u[e],10);break;case 3:this.day=parseInt(u[e],10);break;case 4:this.hour=parseInt(u[e],10)+i;break;case 5:this.minute=parseInt(u[e],10)+o;break;case 6:this.second=parseInt(u[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===s){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(a.vX(this.year,4)),e.push(a.vX(this.month,2)),e.push(a.vX(this.day,2)),e.push(a.vX(this.hour,2)),e.push(a.vX(this.minute,2)),e.push(a.vX(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(a.vX(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}se=tt,N.GeneralizedTime=se,tt.NAME="GeneralizedTime";class st extends Ke{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}re=st,N.DATE=re,st.NAME="DATE";class rt extends Ke{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}ae=rt,N.TimeOfDay=ae,rt.NAME="TimeOfDay";class at extends Ke{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}ne=at,N.DateTime=ne,at.NAME="DateTime";class nt extends Ke{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}ie=nt,N.Duration=ie,nt.NAME="Duration";class it extends Ke{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}oe=it,N.TIME=oe,it.NAME="TIME";class ot{constructor({name:e="",optional:t=!1}={}){this.name=e,this.optional=t}}class lt extends ot{constructor({value:e=[],...t}={}){super(t),this.value=e}}class ut extends ot{constructor({value:e=new ot,local:t=!1,...s}={}){super(s),this.value=e,this.local=t}}class ct{constructor({data:e=g}={}){this.dataView=r.vJ.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=r.vJ.toUint8Array(e)}fromBER(e,t,s){const a=t+s;return this.dataView=r.vJ.toUint8Array(e).subarray(t,a),a}toBER(e){return this.dataView.slice().buffer}}function ht(e,t,s){if(s instanceof lt){for(let r=0;r<s.value.length;r++){if(ht(e,t,s.value[r]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return s.hasOwnProperty(h)&&(e.name=s.name),e}}if(s instanceof ot)return s.hasOwnProperty(h)&&(e[s.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(s instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in s==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in s.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in s.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=s.idBlock.toBER(!1);if(0===r.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===s.idBlock.fromBER(r,0,r.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===s.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(s.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===s.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(s.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===s.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(s.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if(!("isHexOnly"in s.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(s.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(s.idBlock.isHexOnly){if(m in s.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=s.idBlock.valueHexView,a=t.idBlock.valueHexView;if(r.length!==a.length)return{verified:!1,result:e};for(let t=0;t<r.length;t++)if(r[t]!==a[1])return{verified:!1,result:e}}if(s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&(e[s.name]=t)),s instanceof N.Constructed){let r=0,a={verified:!1,result:{error:"Unknown error"}},n=s.valueBlock.value.length;if(n>0&&s.valueBlock.value[0]instanceof ut&&(n=t.valueBlock.value.length),0===n)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==s.valueBlock.value.length){let t=!0;for(let e=0;e<s.valueBlock.value.length;e++)t=t&&(s.valueBlock.value[e].optional||!1);return t?{verified:!0,result:e}:(s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&delete e[s.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let i=0;i<n;i++)if(i-r>=t.valueBlock.value.length){if(!1===s.valueBlock.value[i].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&(delete e[s.name],t.name=s.name)),t}}else if(s.valueBlock.value[0]instanceof ut){if(a=ht(e,t.valueBlock.value[i],s.valueBlock.value[0].value),!1===a.verified){if(!s.valueBlock.value[0].optional)return s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&delete e[s.name]),a;r++}if(h in s.valueBlock.value[0]&&s.valueBlock.value[0].name.length>0){let r={};r="local"in s.valueBlock.value[0]&&s.valueBlock.value[0].local?t:e,void 0===r[s.valueBlock.value[0].name]&&(r[s.valueBlock.value[0].name]=[]),r[s.valueBlock.value[0].name].push(t.valueBlock.value[i])}}else if(a=ht(e,t.valueBlock.value[i-r],s.valueBlock.value[i]),!1===a.verified){if(!s.valueBlock.value[i].optional)return s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&delete e[s.name]),a;r++}if(!1===a.verified){const t={verified:!1,result:e};return s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&(delete e[s.name],t.name=s.name)),t}return{verified:!0,result:e}}if(s.primitiveSchema&&m in t.valueBlock){const r=ue(t.valueBlock.valueHexView);if(-1===r.offset){const t={verified:!1,result:r.result};return s.name&&(s.name=s.name.replace(/^\s+|\s+$/g,f),s.name&&(delete e[s.name],t.name=s.name)),t}return ht(e,r.result,s.primitiveSchema)}return{verified:!0,result:e}}},766:(e,t)=>{"use strict";t.byteLength=function(e){var t=l(e),s=t[0],r=t[1];return 3*(s+r)/4-r},t.toByteArray=function(e){var t,s,n=l(e),i=n[0],o=n[1],u=new a(function(e,t,s){return 3*(t+s)/4-s}(0,i,o)),c=0,h=o>0?i-4:i;for(s=0;s<h;s+=4)t=r[e.charCodeAt(s)]<<18|r[e.charCodeAt(s+1)]<<12|r[e.charCodeAt(s+2)]<<6|r[e.charCodeAt(s+3)],u[c++]=t>>16&255,u[c++]=t>>8&255,u[c++]=255&t;2===o&&(t=r[e.charCodeAt(s)]<<2|r[e.charCodeAt(s+1)]>>4,u[c++]=255&t);1===o&&(t=r[e.charCodeAt(s)]<<10|r[e.charCodeAt(s+1)]<<4|r[e.charCodeAt(s+2)]>>2,u[c++]=t>>8&255,u[c++]=255&t);return u},t.fromByteArray=function(e){for(var t,r=e.length,a=r%3,n=[],i=16383,o=0,l=r-a;o<l;o+=i)n.push(u(e,o,o+i>l?l:o+i));1===a?(t=e[r-1],n.push(s[t>>2]+s[t<<4&63]+"==")):2===a&&(t=(e[r-2]<<8)+e[r-1],n.push(s[t>>10]+s[t>>4&63]+s[t<<2&63]+"="));return n.join("")};for(var s=[],r=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=n.length;i<o;++i)s[i]=n[i],r[n.charCodeAt(i)]=i;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var s=e.indexOf("=");return-1===s&&(s=t),[s,s===t?0:4-s%4]}function u(e,t,r){for(var a,n,i=[],o=t;o<r;o+=3)a=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(s[(n=a)>>18&63]+s[n>>12&63]+s[n>>6&63]+s[63&n]);return i.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},834:(e,t,s)=>{"use strict";const r=s(766),a=s(333),n="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.lW=l,t.h2=50;const i=2147483647;function o(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,s){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return h(e)}return u(e,t,s)}function u(e,t,s){if("string"==typeof e)return function(e,t){"string"==typeof t&&""!==t||(t="utf8");if(!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const s=0|g(e,t);let r=o(s);const a=r.write(e,t);a!==s&&(r=r.slice(0,a));return r}(e,t);if(ArrayBuffer.isView(e))return function(e){if(G(e,Uint8Array)){const t=new Uint8Array(e);return f(t.buffer,t.byteOffset,t.byteLength)}return m(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(G(e,ArrayBuffer)||e&&G(e.buffer,ArrayBuffer))return f(e,t,s);if("undefined"!=typeof SharedArrayBuffer&&(G(e,SharedArrayBuffer)||e&&G(e.buffer,SharedArrayBuffer)))return f(e,t,s);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const r=e.valueOf&&e.valueOf();if(null!=r&&r!==e)return l.from(r,t,s);const a=function(e){if(l.isBuffer(e)){const t=0|d(e.length),s=o(t);return 0===s.length||e.copy(s,0,0,t),s}if(void 0!==e.length)return"number"!=typeof e.length||Z(e.length)?o(0):m(e);if("Buffer"===e.type&&Array.isArray(e.data))return m(e.data)}(e);if(a)return a;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,s);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function h(e){return c(e),o(e<0?0:0|d(e))}function m(e){const t=e.length<0?0:0|d(e.length),s=o(t);for(let r=0;r<t;r+=1)s[r]=255&e[r];return s}function f(e,t,s){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(s||0))throw new RangeError('"length" is outside of buffer bounds');let r;return r=void 0===t&&void 0===s?new Uint8Array(e):void 0===s?new Uint8Array(e,t):new Uint8Array(e,t,s),Object.setPrototypeOf(r,l.prototype),r}function d(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function g(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||G(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const s=e.length,r=arguments.length>2&&!0===arguments[2];if(!r&&0===s)return 0;let a=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return s;case"utf8":case"utf-8":return q(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*s;case"hex":return s>>>1;case"base64":return z(e).length;default:if(a)return r?-1:q(e).length;t=(""+t).toLowerCase(),a=!0}}function p(e,t,s){let r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===s||s>this.length)&&(s=this.length),s<=0)return"";if((s>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return H(this,t,s);case"utf8":case"utf-8":return B(this,t,s);case"ascii":return I(this,t,s);case"latin1":case"binary":return E(this,t,s);case"base64":return C(this,t,s);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,t,s);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function w(e,t,s){const r=e[t];e[t]=e[s],e[s]=r}function y(e,t,s,r,a){if(0===e.length)return-1;if("string"==typeof s?(r=s,s=0):s>2147483647?s=2147483647:s<-2147483648&&(s=-2147483648),Z(s=+s)&&(s=a?0:e.length-1),s<0&&(s=e.length+s),s>=e.length){if(a)return-1;s=e.length-1}else if(s<0){if(!a)return-1;s=0}if("string"==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:v(e,t,s,r,a);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(e,t,s):Uint8Array.prototype.lastIndexOf.call(e,t,s):v(e,[t],s,r,a);throw new TypeError("val must be string, number or Buffer")}function v(e,t,s,r,a){let n,i=1,o=e.length,l=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;i=2,o/=2,l/=2,s/=2}function u(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(a){let r=-1;for(n=s;n<o;n++)if(u(e,n)===u(t,-1===r?0:n-r)){if(-1===r&&(r=n),n-r+1===l)return r*i}else-1!==r&&(n-=n-r),r=-1}else for(s+l>o&&(s=o-l),n=s;n>=0;n--){let s=!0;for(let r=0;r<l;r++)if(u(e,n+r)!==u(t,r)){s=!1;break}if(s)return n}return-1}function b(e,t,s,r){s=Number(s)||0;const a=e.length-s;r?(r=Number(r))>a&&(r=a):r=a;const n=t.length;let i;for(r>n/2&&(r=n/2),i=0;i<r;++i){const r=parseInt(t.substr(2*i,2),16);if(Z(r))return i;e[s+i]=r}return i}function S(e,t,s,r){return W(q(t,e.length-s),e,s,r)}function A(e,t,s,r){return W(function(e){const t=[];for(let s=0;s<e.length;++s)t.push(255&e.charCodeAt(s));return t}(t),e,s,r)}function k(e,t,s,r){return W(z(t),e,s,r)}function N(e,t,s,r){return W(function(e,t){let s,r,a;const n=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)s=e.charCodeAt(i),r=s>>8,a=s%256,n.push(a),n.push(r);return n}(t,e.length-s),e,s,r)}function C(e,t,s){return 0===t&&s===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,s))}function B(e,t,s){s=Math.min(e.length,s);const r=[];let a=t;for(;a<s;){const t=e[a];let n=null,i=t>239?4:t>223?3:t>191?2:1;if(a+i<=s){let s,r,o,l;switch(i){case 1:t<128&&(n=t);break;case 2:s=e[a+1],128==(192&s)&&(l=(31&t)<<6|63&s,l>127&&(n=l));break;case 3:s=e[a+1],r=e[a+2],128==(192&s)&&128==(192&r)&&(l=(15&t)<<12|(63&s)<<6|63&r,l>2047&&(l<55296||l>57343)&&(n=l));break;case 4:s=e[a+1],r=e[a+2],o=e[a+3],128==(192&s)&&128==(192&r)&&128==(192&o)&&(l=(15&t)<<18|(63&s)<<12|(63&r)<<6|63&o,l>65535&&l<1114112&&(n=l))}}null===n?(n=65533,i=1):n>65535&&(n-=65536,r.push(n>>>10&1023|55296),n=56320|1023&n),r.push(n),a+=i}return function(e){const t=e.length;if(t<=V)return String.fromCharCode.apply(String,e);let s="",r=0;for(;r<t;)s+=String.fromCharCode.apply(String,e.slice(r,r+=V));return s}(r)}l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),!l.TYPED_ARRAY_SUPPORT&&"undefined"!=typeof console&&console.error,Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,s){return u(e,t,s)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,s){return function(e,t,s){return c(e),e<=0?o(e):void 0!==t?"string"==typeof s?o(e).fill(t,s):o(e).fill(t):o(e)}(e,t,s)},l.allocUnsafe=function(e){return h(e)},l.allocUnsafeSlow=function(e){return h(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(G(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),G(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let s=e.length,r=t.length;for(let a=0,n=Math.min(s,r);a<n;++a)if(e[a]!==t[a]){s=e[a],r=t[a];break}return s<r?-1:r<s?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let s;if(void 0===t)for(t=0,s=0;s<e.length;++s)t+=e[s].length;const r=l.allocUnsafe(t);let a=0;for(s=0;s<e.length;++s){let t=e[s];if(G(t,Uint8Array))a+t.length>r.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(r,a)):Uint8Array.prototype.set.call(r,t,a);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(r,a)}a+=t.length}return r},l.byteLength=g,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)w(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)w(this,t,t+3),w(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)w(this,t,t+7),w(this,t+1,t+6),w(this,t+2,t+5),w(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?B(this,0,e):p.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const s=t.h2;return e=this.toString("hex",0,s).replace(/(.{2})/g,"$1 ").trim(),this.length>s&&(e+=" ... "),"<Buffer "+e+">"},n&&(l.prototype[n]=l.prototype.inspect),l.prototype.compare=function(e,t,s,r,a){if(G(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===s&&(s=e?e.length:0),void 0===r&&(r=0),void 0===a&&(a=this.length),t<0||s>e.length||r<0||a>this.length)throw new RangeError("out of range index");if(r>=a&&t>=s)return 0;if(r>=a)return-1;if(t>=s)return 1;if(this===e)return 0;let n=(a>>>=0)-(r>>>=0),i=(s>>>=0)-(t>>>=0);const o=Math.min(n,i),u=this.slice(r,a),c=e.slice(t,s);for(let e=0;e<o;++e)if(u[e]!==c[e]){n=u[e],i=c[e];break}return n<i?-1:i<n?1:0},l.prototype.includes=function(e,t,s){return-1!==this.indexOf(e,t,s)},l.prototype.indexOf=function(e,t,s){return y(this,e,t,s,!0)},l.prototype.lastIndexOf=function(e,t,s){return y(this,e,t,s,!1)},l.prototype.write=function(e,t,s,r){if(void 0===t)r="utf8",s=this.length,t=0;else if(void 0===s&&"string"==typeof t)r=t,s=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(s)?(s>>>=0,void 0===r&&(r="utf8")):(r=s,s=void 0)}const a=this.length-t;if((void 0===s||s>a)&&(s=a),e.length>0&&(s<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");let n=!1;for(;;)switch(r){case"hex":return b(this,e,t,s);case"utf8":case"utf-8":return S(this,e,t,s);case"ascii":case"latin1":case"binary":return A(this,e,t,s);case"base64":return k(this,e,t,s);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return N(this,e,t,s);default:if(n)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),n=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const V=4096;function I(e,t,s){let r="";s=Math.min(e.length,s);for(let a=t;a<s;++a)r+=String.fromCharCode(127&e[a]);return r}function E(e,t,s){let r="";s=Math.min(e.length,s);for(let a=t;a<s;++a)r+=String.fromCharCode(e[a]);return r}function H(e,t,s){const r=e.length;(!t||t<0)&&(t=0),(!s||s<0||s>r)&&(s=r);let a="";for(let r=t;r<s;++r)a+=Y[e[r]];return a}function x(e,t,s){const r=e.slice(t,s);let a="";for(let e=0;e<r.length-1;e+=2)a+=String.fromCharCode(r[e]+256*r[e+1]);return a}function D(e,t,s){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>s)throw new RangeError("Trying to access beyond buffer length")}function O(e,t,s,r,a,n){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>a||t<n)throw new RangeError('"value" argument is out of bounds');if(s+r>e.length)throw new RangeError("Index out of range")}function T(e,t,s,r,a){_(t,r,a,e,s,7);let n=Number(t&BigInt(4294967295));e[s++]=n,n>>=8,e[s++]=n,n>>=8,e[s++]=n,n>>=8,e[s++]=n;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[s++]=i,i>>=8,e[s++]=i,i>>=8,e[s++]=i,i>>=8,e[s++]=i,s}function P(e,t,s,r,a){_(t,r,a,e,s,7);let n=Number(t&BigInt(4294967295));e[s+7]=n,n>>=8,e[s+6]=n,n>>=8,e[s+5]=n,n>>=8,e[s+4]=n;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[s+3]=i,i>>=8,e[s+2]=i,i>>=8,e[s+1]=i,i>>=8,e[s]=i,s+8}function U(e,t,s,r,a,n){if(s+r>e.length)throw new RangeError("Index out of range");if(s<0)throw new RangeError("Index out of range")}function $(e,t,s,r,n){return t=+t,s>>>=0,n||U(e,0,s,4),a.write(e,t,s,r,23,4),s+4}function L(e,t,s,r,n){return t=+t,s>>>=0,n||U(e,0,s,8),a.write(e,t,s,r,52,8),s+8}l.prototype.slice=function(e,t){const s=this.length;(e=~~e)<0?(e+=s)<0&&(e=0):e>s&&(e=s),(t=void 0===t?s:~~t)<0?(t+=s)<0&&(t=0):t>s&&(t=s),t<e&&(t=e);const r=this.subarray(e,t);return Object.setPrototypeOf(r,l.prototype),r},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,s){e>>>=0,t>>>=0,s||D(e,t,this.length);let r=this[e],a=1,n=0;for(;++n<t&&(a*=256);)r+=this[e+n]*a;return r},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,s){e>>>=0,t>>>=0,s||D(e,t,this.length);let r=this[e+--t],a=1;for(;t>0&&(a*=256);)r+=this[e+--t]*a;return r},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||D(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=Q((function(e){F(e>>>=0,"offset");const t=this[e],s=this[e+7];void 0!==t&&void 0!==s||M(e,this.length-8);const r=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,a=this[++e]+256*this[++e]+65536*this[++e]+s*2**24;return BigInt(r)+(BigInt(a)<<BigInt(32))})),l.prototype.readBigUInt64BE=Q((function(e){F(e>>>=0,"offset");const t=this[e],s=this[e+7];void 0!==t&&void 0!==s||M(e,this.length-8);const r=t*2**24+65536*this[++e]+256*this[++e]+this[++e],a=this[++e]*2**24+65536*this[++e]+256*this[++e]+s;return(BigInt(r)<<BigInt(32))+BigInt(a)})),l.prototype.readIntLE=function(e,t,s){e>>>=0,t>>>=0,s||D(e,t,this.length);let r=this[e],a=1,n=0;for(;++n<t&&(a*=256);)r+=this[e+n]*a;return a*=128,r>=a&&(r-=Math.pow(2,8*t)),r},l.prototype.readIntBE=function(e,t,s){e>>>=0,t>>>=0,s||D(e,t,this.length);let r=t,a=1,n=this[e+--r];for(;r>0&&(a*=256);)n+=this[e+--r]*a;return a*=128,n>=a&&(n-=Math.pow(2,8*t)),n},l.prototype.readInt8=function(e,t){return e>>>=0,t||D(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||D(e,2,this.length);const s=this[e]|this[e+1]<<8;return 32768&s?4294901760|s:s},l.prototype.readInt16BE=function(e,t){e>>>=0,t||D(e,2,this.length);const s=this[e+1]|this[e]<<8;return 32768&s?4294901760|s:s},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||D(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=Q((function(e){F(e>>>=0,"offset");const t=this[e],s=this[e+7];void 0!==t&&void 0!==s||M(e,this.length-8);const r=this[e+4]+256*this[e+5]+65536*this[e+6]+(s<<24);return(BigInt(r)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),l.prototype.readBigInt64BE=Q((function(e){F(e>>>=0,"offset");const t=this[e],s=this[e+7];void 0!==t&&void 0!==s||M(e,this.length-8);const r=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(r)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+s)})),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||D(e,4,this.length),a.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||D(e,4,this.length),a.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||D(e,8,this.length),a.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||D(e,8,this.length),a.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,s,r){if(e=+e,t>>>=0,s>>>=0,!r){O(this,e,t,s,Math.pow(2,8*s)-1,0)}let a=1,n=0;for(this[t]=255&e;++n<s&&(a*=256);)this[t+n]=e/a&255;return t+s},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,s,r){if(e=+e,t>>>=0,s>>>=0,!r){O(this,e,t,s,Math.pow(2,8*s)-1,0)}let a=s-1,n=1;for(this[t+a]=255&e;--a>=0&&(n*=256);)this[t+a]=e/n&255;return t+s},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=Q((function(e,t=0){return T(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeBigUInt64BE=Q((function(e,t=0){return P(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),l.prototype.writeIntLE=function(e,t,s,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*s-1);O(this,e,t,s,r-1,-r)}let a=0,n=1,i=0;for(this[t]=255&e;++a<s&&(n*=256);)e<0&&0===i&&0!==this[t+a-1]&&(i=1),this[t+a]=(e/n>>0)-i&255;return t+s},l.prototype.writeIntBE=function(e,t,s,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*s-1);O(this,e,t,s,r-1,-r)}let a=s-1,n=1,i=0;for(this[t+a]=255&e;--a>=0&&(n*=256);)e<0&&0===i&&0!==this[t+a+1]&&(i=1),this[t+a]=(e/n>>0)-i&255;return t+s},l.prototype.writeInt8=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,s){return e=+e,t>>>=0,s||O(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=Q((function(e,t=0){return T(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeBigInt64BE=Q((function(e,t=0){return P(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),l.prototype.writeFloatLE=function(e,t,s){return $(this,e,t,!0,s)},l.prototype.writeFloatBE=function(e,t,s){return $(this,e,t,!1,s)},l.prototype.writeDoubleLE=function(e,t,s){return L(this,e,t,!0,s)},l.prototype.writeDoubleBE=function(e,t,s){return L(this,e,t,!1,s)},l.prototype.copy=function(e,t,s,r){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(s||(s=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<s&&(r=s),r===s)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(s<0||s>=this.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-s&&(r=e.length-t+s);const a=r-s;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,s,r):Uint8Array.prototype.set.call(e,this.subarray(s,r),t),a},l.prototype.fill=function(e,t,s,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,s=this.length):"string"==typeof s&&(r=s,s=this.length),void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r);if(1===e.length){const t=e.charCodeAt(0);("utf8"===r&&t<128||"latin1"===r)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<s)throw new RangeError("Out of range index");if(s<=t)return this;let a;if(t>>>=0,s=void 0===s?this.length:s>>>0,e||(e=0),"number"==typeof e)for(a=t;a<s;++a)this[a]=e;else{const n=l.isBuffer(e)?e:l.from(e,r),i=n.length;if(0===i)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(a=0;a<s-t;++a)this[a+t]=n[a%i]}return this};const R={};function K(e,t,s){R[e]=class extends s{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function J(e){let t="",s=e.length;const r="-"===e[0]?1:0;for(;s>=r+4;s-=3)t=`_${e.slice(s-3,s)}${t}`;return`${e.slice(0,s)}${t}`}function _(e,t,s,r,a,n){if(e>s||e<t){const r="bigint"==typeof t?"n":"";let a;throw a=n>3?0===t||t===BigInt(0)?`>= 0${r} and < 2${r} ** ${8*(n+1)}${r}`:`>= -(2${r} ** ${8*(n+1)-1}${r}) and < 2 ** ${8*(n+1)-1}${r}`:`>= ${t}${r} and <= ${s}${r}`,new R.ERR_OUT_OF_RANGE("value",a,e)}!function(e,t,s){F(t,"offset"),void 0!==e[t]&&void 0!==e[t+s]||M(t,e.length-(s+1))}(r,a,n)}function F(e,t){if("number"!=typeof e)throw new R.ERR_INVALID_ARG_TYPE(t,"number",e)}function M(e,t,s){if(Math.floor(e)!==e)throw F(e,s),new R.ERR_OUT_OF_RANGE(s||"offset","an integer",e);if(t<0)throw new R.ERR_BUFFER_OUT_OF_BOUNDS;throw new R.ERR_OUT_OF_RANGE(s||"offset",`>= ${s?1:0} and <= ${t}`,e)}K("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),K("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),K("ERR_OUT_OF_RANGE",(function(e,t,s){let r=`The value of "${e}" is out of range.`,a=s;return Number.isInteger(s)&&Math.abs(s)>2**32?a=J(String(s)):"bigint"==typeof s&&(a=String(s),(s>BigInt(2)**BigInt(32)||s<-(BigInt(2)**BigInt(32)))&&(a=J(a)),a+="n"),r+=` It must be ${t}. Received ${a}`,r}),RangeError);const j=/[^+/0-9A-Za-z-_]/g;function q(e,t){let s;t=t||1/0;const r=e.length;let a=null;const n=[];for(let i=0;i<r;++i){if(s=e.charCodeAt(i),s>55295&&s<57344){if(!a){if(s>56319){(t-=3)>-1&&n.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&n.push(239,191,189);continue}a=s;continue}if(s<56320){(t-=3)>-1&&n.push(239,191,189),a=s;continue}s=65536+(a-55296<<10|s-56320)}else a&&(t-=3)>-1&&n.push(239,191,189);if(a=null,s<128){if((t-=1)<0)break;n.push(s)}else if(s<2048){if((t-=2)<0)break;n.push(s>>6|192,63&s|128)}else if(s<65536){if((t-=3)<0)break;n.push(s>>12|224,s>>6&63|128,63&s|128)}else{if(!(s<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;n.push(s>>18|240,s>>12&63|128,s>>6&63|128,63&s|128)}}return n}function z(e){return r.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(j,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function W(e,t,s,r){let a;for(a=0;a<r&&!(a+s>=t.length||a>=e.length);++a)t[a+s]=e[a];return a}function G(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Z(e){return e!=e}const Y=function(){const e="0123456789abcdef",t=new Array(256);for(let s=0;s<16;++s){const r=16*s;for(let a=0;a<16;++a)t[r+a]=e[s]+e[a]}return t}();function Q(e){return"undefined"==typeof BigInt?X:e}function X(){throw new Error("BigInt not supported")}},333:(e,t)=>{t.read=function(e,t,s,r,a){var n,i,o=8*a-r-1,l=(1<<o)-1,u=l>>1,c=-7,h=s?a-1:0,m=s?-1:1,f=e[t+h];for(h+=m,n=f&(1<<-c)-1,f>>=-c,c+=o;c>0;n=256*n+e[t+h],h+=m,c-=8);for(i=n&(1<<-c)-1,n>>=-c,c+=r;c>0;i=256*i+e[t+h],h+=m,c-=8);if(0===n)n=1-u;else{if(n===l)return i?NaN:1/0*(f?-1:1);i+=Math.pow(2,r),n-=u}return(f?-1:1)*i*Math.pow(2,n-r)},t.write=function(e,t,s,r,a,n){var i,o,l,u=8*n-a-1,c=(1<<u)-1,h=c>>1,m=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,f=r?0:n-1,d=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=c):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),(t+=i+h>=1?m/l:m*Math.pow(2,1-h))*l>=2&&(i++,l/=2),i+h>=c?(o=0,i=c):i+h>=1?(o=(t*l-1)*Math.pow(2,a),i+=h):(o=t*Math.pow(2,h-1)*Math.pow(2,a),i=0));a>=8;e[s+f]=255&o,f+=d,o/=256,a-=8);for(i=i<<a|o,u+=a;u>0;e[s+f]=255&i,f+=d,i/=256,u-=8);e[s+f-d]|=128*g}},455:(e,t,s)=>{"use strict";s.d(t,{KBB:()=>Un});var r=s(220),a=s(656),n=s(422);class i{constructor(e={}){if("view"in e)this.fromUint8Array(e.view);else if("buffer"in e)this.fromArrayBuffer(e.buffer);else if("string"in e)this.fromString(e.string);else if("hexstring"in e)this.fromHexString(e.hexstring);else if("length"in e&&e.length>0){if(this.length=e.length,e.stub)for(let t=0;t<this._view.length;t++)this._view[t]=e.stub}else this.length=0}set buffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this.view.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}fromUint8Array(e){this.fromArrayBuffer(new Uint8Array(e).buffer)}fromString(e){const t=e.length;this.length=t;for(let s=0;s<t;s++)this.view[s]=e.charCodeAt(s)}toString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++)s+=String.fromCharCode(this.view[r]);return s}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const s=new Map;s.set("0",0),s.set("1",1),s.set("2",2),s.set("3",3),s.set("4",4),s.set("5",5),s.set("6",6),s.set("7",7),s.set("8",8),s.set("9",9),s.set("A",10),s.set("a",10),s.set("B",11),s.set("b",11),s.set("C",12),s.set("c",12),s.set("D",13),s.set("d",13),s.set("E",14),s.set("e",14),s.set("F",15),s.set("f",15);let r=0,a=0;for(let n=0;n<t;n++)n%2?(a|=s.get(e.charAt(n)),this.view[r]=a,r++):a=s.get(e.charAt(n))<<4}toHexString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++){const e=this.view[r].toString(16).toUpperCase();s=s+(1==e.length?"0":"")+e}return s}copy(e=0,t=this.length-e){if(!e&&!this.length)return new i;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new i({buffer:this._buffer.slice(e,e+t)})}slice(e=0,t=this.length){if(!e&&!this.length)return new i;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new i({buffer:this._buffer.slice(e,t)})}realloc(e){const t=new ArrayBuffer(e),s=new Uint8Array(t);e>this._view.length?s.set(this._view):s.set(new Uint8Array(this._buffer,0,e)),this._buffer=t,this._view=new Uint8Array(this._buffer)}append(e){const t=this.length,s=e.length,r=e._view.subarray();this.realloc(t+s),this._view.set(r,t)}insert(e,t=0,s=this.length-t){return!(t>this.length-1)&&(s>this.length-t&&(s=this.length-t),s>e.length&&(s=e.length),s==e.length?this._view.set(e._view,t):this._view.set(e._view.subarray(0,s),t),!0)}isEqual(e){if(this.length!=e.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t,s,r){const{start:a,length:n,backward:i}=this.prepareFindParameters(t,s,r),o=e.length;if(o>n)return-1;const l=[];for(let t=0;t<o;t++)l.push(e.view[t]);for(let e=0;e<=n-o;e++){let t=!0;const s=i?a-o-e:a+e;for(let e=0;e<o;e++)if(this.view[e+s]!=l[e]){t=!1;break}if(t)return i?a-o-e:a+o+e}return-1}findFirstIn(e,t,s,r){const{start:a,length:n,backward:i}=this.prepareFindParameters(t,s,r),o={id:-1,position:i?0:a+n,length:0};for(let t=0;t<e.length;t++){const s=this.findPattern(e[t],a,n,i);if(-1!=s){let r=!1;const a=e[t].length;i?s-a>=o.position-o.length&&(r=!0):s-a<=o.position-o.length&&(r=!0),r&&(o.position=s,o.id=t,o.length=a)}}return o}findAllIn(e,t,s){let{start:r,length:a}=this.prepareFindParameters(t,s);const n=[];let i={id:-1,position:r};for(;;){const t=i.position;if(i=this.findFirstIn(e,i.position,a),-1==i.id)break;a-=i.position-t,n.push({id:i.id,position:i.position})}return n}findAllPatternIn(e,t,s){const{start:r,length:a}=this.prepareFindParameters(t,s),n=[],i=e.length;if(i>a)return-1;const o=Array.from(e.view);for(let e=0;e<=a-i;e++){let t=!0;const s=r+e;for(let e=0;e<i;e++)if(this.view[e+s]!=o[e]){t=!1;break}t&&(n.push(r+i+e),e+=i-1)}return n}findFirstNotIn(e,t,s,r){let{start:a,length:n,backward:o}=this.prepareFindParameters(t,s,r);const l={left:{id:-1,position:a},right:{id:-1,position:0},value:new i};let u=n;for(;u>0;){if(l.right=this.findFirstIn(e,o?a-n+u:a+n-u,u,o),-1==l.right.id){n=u,o?a-=n:a=l.left.position,l.value=new i({buffer:this._buffer.slice(a,a+n)});break}if(l.right.position!=(o?l.left.position-e[l.right.id].length:l.left.position+e[l.right.id].length)){o?(a=l.right.position+e[l.right.id].length,n=l.left.position-l.right.position-e[l.right.id].length):(a=l.left.position,n=l.right.position-l.left.position-e[l.right.id].length),l.value=new i({buffer:this._buffer.slice(a,a+n)});break}l.left=l.right,u-=e[l.right.id].length}if(o){const e=l.right;l.right=l.left,l.left=e}return l}findAllNotIn(e,t,s){let{start:r,length:a}=this.prepareFindParameters(t,s);const n=[];let o={left:{id:-1,position:r},right:{id:-1,position:r},value:new i};do{const t=o.right.position;o=this.findFirstNotIn(e,o.right.position,a),a-=o.right.position-t,n.push({left:{id:o.left.id,position:o.left.position},right:{id:o.right.id,position:o.right.position},value:o.value})}while(-1!=o.right.id);return n}findFirstSequence(e,t,s,r){let{start:a,length:n,backward:o}=this.prepareFindParameters(t,s,r);const l=this.skipNotPatterns(e,a,n,o);if(-1==l)return{position:-1,value:new i};const u=this.skipPatterns(e,l,n-(o?a-l:l-a),o);o?(a=u,n=l-u):(a=l,n=u-l);return{position:u,value:new i({buffer:this._buffer.slice(a,a+n)})}}findAllSequences(e,t,s){let{start:r,length:a}=this.prepareFindParameters(t,s);const n=[];let o={position:r,value:new i};do{const t=o.position;o=this.findFirstSequence(e,o.position,a),-1!=o.position&&(a-=o.position-t,n.push({position:o.position,value:o.value}))}while(-1!=o.position);return n}findPairedPatterns(e,t,s,r){const a=[];if(e.isEqual(t))return a;const{start:n,length:i}=this.prepareFindParameters(s,r);let o=0;const l=this.findAllPatternIn(e,n,i);if(!Array.isArray(l)||0==l.length)return a;const u=this.findAllPatternIn(t,n,i);if(!Array.isArray(u)||0==u.length)return a;for(;o<l.length&&0!=u.length;)if(l[0]!=u[0]){if(l[o]>u[0])break;for(;l[o]<u[0]&&(o++,!(o>=l.length)););a.push({left:l[o-1],right:u[0]}),l.splice(o-1,1),u.splice(0,1),o=0}else a.push({left:l[0],right:u[0]}),l.splice(0,1),u.splice(0,1);return a.sort(((e,t)=>e.left-t.left)),a}findPairedArrays(e,t,s,r){const{start:a,length:n}=this.prepareFindParameters(s,r),i=[];let o=0;const l=this.findAllIn(e,a,n);if(0==l.length)return i;const u=this.findAllIn(t,a,n);if(0==u.length)return i;for(;o<l.length&&0!=u.length;)if(l[0].position!=u[0].position){if(l[o].position>u[0].position)break;for(;l[o].position<u[0].position&&(o++,!(o>=l.length)););i.push({left:l[o-1],right:u[0]}),l.splice(o-1,1),u.splice(0,1),o=0}else i.push({left:l[0],right:u[0]}),l.splice(0,1),u.splice(0,1);return i.sort(((e,t)=>e.left.position-t.left.position)),i}replacePattern(e,t,s,r,a=null){let n,i=[];const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]},{start:l,length:u}=this.prepareFindParameters(s,r);if(null==a){if(i=this.findAllIn([e],l,u),0==i.length)return o}else i=a;o.searchPatternPositions.push(...Array.from(i,(e=>e.position)));const c=e.length-t.length,h=new ArrayBuffer(this.view.length-i.length*c),m=new Uint8Array(h);for(m.set(new Uint8Array(this.buffer,0,l)),n=0;n<i.length;n++){const s=0==n?l:i[n-1].position;m.set(new Uint8Array(this.buffer,s,i[n].position-e.length-s),s-n*c),m.set(t.view,i[n].position-e.length-n*c),o.replacePatternPositions.push(i[n].position-e.length-n*c)}return n--,m.set(new Uint8Array(this.buffer,i[n].position,this.length-i[n].position),i[n].position-e.length+t.length-n*c),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t,s,r){const{start:a,length:n,backward:i}=this.prepareFindParameters(t,s,r);let o=a;for(let t=0;t<e.length;t++){const s=e[t].length,r=i?o-s:o;let l=!0;for(let a=0;a<s;a++)if(this.view[a+r]!=e[t].view[a]){l=!1;break}if(l)if(t=-1,i){if(o-=s,o<=0)return o}else if(o+=s,o>=a+n)return o}return o}skipNotPatterns(e,t,s,r){const{start:a,length:n,backward:i}=this.prepareFindParameters(t,s,r);let o=-1;for(let t=0;t<n;t++){for(let s=0;s<e.length;s++){const r=e[s].length,n=i?a-t-r:a+t;let l=!0;for(let t=0;t<r;t++)if(this.view[t+n]!=e[s].view[t]){l=!1;break}if(l){o=i?a-t:a+t;break}}if(-1!=o)break}return o}prepareFindParameters(e=null,t=null,s=!1){return null===e&&(e=s?this.length:0),e>this.length&&(e=this.length),s?(null===t&&(t=e),t>e&&(t=e)):(null===t&&(t=this.length-e),t>this.length-e&&(t=this.length-e)),{start:e,length:t,backward:s}}}class o{constructor(e={}){this._stream=new i,this._length=0,this._start=0,this.backward=!1,this.appendBlock=0,this.prevLength=0,this.prevStart=0,this.stream="view"in e?new i({view:e.view}):"buffer"in e?new i({buffer:e.buffer}):"string"in e?new i({string:e.string}):"hexstring"in e?new i({hexstring:e.hexstring}):"stream"in e?e.stream.slice():new i,"backward"in e&&e.backward&&(this.backward=e.backward,this._start=this.stream.length),"length"in e&&e.length>0&&(this._length=e.length),"start"in e&&e.start&&e.start>0&&(this._start=e.start),"appendBlock"in e&&e.appendBlock&&e.appendBlock>0&&(this.appendBlock=e.appendBlock)}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e.length,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.length||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream.buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const s=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==s)return s;if(this.backward){if(s<this.start-e.length-t)return-1}else if(s>this.start+e.length+t)return-1;return this.start=s,s}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const s=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==s.id)return s;if(this.backward){if(s.position<this.start-e[s.id].length-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(s.position>this.start+e[s.id].length+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=s.position,s}findAllIn(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllIn(e,t,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const s=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==s.left.id&&-1==s.right.id)return s;if(this.backward){if(-1!=s.right.id&&s.right.position<this._start-e[s.right.id].length-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new i}}else if(-1!=s.left.id&&s.left.position>this._start+e[s.left.id].length+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new i};return this.backward?-1==s.left.id?this.start=0:this.start=s.left.position:-1==s.right.id?this.start=this._start+this._length:this.start=s.right.position,s}findAllNotIn(e){const t=this.backward?this._start-this._length:this._start;return this._stream.findAllNotIn(e,t,this._length)}findFirstSequence(e,t=null,s=null){(null==t||t>this._length)&&(t=this._length),(null==s||s>t)&&(s=t);const r=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==r.value.length)return r;if(this.backward){if(r.position<this._start-r.value.length-s)return{position:-1,value:new i}}else if(r.position>this._start+r.value.length+s)return{position:-1,value:new i};return this.start=r.position,r}findAllSequences(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllSequences(e,t,this.length)}findPairedPatterns(e,t,s=null){(null==s||s>this.length)&&(s=this.length);const r=this.backward?this.start-this.length:this.start,a=this.stream.findPairedPatterns(e,t,r,this.length);if(a.length)if(this.backward){if(a[0].right<this.start-t.length-s)return[]}else if(a[0].left>this.start+e.length+s)return[];return a}findPairedArrays(e,t,s=null){(null==s||s>this.length)&&(s=this.length);const r=this.backward?this.start-this.length:this.start,a=this.stream.findPairedArrays(e,t,r,this.length);if(a.length)if(this.backward){if(a[0].right.position<this.start-t[a[0].right.id].length-s)return[]}else if(a[0].left.position>this.start+e[a[0].left.id].length+s)return[];return a}replacePattern(e,t){const s=this.backward?this.start-this.length:this.start;return this.stream.replacePattern(e,t,s,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this.beforeAppend(e.length),this._stream.view.set(e.view,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendView(e){this.beforeAppend(e.length),this._stream.view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this.beforeAppend(1),this._stream.view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this.beforeAppend(2);const t=new Uint16Array([e]),s=new Uint8Array(t.buffer);this.stream.view[this._start]=s[1],this._stream.view[this._start+1]=s[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this.beforeAppend(3);const t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[2],this._stream.view[this._start+1]=s[1],this._stream.view[this._start+2]=s[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this.beforeAppend(4);const t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[3],this._stream.view[this._start+1]=s[2],this._stream.view[this._start+2]=s[1],this._stream.view[this._start+3]=s[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}appendInt16(e){this.beforeAppend(2);const t=new Int16Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[1],this._stream.view[this._start+1]=s[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendInt32(e){this.beforeAppend(4);const t=new Int32Array([e]),s=new Uint8Array(t.buffer);this._stream.view[this._start]=s[3],this._stream.view[this._start+1]=s[2],this._stream.view[this._start+2]=s[1],this._stream.view[this._start+3]=s[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return new Uint8Array(0);let s;if(this._length<e&&(e=this._length),this.backward){const t=this._stream.view.subarray(this._length-e,this._length);s=new Uint8Array(e);for(let r=0;r<e;r++)s[e-1-r]=t[r]}else s=this._stream.view.subarray(this._start,this._start+e);return t&&(this.start+=this.backward?-1*e:e),s}getUint16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const s=new Uint16Array(1),r=new Uint8Array(s.buffer);return r[0]=t[1],r[1]=t[0],s[0]}getInt16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const s=new Int16Array(1),r=new Uint8Array(s.buffer);return r[0]=t[1],r[1]=t[0],s[0]}getUint24(e=!0){const t=this.getBlock(3,e);if(t.length<3)return 0;const s=new Uint32Array(1),r=new Uint8Array(s.buffer);for(let e=3;e>=1;e--)r[3-e]=t[e-1];return s[0]}getUint32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const s=new Uint32Array(1),r=new Uint8Array(s.buffer);for(let e=3;e>=0;e--)r[3-e]=t[e];return s[0]}getInt32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const s=new Int32Array(1),r=new Uint8Array(s.buffer);for(let e=3;e>=0;e--)r[3-e]=t[e];return s[0]}beforeAppend(e){this._start+e>this._stream.length&&(e>this.appendBlock&&(this.appendBlock=e+o.APPEND_BLOCK),this._stream.realloc(this._stream.length+this.appendBlock))}}o.APPEND_BLOCK=1e3;const l=new ArrayBuffer(0),u="";class c extends TypeError{constructor(){super(...arguments),this.name=c.NAME}static isType(e,t){if("string"==typeof t){if("Array"===t&&Array.isArray(e))return!0;if("ArrayBuffer"===t&&e instanceof ArrayBuffer)return!0;if("ArrayBufferView"===t&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...s){for(const t of s)if(this.isType(e,t))return;const r=s.map((e=>e instanceof Function&&"name"in e?e.name:`${e}`));throw new c(`Parameter '${t}' is not of type ${r.length>1?`(${r.join(" or ")})`:r[0]}`)}}c.NAME="ArgumentError";class h extends TypeError{constructor(e,t=null,s){super(),this.name=h.NAME,this.field=e,t&&(this.target=t),this.message=s||`Absent mandatory parameter '${e}' ${t?` in '${t}'`:u}`}static assert(...e){let t,s,r=null;"string"==typeof e[0]?(r=e[0],t=e[1],s=e.slice(2)):(t=e[0],s=e.slice(1)),c.assert(t,"parameters","object");for(const e of s){const s=t[e];if(null==s)throw new h(e,r)}}static assertEmpty(e,t,s){if(null==e)throw new h(t,s)}}h.NAME="ParameterError";class m extends Error{static assertSchema(e,t){if(!e.verified)throw new Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(-1===e.offset)throw new m(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}}class f{static blockName(){return this.CLASS_NAME}static fromBER(e){const t=r.sc(e);m.assert(t,this.name);try{return new this({schema:t.result})}catch(e){throw new m(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch{t=this.toSchema(!0)}return a.ep.ToString(t.toBER(),e)}}function d(e){let t=!1,s=u;const r=e.trim();for(let e=0;e<r.length;e++)32===r.charCodeAt(e)?!1===t&&(t=!0):(t&&(s+=" ",t=!1),s+=r[e]);return s.toLowerCase()}f.CLASS_NAME="PkiObject";const g="type",p="value";class w extends f{constructor(e={}){super(),this.type=n.H$(e,g,w.defaultValues(g)),this.value=n.H$(e,p,w.defaultValues(p)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case g:return u;case p:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.type||u}),new r.IK({name:t.value||u})]})}fromSchema(e){n.ze(e,[g,"typeValue"]);const t=r.eN(e,e,w.schema({names:{type:g,value:"typeValue"}}));m.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new r.T9({value:[new r.rP({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){const t=[r.qU.blockName(),r.kE.blockName(),r.GM.blockName(),r.Tz.blockName(),r.Ox.blockName(),r.gF.blockName(),r.SZ.blockName(),r.$.blockName(),r.HQ.blockName(),r.NI.blockName(),r.EI.blockName(),r.Hk.blockName()];if(e instanceof ArrayBuffer)return a.vJ.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===w.blockName()){if(this.type!==e.type)return!1;const s=[!1,!1],r=this.value.constructor.blockName();for(const a of t)r===a&&(s[0]=!0),e.value.constructor.blockName()===a&&(s[1]=!0);if(s[0]!==s[1])return!1;if(s[0]&&s[1]){const t=d(this.value.valueBlock.value),s=d(e.value.valueBlock.value);if(0!==t.localeCompare(s))return!1}else if(!a.vJ.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}}w.CLASS_NAME="AttributeTypeAndValue";const y="typesAndValues",v="valueBeforeDecode";class b extends f{constructor(e={}){super(),this.typesAndValues=n.H$(e,y,b.defaultValues(y)),this.valueBeforeDecode=n.H$(e,v,b.defaultValues(v)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case y:return[];case v:return l;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case y:return 0===t.length;case v:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.repeatedSequence||u,value:new r.l4({value:[new r.ZD({name:t.repeatedSet||u,value:w.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){n.ze(e,["RDN",y]);const t=r.eN(e,e,b.schema({names:{blockName:"RDN",repeatedSet:y}}));m.assertSchema(t,this.className),y in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,(e=>new w({schema:e})))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new r.T9({value:[new r.l4({value:Array.from(this.typesAndValues,(e=>e.toSchema()))})]});const e=r.sc(this.valueBeforeDecode);if(m.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof r.T9))throw new Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,(e=>e.toJSON()))}}isEqual(e){if(e instanceof b){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,s]of this.typesAndValues.entries())if(!1===s.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&n.dN(this.valueBeforeDecode,e)}}b.CLASS_NAME="RelativeDistinguishedNames";const S="type",A="value";function k(e={},t=!1){const s=n.H$(e,"names",{});return new r.T9({optional:t,value:[new r.FC({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:s.country_name||u,value:[new r.Lv({value:[new r.Tz,new r.Ox]})]}),new r.FC({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:s.administration_domain_name||u,value:[new r.Lv({value:[new r.Tz,new r.Ox]})]}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:s.network_address||u,isHexOnly:!0}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:s.terminal_identifier||u,isHexOnly:!0}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:s.private_domain_name||u,value:[new r.Lv({value:[new r.Tz,new r.Ox]})]}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:s.organization_name||u,isHexOnly:!0}),new r.WV({optional:!0,name:s.numeric_user_identifier||u,idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new r.FC({optional:!0,name:s.personal_name||u,idBlock:{tagClass:3,tagNumber:5},value:[new r.WV({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new r.FC({optional:!0,name:s.organizational_unit_names||u,idBlock:{tagClass:3,tagNumber:6},value:[new r.ZD({value:new r.Ox})]})]})}function N(e=!1){return new r.T9({optional:e,value:[new r.Ox,new r.Ox]})}function C(e=!1){return new r.l4({optional:e,value:[new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.IK]})]})}class B extends f{constructor(e={}){super(),this.type=n.H$(e,S,B.defaultValues(S)),this.value=n.H$(e,A,B.defaultValues(A)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case S:return 9;case A:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case S:return t===B.defaultValues(e);case A:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.Lv({value:[new r.FC({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||u,value:[new r.rP,new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK]})]}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:1}}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:2}}),new r.FC({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||u,value:[k(t.builtInStandardAttributes||{},!1),N(!0),C(!0)]}),new r.FC({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||u,value:[b.schema(t.directoryName||{})]}),new r.FC({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||u,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.Lv({value:[new r.gF,new r.Ox,new r.GM,new r.qU,new r.kE]})]}),new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[new r.Lv({value:[new r.gF,new r.Ox,new r.GM,new r.qU,new r.kE]})]})]}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:6}}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:7}}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){n.ze(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=r.eN(e,e,B.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(m.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:case 3:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const s=e.toBER(!1),a=r.sc(s);m.assert(a,"GeneralName value"),this.value=a.result.valueBlock.value}break;case 4:this.value=new b({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new r.fi({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const s=e.toBER(!1),a=r.sc(s);m.assert(a,"GeneralName registeredID"),this.value=a.result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new r.FC({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new r.$({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new r.FC({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new r.rP({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return B.schema()}}toJSON(){const e={type:this.type,value:u};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}B.CLASS_NAME="GeneralName";const V="accessMethod",I="accessLocation",E=[V,I];class H extends f{constructor(e={}){super(),this.accessMethod=n.H$(e,V,H.defaultValues(V)),this.accessLocation=n.H$(e,I,H.defaultValues(I)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case V:return u;case I:return new B;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.accessMethod||u}),B.schema(t.accessLocation||{})]})}fromSchema(e){n.ze(e,E);const t=r.eN(e,e,H.schema({names:{accessMethod:V,accessLocation:{names:{blockName:I}}}}));m.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new B({schema:t.result.accessLocation})}toSchema(){return new r.T9({value:[new r.rP({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}H.CLASS_NAME="AccessDescription";const x="seconds",D="millis",O="micros";class T extends f{constructor(e={}){super(),x in e&&(this.seconds=n.H$(e,x,T.defaultValues(x))),D in e&&(this.millis=n.H$(e,D,T.defaultValues(D))),O in e&&(this.micros=n.H$(e,O,T.defaultValues(O))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case x:case D:case O:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case x:case D:case O:return t===T.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,optional:!0,value:[new r.z8({optional:!0,name:t.seconds||u}),new r.WV({name:t.millis||u,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new r.WV({name:t.micros||u,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){n.ze(e,[x,D,O]);const t=r.eN(e,e,T.schema({names:{seconds:x,millis:D,micros:O}}));if(m.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){const e=new r.z8({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){const e=new r.z8({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){const e=[];if(void 0!==this.seconds&&e.push(new r.z8({value:this.seconds})),void 0!==this.millis){const t=new r.z8({value:this.millis});e.push(new r.WV({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(void 0!==this.micros){const t=new r.z8({value:this.micros});e.push(new r.WV({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new r.T9({value:e})}toJSON(){const e={};return void 0!==this.seconds&&(e.seconds=this.seconds),void 0!==this.millis&&(e.millis=this.millis),void 0!==this.micros&&(e.micros=this.micros),e}}T.CLASS_NAME="Accuracy";const P="algorithmId",U="algorithmParams",$="algorithm",L="params",R=[$,L];class K extends f{constructor(e={}){super(),this.algorithmId=n.H$(e,P,K.defaultValues(P)),U in e&&(this.algorithmParams=n.H$(e,U,K.defaultValues(U))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case P:return u;case U:return new r.IK;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case P:return t===u;case U:return t instanceof r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,optional:t.optional||!1,value:[new r.rP({name:t.algorithmIdentifier||u}),new r.IK({name:t.algorithmParams||u,optional:!0})]})}fromSchema(e){n.ze(e,R);const t=r.eN(e,e,K.schema({names:{algorithmIdentifier:$,algorithmParams:L}}));m.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),L in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new r.rP({value:this.algorithmId})),!this.algorithmParams||this.algorithmParams instanceof r.IK||e.push(this.algorithmParams),new r.T9({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return!this.algorithmParams||this.algorithmParams instanceof r.IK||(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof K&&(this.algorithmId===e.algorithmId&&(this.algorithmParams?!!e.algorithmParams&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!e.algorithmParams))}}K.CLASS_NAME="AlgorithmIdentifier";const J="altNames",_=[J];class F extends f{constructor(e={}){super(),this.altNames=n.H$(e,J,F.defaultValues(J)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===J?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.altNames||u,value:B.schema()})]})}fromSchema(e){n.ze(e,_);const t=r.eN(e,e,F.schema({names:{altNames:J}}));m.assertSchema(t,this.className),J in t.result&&(this.altNames=Array.from(t.result.altNames,(e=>new B({schema:e}))))}toSchema(){return new r.T9({value:Array.from(this.altNames,(e=>e.toSchema()))})}toJSON(){return{altNames:Array.from(this.altNames,(e=>e.toJSON()))}}}F.CLASS_NAME="AltName";const M="type",j="values",q=[M,j];class z extends f{constructor(e={}){super(),this.type=n.H$(e,M,z.defaultValues(M)),this.values=n.H$(e,j,z.defaultValues(j)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case M:return u;case j:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case M:return t===u;case j:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.type||u}),new r.l4({name:t.setName||u,value:[new r.ZD({name:t.values||u,value:new r.IK})]})]})}fromSchema(e){n.ze(e,q);const t=r.eN(e,e,z.schema({names:{type:M,values:j}}));m.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new r.T9({value:[new r.rP({value:this.type}),new r.l4({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,(e=>e.toJSON()))}}}z.CLASS_NAME="Attribute";const W="notBeforeTime",G="notAfterTime",Z=[W,G];class Y extends f{constructor(e={}){super(),this.notBeforeTime=n.H$(e,W,Y.defaultValues(W)),this.notAfterTime=n.H$(e,G,Y.defaultValues(G)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case W:case G:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.Yw({name:t.notBeforeTime||u}),new r.Yw({name:t.notAfterTime||u})]})}fromSchema(e){n.ze(e,Z);const t=r.eN(e,e,Y.schema({names:{notBeforeTime:W,notAfterTime:G}}));m.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new r.T9({value:[new r.Yw({valueDate:this.notBeforeTime}),new r.Yw({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}Y.CLASS_NAME="AttCertValidityPeriod";const Q="names",X="generalNames";class ee extends f{constructor(e={}){super(),this.names=n.H$(e,Q,ee.defaultValues(Q)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"names"===e?[]:super.defaultValues(e)}static schema(e={},t=!1){const s=n.H$(e,Q,{});return new r.T9({optional:t,name:s.blockName||u,value:[new r.ZD({name:s.generalNames||u,value:B.schema()})]})}fromSchema(e){n.ze(e,[Q,X]);const t=r.eN(e,e,ee.schema({names:{blockName:Q,generalNames:X}}));m.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,(e=>new B({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.names,(e=>e.toSchema()))})}toJSON(){return{names:Array.from(this.names,(e=>e.toJSON()))}}}ee.CLASS_NAME="GeneralNames";const te="2.5.29.17",se="2.5.29.18",re="2.5.29.19",ae="2.5.29.28",ne="2.5.29.29",ie="2.5.29.30",oe="2.5.29.31",le="2.5.29.46",ue="2.5.29.32",ce="2.5.29.32.0",he="2.5.29.33",me="2.5.29.35",fe="2.5.29.36",de="1.3.6.1.5.5.7.1.1",ge="1.3.6.1.4.1.11129.2.4.2",pe="1.2.840.113549.1.7.1",we="1.2.840.113549.1.7.2",ye="1.2.840.113549.1.7.3",ve="1.2.840.113549.1.7.6",be="1.2.840.113549.1.9.22.1",Se="1.2.840.113549.1.9.22.3",Ae="1.2.840.113549.1.9.23.1",ke="1.3.6.1.5.5.7.48",Ne=`${ke}.1.1`,Ce="keyIdentifier",Be="authorityCertIssuer",Ve="authorityCertSerialNumber",Ie=[Ce,Be,Ve];class Ee extends f{constructor(e={}){super(),Ce in e&&(this.keyIdentifier=n.H$(e,Ce,Ee.defaultValues(Ce))),Be in e&&(this.authorityCertIssuer=n.H$(e,Be,Ee.defaultValues(Be))),Ve in e&&(this.authorityCertSerialNumber=n.H$(e,Ve,Ee.defaultValues(Ve))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ce:return new r.fi;case Be:return[];case Ve:return new r.z8;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.WV({name:t.keyIdentifier||u,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.ZD({name:t.authorityCertIssuer||u,value:B.schema()})]}),new r.WV({name:t.authorityCertSerialNumber||u,optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){n.ze(e,Ie);const t=r.eN(e,e,Ee.schema({names:{keyIdentifier:Ce,authorityCertIssuer:Be,authorityCertSerialNumber:Ve}}));m.assertSchema(t,this.className),Ce in t.result&&(this.keyIdentifier=new r.fi({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),Be in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,(e=>new B({schema:e})))),Ve in t.result&&(this.authorityCertSerialNumber=new r.z8({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return this.keyIdentifier&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,(e=>e.toSchema()))})),this.authorityCertSerialNumber&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new r.T9({value:e})}toJSON(){const e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,(e=>e.toJSON()))),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}Ee.CLASS_NAME="AuthorityKeyIdentifier";const He="pathLenConstraint",xe="cA";class De extends f{constructor(e={}){super(),this.cA=n.H$(e,xe,!1),He in e&&(this.pathLenConstraint=n.H$(e,He,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e!==xe&&super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ge({optional:!0,name:t.cA||u}),new r.z8({optional:!0,name:t.pathLenConstraint||u})]})}fromSchema(e){n.ze(e,[xe,He]);const t=r.eN(e,e,De.schema({names:{cA:xe,pathLenConstraint:He}}));m.assertSchema(t,this.className),xe in t.result&&(this.cA=t.result.cA.valueBlock.value),He in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==De.defaultValues(xe)&&e.push(new r.ge({value:this.cA})),He in this&&(this.pathLenConstraint instanceof r.z8?e.push(this.pathLenConstraint):e.push(new r.z8({value:this.pathLenConstraint}))),new r.T9({value:e})}toJSON(){const e={};return this.cA!==De.defaultValues(xe)&&(e.cA=this.cA),He in this&&(this.pathLenConstraint instanceof r.z8?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}De.CLASS_NAME="BasicConstraints";const Oe="certificateIndex",Te="keyIndex";class Pe extends f{constructor(e={}){super(),this.certificateIndex=n.H$(e,Oe,Pe.defaultValues(Oe)),this.keyIndex=n.H$(e,Te,Pe.defaultValues(Te)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Oe:case Te:return 0;default:return super.defaultValues(e)}}static schema(){return new r.z8}fromSchema(e){if(e.constructor.blockName()!==r.z8.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const s=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(s,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(s.slice(0,4)),t=e.slice(0)}}const a=t.slice(0,2),n=new Uint8Array(a);let i=n[0];n[0]=n[1],n[1]=i;const o=new Uint16Array(a);this.keyIndex=o[0];const l=t.slice(2),u=new Uint8Array(l);i=u[0],u[0]=u[1],u[1]=i;const c=new Uint16Array(l);this.certificateIndex=c[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let s=t[0];t[0]=t[1],t[1]=s;const a=new ArrayBuffer(2);new Uint16Array(a)[0]=this.keyIndex;const i=new Uint8Array(a);return s=i[0],i[0]=i[1],i[1]=s,new r.z8({valueHex:n.hk(a,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}Pe.CLASS_NAME="CAVersion";const Ue="policyQualifierId",$e="qualifier",Le=[Ue,$e];class Re extends f{constructor(e={}){super(),this.policyQualifierId=n.H$(e,Ue,Re.defaultValues(Ue)),this.qualifier=n.H$(e,$e,Re.defaultValues($e)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ue:return u;case $e:return new r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.policyQualifierId||u}),new r.IK({name:t.qualifier||u})]})}fromSchema(e){n.ze(e,Le);const t=r.eN(e,e,Re.schema({names:{policyQualifierId:Ue,qualifier:$e}}));m.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new r.T9({value:[new r.rP({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}Re.CLASS_NAME="PolicyQualifierInfo";const Ke="policyIdentifier",Je="policyQualifiers",_e=[Ke,Je];class Fe extends f{constructor(e={}){super(),this.policyIdentifier=n.H$(e,Ke,Fe.defaultValues(Ke)),Je in e&&(this.policyQualifiers=n.H$(e,Je,Fe.defaultValues(Je))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ke:return u;case Je:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.policyIdentifier||u}),new r.T9({optional:!0,value:[new r.ZD({name:t.policyQualifiers||u,value:Re.schema()})]})]})}fromSchema(e){n.ze(e,_e);const t=r.eN(e,e,Fe.schema({names:{policyIdentifier:Ke,policyQualifiers:Je}}));m.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),Je in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,(e=>new Re({schema:e}))))}toSchema(){const e=[];return e.push(new r.rP({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new r.T9({value:Array.from(this.policyQualifiers,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,(e=>e.toJSON()))),e}}Fe.CLASS_NAME="PolicyInformation";const Me="certificatePolicies",je=[Me];class qe extends f{constructor(e={}){super(),this.certificatePolicies=n.H$(e,Me,qe.defaultValues(Me)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Me?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.certificatePolicies||u,value:Fe.schema()})]})}fromSchema(e){n.ze(e,je);const t=r.eN(e,e,qe.schema({names:{certificatePolicies:Me}}));m.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,(e=>new Fe({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.certificatePolicies,(e=>e.toSchema()))})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,(e=>e.toJSON()))}}}qe.CLASS_NAME="CertificatePolicies";const ze="templateID",We="templateMajorVersion",Ge="templateMinorVersion",Ze=[ze,We,Ge];class Ye extends f{constructor(e={}){super(),this.templateID=n.H$(e,ze,Ye.defaultValues(ze)),We in e&&(this.templateMajorVersion=n.H$(e,We,Ye.defaultValues(We))),Ge in e&&(this.templateMinorVersion=n.H$(e,Ge,Ye.defaultValues(Ge))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ze:return u;case We:case Ge:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.templateID||u}),new r.z8({name:t.templateMajorVersion||u,optional:!0}),new r.z8({name:t.templateMinorVersion||u,optional:!0})]})}fromSchema(e){n.ze(e,Ze);const t=r.eN(e,e,Ye.schema({names:{templateID:ze,templateMajorVersion:We,templateMinorVersion:Ge}}));m.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),We in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),Ge in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new r.rP({value:this.templateID})),We in this&&e.push(new r.z8({value:this.templateMajorVersion})),Ge in this&&e.push(new r.z8({value:this.templateMinorVersion})),new r.T9({value:e})}toJSON(){const e={templateID:this.templateID};return We in this&&(e.templateMajorVersion=this.templateMajorVersion),Ge in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}const Qe="distributionPoint",Xe="distributionPointNames",et="reasons",tt="cRLIssuer",st="cRLIssuerNames",rt=[Qe,Xe,et,tt,st];class at extends f{constructor(e={}){super(),Qe in e&&(this.distributionPoint=n.H$(e,Qe,at.defaultValues(Qe))),et in e&&(this.reasons=n.H$(e,et,at.defaultValues(et))),tt in e&&(this.cRLIssuer=n.H$(e,tt,at.defaultValues(tt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qe:return[];case et:return new r._K;case tt:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.Lv({value:[new r.FC({name:t.distributionPoint||u,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({name:t.distributionPointNames||u,value:B.schema()})]}),new r.FC({name:t.distributionPoint||u,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:b.schema().valueBlock.value})]})]}),new r.WV({name:t.reasons||u,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new r.FC({name:t.cRLIssuer||u,optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new r.ZD({name:t.cRLIssuerNames||u,value:B.schema()})]})]})}fromSchema(e){n.ze(e,rt);const t=r.eN(e,e,at.schema({names:{distributionPoint:Qe,distributionPointNames:Xe,reasons:et,cRLIssuer:tt,cRLIssuerNames:st}}));m.assertSchema(t,this.className),Qe in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,(e=>new B({schema:e})))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new b({schema:new r.T9({value:t.result.distributionPoint.valueBlock.value})}))),et in t.result&&(this.reasons=new r._K({valueHex:t.result.reasons.valueBlock.valueHex})),tt in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,(e=>new B({schema:e}))))}toSchema(){const e=[];if(this.distributionPoint){let t;t=this.distributionPoint instanceof Array?new r.FC({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,(e=>e.toSchema()))}):new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,(e=>e.toJSON())):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,(e=>e.toJSON()))),e}}at.CLASS_NAME="DistributionPoint";const nt="distributionPoints",it=[nt];class ot extends f{constructor(e={}){super(),this.distributionPoints=n.H$(e,nt,ot.defaultValues(nt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===nt?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.distributionPoints||u,value:at.schema()})]})}fromSchema(e){n.ze(e,it);const t=r.eN(e,e,ot.schema({names:{distributionPoints:nt}}));m.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,(e=>new at({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.distributionPoints,(e=>e.toSchema()))})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,(e=>e.toJSON()))}}}ot.CLASS_NAME="CRLDistributionPoints";const lt="keyPurposes",ut=[lt];class ct extends f{constructor(e={}){super(),this.keyPurposes=n.H$(e,lt,ct.defaultValues(lt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===lt?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.keyPurposes||u,value:new r.rP})]})}fromSchema(e){n.ze(e,ut);const t=r.eN(e,e,ct.schema({names:{keyPurposes:lt}}));m.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,(e=>e.valueBlock.toString()))}toSchema(){return new r.T9({value:Array.from(this.keyPurposes,(e=>new r.rP({value:e})))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}ct.CLASS_NAME="ExtKeyUsage";const ht="accessDescriptions";class mt extends f{constructor(e={}){super(),this.accessDescriptions=n.H$(e,ht,mt.defaultValues(ht)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===ht?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.accessDescriptions||u,value:H.schema()})]})}fromSchema(e){n.ze(e,[ht]);const t=r.eN(e,e,mt.schema({names:{accessDescriptions:ht}}));m.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,(e=>new H({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.accessDescriptions,(e=>e.toSchema()))})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,(e=>e.toJSON()))}}}mt.CLASS_NAME="InfoAccess";const ft="distributionPoint",dt="distributionPointNames",gt="onlyContainsUserCerts",pt="onlyContainsCACerts",wt="onlySomeReasons",yt="indirectCRL",vt="onlyContainsAttributeCerts",bt=[ft,dt,gt,pt,wt,yt,vt];class St extends f{constructor(e={}){super(),ft in e&&(this.distributionPoint=n.H$(e,ft,St.defaultValues(ft))),this.onlyContainsUserCerts=n.H$(e,gt,St.defaultValues(gt)),this.onlyContainsCACerts=n.H$(e,pt,St.defaultValues(pt)),wt in e&&(this.onlySomeReasons=n.H$(e,wt,St.defaultValues(wt))),this.indirectCRL=n.H$(e,yt,St.defaultValues(yt)),this.onlyContainsAttributeCerts=n.H$(e,vt,St.defaultValues(vt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ft:return[];case gt:case pt:return!1;case wt:return 0;case yt:case vt:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.Lv({value:[new r.FC({name:t.distributionPoint||u,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({name:t.distributionPointNames||u,value:B.schema()})]}),new r.FC({name:t.distributionPoint||u,idBlock:{tagClass:3,tagNumber:1},value:b.schema().valueBlock.value})]})]}),new r.WV({name:t.onlyContainsUserCerts||u,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new r.WV({name:t.onlyContainsCACerts||u,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new r.WV({name:t.onlySomeReasons||u,optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new r.WV({name:t.indirectCRL||u,optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new r.WV({name:t.onlyContainsAttributeCerts||u,optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){n.ze(e,bt);const t=r.eN(e,e,St.schema({names:{distributionPoint:ft,distributionPointNames:dt,onlyContainsUserCerts:gt,onlyContainsCACerts:pt,onlySomeReasons:wt,indirectCRL:yt,onlyContainsAttributeCerts:vt}}));if(m.assertSchema(t,this.className),ft in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,(e=>new B({schema:e})));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new b({schema:new r.T9({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(gt in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if(pt in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if(wt in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if(yt in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if(vt in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new r.FC({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,(e=>e.toSchema()))}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==St.defaultValues(gt)&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==St.defaultValues(pt)&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),void 0!==this.onlySomeReasons){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new r.WV({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==St.defaultValues(yt)&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==St.defaultValues(vt)&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new r.T9({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,(e=>e.toJSON())):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==St.defaultValues(gt)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==St.defaultValues(pt)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),wt in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==St.defaultValues(yt)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==St.defaultValues(vt)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}St.CLASS_NAME="IssuingDistributionPoint";const At="base",kt="minimum",Nt="maximum",Ct=[At,kt,Nt];class Bt extends f{constructor(e={}){super(),this.base=n.H$(e,At,Bt.defaultValues(At)),this.minimum=n.H$(e,kt,Bt.defaultValues(kt)),Nt in e&&(this.maximum=n.H$(e,Nt,Bt.defaultValues(Nt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case At:return new B;case kt:case Nt:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[B.schema(t.base||{}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({name:t.minimum||u})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.z8({name:t.maximum||u})]})]})}fromSchema(e){n.ze(e,Ct);const t=r.eN(e,e,Bt.schema({names:{base:{names:{blockName:At}},minimum:kt,maximum:Nt}}));m.assertSchema(t,this.className),this.base=new B({schema:t.result.base}),kt in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),Nt in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof r.z8?this.minimum:new r.z8({value:this.minimum}),e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(Nt in this){let t=0;t=this.maximum instanceof r.z8?this.maximum:new r.z8({value:this.maximum}),e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new r.T9({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),void 0!==this.maximum&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}Bt.CLASS_NAME="GeneralSubtree";const Vt="permittedSubtrees",It="excludedSubtrees",Et=[Vt,It];class Ht extends f{constructor(e={}){super(),Vt in e&&(this.permittedSubtrees=n.H$(e,Vt,Ht.defaultValues(Vt))),It in e&&(this.excludedSubtrees=n.H$(e,It,Ht.defaultValues(It))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vt:case It:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({name:t.permittedSubtrees||u,value:Bt.schema()})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.ZD({name:t.excludedSubtrees||u,value:Bt.schema()})]})]})}fromSchema(e){n.ze(e,Et);const t=r.eN(e,e,Ht.schema({names:{permittedSubtrees:Vt,excludedSubtrees:It}}));m.assertSchema(t,this.className),Vt in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,(e=>new Bt({schema:e})))),It in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,(e=>new Bt({schema:e}))))}toSchema(){const e=[];return this.permittedSubtrees&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,(e=>e.toSchema()))})),this.excludedSubtrees&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,(e=>e.toJSON()))),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,(e=>e.toJSON()))),e}}Ht.CLASS_NAME="NameConstraints";const xt="requireExplicitPolicy",Dt="inhibitPolicyMapping",Ot=[xt,Dt];class Tt extends f{constructor(e={}){super(),xt in e&&(this.requireExplicitPolicy=n.H$(e,xt,Tt.defaultValues(xt))),Dt in e&&(this.inhibitPolicyMapping=n.H$(e,Dt,Tt.defaultValues(Dt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xt:case Dt:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.WV({name:t.requireExplicitPolicy||u,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new r.WV({name:t.inhibitPolicyMapping||u,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){n.ze(e,Ot);const t=r.eN(e,e,Tt.schema({names:{requireExplicitPolicy:xt,inhibitPolicyMapping:Dt}}));if(m.assertSchema(t,this.className),xt in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const s=e.toBER(!1),a=r.sc(s);m.assert(a,"Integer"),this.requireExplicitPolicy=a.result.valueBlock.valueDec}if(Dt in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const s=e.toBER(!1),a=r.sc(s);m.assert(a,"Integer"),this.inhibitPolicyMapping=a.result.valueBlock.valueDec}}toSchema(){const e=[];if(xt in this){const t=new r.z8({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(Dt in this){const t=new r.z8({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new r.T9({value:e})}toJSON(){const e={};return xt in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),Dt in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}Tt.CLASS_NAME="PolicyConstraints";const Pt="issuerDomainPolicy",Ut="subjectDomainPolicy",$t=[Pt,Ut];class Lt extends f{constructor(e={}){super(),this.issuerDomainPolicy=n.H$(e,Pt,Lt.defaultValues(Pt)),this.subjectDomainPolicy=n.H$(e,Ut,Lt.defaultValues(Ut)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pt:case Ut:return u;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.issuerDomainPolicy||u}),new r.rP({name:t.subjectDomainPolicy||u})]})}fromSchema(e){n.ze(e,$t);const t=r.eN(e,e,Lt.schema({names:{issuerDomainPolicy:Pt,subjectDomainPolicy:Ut}}));m.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new r.T9({value:[new r.rP({value:this.issuerDomainPolicy}),new r.rP({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}Lt.CLASS_NAME="PolicyMapping";const Rt="mappings",Kt=[Rt];class Jt extends f{constructor(e={}){super(),this.mappings=n.H$(e,Rt,Jt.defaultValues(Rt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Rt?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.mappings||u,value:Lt.schema()})]})}fromSchema(e){n.ze(e,Kt);const t=r.eN(e,e,Jt.schema({names:{mappings:Rt}}));m.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,(e=>new Lt({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.mappings,(e=>e.toSchema()))})}toJSON(){return{mappings:Array.from(this.mappings,(e=>e.toJSON()))}}}Jt.CLASS_NAME="PolicyMappings";const _t="notBefore",Ft="notAfter",Mt=[_t,Ft];class jt extends f{constructor(e={}){super(),_t in e&&(this.notBefore=n.H$(e,_t,jt.defaultValues(_t))),Ft in e&&(this.notAfter=n.H$(e,Ft,jt.defaultValues(Ft))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _t:case Ft:return new Date;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.WV({name:t.notBefore||u,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new r.WV({name:t.notAfter||u,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){n.ze(e,Mt);const t=r.eN(e,e,jt.schema({names:{notBefore:_t,notAfter:Ft}}));if(m.assertSchema(t,this.className),_t in t.result){const e=new r.Yw;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if(Ft in t.result){const e=new r.Yw({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return _t in this&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:0},valueHex:new r.Yw({valueDate:this.notBefore}).valueBlock.valueHexView})),Ft in this&&e.push(new r.WV({idBlock:{tagClass:3,tagNumber:1},valueHex:new r.Yw({valueDate:this.notAfter}).valueBlock.valueHexView})),new r.T9({value:e})}toJSON(){const e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}}jt.CLASS_NAME="PrivateKeyUsagePeriod";const qt="id",zt="type",Wt="values",Gt=[qt,zt],Zt=[Wt];class Yt extends f{constructor(e={}){super(),this.id=n.H$(e,qt,Yt.defaultValues(qt)),zt in e&&(this.type=n.H$(e,zt,Yt.defaultValues(zt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case qt:return u;case zt:return new r.p2;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case qt:return t===u;case zt:return t instanceof r.p2;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.id||u}),new r.IK({name:t.type||u,optional:!0})]})}fromSchema(e){n.ze(e,Gt);const t=r.eN(e,e,Yt.schema({names:{id:qt,type:zt}}));m.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),zt in t.result&&(this.type=t.result.type)}toSchema(){const e=[new r.rP({value:this.id})];return zt in this&&e.push(this.type),new r.T9({value:e})}toJSON(){const e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}}Yt.CLASS_NAME="QCStatement";class Qt extends f{constructor(e={}){super(),this.values=n.H$(e,Wt,Qt.defaultValues(Wt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Wt?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Wt?0===t.length:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.values||u,value:Yt.schema(t.value||{})})]})}fromSchema(e){n.ze(e,Zt);const t=r.eN(e,e,Qt.schema({names:{values:Wt}}));m.assertSchema(t,this.className),this.values=Array.from(t.result.values,(e=>new Yt({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.values,(e=>e.toSchema()))})}toJSON(){return{values:Array.from(this.values,(e=>e.toJSON()))}}}var Xt;Qt.CLASS_NAME="QCStatements";class es{static register(e,t,s){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:s}}static find(e){return this.namedCurves[e.toLowerCase()]||null}}Xt=es,es.namedCurves={},Xt.register("P-256","1.2.840.10045.3.1.7",32),Xt.register("P-384","1.3.132.0.34",48),Xt.register("P-521","1.3.132.0.35",66),Xt.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),Xt.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),Xt.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);const ts="x",ss="y",rs="namedCurve";class as extends f{constructor(e={}){super(),this.x=n.H$(e,ts,as.defaultValues(ts)),this.y=n.H$(e,ss,as.defaultValues(ss)),this.namedCurve=n.H$(e,rs,as.defaultValues(rs)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ts:case ss:return l;case rs:return u;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ts:case ss:return t instanceof ArrayBuffer&&n.dN(t,as.defaultValues(e));case rs:return"string"==typeof t&&t===as.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new r.Gh}fromSchema(e){const t=a.vJ.toUint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");const s=es.find(this.namedCurve);if(!s)throw new Error(`Incorrect curve OID: ${this.namedCurve}`);const r=s.size;if(t.byteLength!==2*r+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=s.name,this.x=t.slice(1,r+1).buffer,this.y=t.slice(1+r,2*r+1).buffer}toSchema(){return new r.Gh({data:n.hk(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){const e=es.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:n.s3(n.lE(this.x),!0,!0,!1),y:n.s3(n.lE(this.y),!0,!0,!1)}}fromJSON(e){h.assert("json",e,"crv","x","y");let t=0;const s=es.find(e.crv);s&&(this.namedCurve=s.id,t=s.size);const r=n.gG(n.Gh(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(s,1)}else this.x=r.slice(0,t);const a=n.gG(n.Gh(e.y,!0));if(a.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(a);e.set(s,1)}else this.y=a.slice(0,t)}}as.CLASS_NAME="ECPublicKey";const ns="modulus",is="publicExponent",os=[ns,is];class ls extends f{constructor(e={}){super(),this.modulus=n.H$(e,ns,ls.defaultValues(ns)),this.publicExponent=n.H$(e,is,ls.defaultValues(is)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ns:case is:return new r.z8;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.modulus||u}),new r.z8({name:t.publicExponent||u})]})}fromSchema(e){n.ze(e,os);const t=r.eN(e,e,ls.schema({names:{modulus:ns,publicExponent:is}}));m.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new r.T9({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:a.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:a.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){h.assert("json",e,"n","e");const t=n.gG(n.Gh(e.n,!0));this.modulus=new r.z8({valueHex:t.slice(0,Math.pow(2,n.J$(t.byteLength)))}),this.publicExponent=new r.z8({valueHex:n.gG(n.Gh(e.e,!0)).slice(0,3)})}}ls.CLASS_NAME="RSAPublicKey";const us="algorithm",cs="subjectPublicKey",hs=[us,cs];class ms extends f{constructor(e={}){super(),this.algorithm=n.H$(e,us,ms.defaultValues(us)),this.subjectPublicKey=n.H$(e,cs,ms.defaultValues(cs));const t=n.H$(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}get parsedKey(){if(void 0===this._parsedKey){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===r.rP.blockName())try{this._parsedKey=new as({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=r.sc(this.subjectPublicKey.valueBlock.valueHexView);if(-1!==e.offset)try{this._parsedKey=new ls({schema:e.result})}catch(e){}}}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}static defaultValues(e){switch(e){case us:return new K;case cs:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.algorithm||{}),new r._K({name:t.subjectPublicKey||u})]})}fromSchema(e){n.ze(e,hs);const t=r.eN(e,e,ms.schema({names:{algorithm:{names:{blockName:us}},subjectPublicKey:cs}}));m.assertSchema(t,this.className),this.algorithm=new K({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new r.T9({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new as({json:e}),this.algorithm=new K({algorithmId:"1.2.840.10045.2.1",algorithmParams:new r.rP({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new ls({json:e}),this.algorithm=new K({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new r.p2});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new r._K({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=pr(!0)){try{if(!e)throw new Error("Need to provide publicKey input parameter");const s=await t.exportKey("spki",e),a=r.sc(s);try{this.fromSchema(a.result)}catch(e){throw new Error("Error during initializing object from schema")}}catch(e){const t=e instanceof Error?e.message:`${e}`;throw new Error(`Error during exporting public key: ${t}`)}}}ms.CLASS_NAME="PublicKeyInfo";const fs="version",ds="privateKey",gs="namedCurve",ps="publicKey",ws=[fs,ds,gs,ps];class ys extends f{constructor(e={}){super(),this.version=n.H$(e,fs,ys.defaultValues(fs)),this.privateKey=n.H$(e,ds,ys.defaultValues(ds)),gs in e&&(this.namedCurve=n.H$(e,gs,ys.defaultValues(gs))),ps in e&&(this.publicKey=n.H$(e,ps,ys.defaultValues(ps))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fs:return 1;case ds:return new r.fi;case gs:return u;case ps:return new as;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fs:return t===ys.defaultValues(e);case ds:return t.isEqual(ys.defaultValues(e));case gs:return t===u;case ps:return as.compareWithDefault(gs,t.namedCurve)&&as.compareWithDefault("x",t.x)&&as.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.fi({name:t.privateKey||u}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.rP({name:t.namedCurve||u})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r._K({name:t.publicKey||u})]})]})}fromSchema(e){n.ze(e,ws);const t=r.eN(e,e,ys.schema({names:{version:fs,privateKey:ds,namedCurve:gs,publicKey:ps}}));if(m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,gs in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),ps in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};gs in this&&(e.namedCurve=this.namedCurve),this.publicKey=new as(e)}}toSchema(){const e=[new r.z8({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.rP({value:this.namedCurve})]})),this.publicKey&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[new r._K({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new r.T9({value:e})}toJSON(){if(!this.namedCurve||ys.compareWithDefault(gs,this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');const e=es.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:a.ep.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){h.assert("json",e,"crv","d");let t=0;const s=es.find(e.crv);s&&(this.namedCurve=s.id,t=s.size);const n=a.ep.FromBase64Url(e.d);if(n.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),a=new Uint8Array(n);s.set(a,1),this.privateKey=new r.fi({valueHex:e})}else this.privateKey=new r.fi({valueHex:n.slice(0,t)});e.x&&e.y&&(this.publicKey=new as({json:e}))}}ys.CLASS_NAME="ECPrivateKey";const vs="prime",bs="exponent",Ss="coefficient",As=[vs,bs,Ss];class ks extends f{constructor(e={}){super(),this.prime=n.H$(e,vs,ks.defaultValues(vs)),this.exponent=n.H$(e,bs,ks.defaultValues(bs)),this.coefficient=n.H$(e,Ss,ks.defaultValues(Ss)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vs:case bs:case Ss:return new r.z8;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.prime||u}),new r.z8({name:t.exponent||u}),new r.z8({name:t.coefficient||u})]})}fromSchema(e){n.ze(e,As);const t=r.eN(e,e,ks.schema({names:{prime:vs,exponent:bs,coefficient:Ss}}));m.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new r.T9({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:a.ep.ToBase64Url(this.prime.valueBlock.valueHexView),d:a.ep.ToBase64Url(this.exponent.valueBlock.valueHexView),t:a.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){h.assert("json",e,"r","d","r"),this.prime=new r.z8({valueHex:a.ep.FromBase64Url(e.r)}),this.exponent=new r.z8({valueHex:a.ep.FromBase64Url(e.d)}),this.coefficient=new r.z8({valueHex:a.ep.FromBase64Url(e.t)})}}ks.CLASS_NAME="OtherPrimeInfo";const Ns="version",Cs="modulus",Bs="publicExponent",Vs="privateExponent",Is="prime1",Es="prime2",Hs="exponent1",xs="exponent2",Ds="coefficient",Os="otherPrimeInfos",Ts=[Ns,Cs,Bs,Vs,Is,Es,Hs,xs,Ds,Os];class Ps extends f{constructor(e={}){super(),this.version=n.H$(e,Ns,Ps.defaultValues(Ns)),this.modulus=n.H$(e,Cs,Ps.defaultValues(Cs)),this.publicExponent=n.H$(e,Bs,Ps.defaultValues(Bs)),this.privateExponent=n.H$(e,Vs,Ps.defaultValues(Vs)),this.prime1=n.H$(e,Is,Ps.defaultValues(Is)),this.prime2=n.H$(e,Es,Ps.defaultValues(Es)),this.exponent1=n.H$(e,Hs,Ps.defaultValues(Hs)),this.exponent2=n.H$(e,xs,Ps.defaultValues(xs)),this.coefficient=n.H$(e,Ds,Ps.defaultValues(Ds)),Os in e&&(this.otherPrimeInfos=n.H$(e,Os,Ps.defaultValues(Os))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ns:return 0;case Cs:case Bs:case Vs:case Is:case Es:case Hs:case xs:case Ds:return new r.z8;case Os:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.z8({name:t.modulus||u}),new r.z8({name:t.publicExponent||u}),new r.z8({name:t.privateExponent||u}),new r.z8({name:t.prime1||u}),new r.z8({name:t.prime2||u}),new r.z8({name:t.exponent1||u}),new r.z8({name:t.exponent2||u}),new r.z8({name:t.coefficient||u}),new r.T9({optional:!0,value:[new r.ZD({name:t.otherPrimeInfosName||u,value:ks.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){n.ze(e,Ts);const t=r.eN(e,e,Ps.schema({names:{version:Ns,modulus:Cs,publicExponent:Bs,privateExponent:Vs,prime1:Is,prime2:Es,exponent1:Hs,exponent2:xs,coefficient:Ds,otherPrimeInfo:{names:{blockName:Os}}}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),Os in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,(e=>new ks({schema:e}))))}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new r.T9({value:Array.from(this.otherPrimeInfos,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={n:a.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:a.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:a.ep.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:a.ep.ToBase64Url(this.prime1.valueBlock.valueHexView),q:a.ep.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:a.ep.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:a.ep.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:a.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,(e=>e.toJSON()))),e}fromJSON(e){h.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new r.z8({valueHex:a.ep.FromBase64Url(e.n)}),this.publicExponent=new r.z8({valueHex:a.ep.FromBase64Url(e.e)}),this.privateExponent=new r.z8({valueHex:a.ep.FromBase64Url(e.d)}),this.prime1=new r.z8({valueHex:a.ep.FromBase64Url(e.p)}),this.prime2=new r.z8({valueHex:a.ep.FromBase64Url(e.q)}),this.exponent1=new r.z8({valueHex:a.ep.FromBase64Url(e.dp)}),this.exponent2=new r.z8({valueHex:a.ep.FromBase64Url(e.dq)}),this.coefficient=new r.z8({valueHex:a.ep.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,(e=>new ks({json:e}))))}}Ps.CLASS_NAME="RSAPrivateKey";const Us="version",$s="privateKeyAlgorithm",Ls="privateKey",Rs="attributes",Ks="parsedKey",Js=[Us,$s,Ls,Rs];class _s extends f{constructor(e={}){super(),this.version=n.H$(e,Us,_s.defaultValues(Us)),this.privateKeyAlgorithm=n.H$(e,$s,_s.defaultValues($s)),this.privateKey=n.H$(e,Ls,_s.defaultValues(Ls)),Rs in e&&(this.attributes=n.H$(e,Rs,_s.defaultValues(Rs))),Ks in e&&(this.parsedKey=n.H$(e,Ks,_s.defaultValues(Ks))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Us:return 0;case $s:return new K;case Ls:return new r.fi;case Rs:return[];case Ks:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),K.schema(t.privateKeyAlgorithm||{}),new r.fi({name:t.privateKey||u}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({name:t.attributes||u,value:z.schema()})]})]})}fromSchema(e){n.ze(e,Js);const t=r.eN(e,e,_s.schema({names:{version:Us,privateKeyAlgorithm:{names:{blockName:$s}},privateKey:Ls,attributes:Rs}}));switch(m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new K({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,Rs in t.result&&(this.attributes=Array.from(t.result.attributes,(e=>new z({schema:e})))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=r.sc(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new Ps({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof r.rP){const e=r.sc(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new ys({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new r.z8({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){if(!this.parsedKey){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(e.attributes=Array.from(this.attributes,(e=>e.toJSON()))),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ys({json:e}),this.privateKeyAlgorithm=new K({algorithmId:"1.2.840.10045.2.1",algorithmParams:new r.rP({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ps({json:e}),this.privateKeyAlgorithm=new K({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new r.p2});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new r.fi({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}_s.CLASS_NAME="PrivateKeyInfo";const Fs="contentType",Ms="contentEncryptionAlgorithm",js="encryptedContent",qs=[Fs,Ms,js];class zs extends f{constructor(e={}){if(super(),this.contentType=n.H$(e,Fs,zs.defaultValues(Fs)),this.contentEncryptionAlgorithm=n.H$(e,Ms,zs.defaultValues(Ms)),js in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new r.fi({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const s=this.encryptedContent.valueBlock.valueHexView.slice().buffer;let a=s.byteLength;const n=1024;for(;a>0;){const i=new Uint8Array(s,t,t+n>s.byteLength?s.byteLength-t:n),o=new ArrayBuffer(i.length),l=new Uint8Array(o);for(let e=0;e<l.length;e++)l[e]=i[e];e.valueBlock.value.push(new r.fi({valueHex:o})),a-=i.length,t+=i.length}this.encryptedContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fs:return u;case Ms:return new K;case js:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Fs:return t===u;case Ms:return t.algorithmId===u&&"algorithmParams"in t==!1;case js:return t.isEqual(zs.defaultValues(js));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.contentType||u}),K.schema(t.contentEncryptionAlgorithm||{}),new r.Lv({value:[new r.FC({name:t.encryptedContent||u,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({value:new r.fi})]}),new r.WV({name:t.encryptedContent||u,idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){n.ze(e,qs);const t=r.eN(e,e,zs.schema({names:{contentType:Fs,contentEncryptionAlgorithm:{names:{blockName:Ms}},encryptedContent:js}}));m.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new K({schema:t.result.contentEncryptionAlgorithm}),js in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new r.rP({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const s=this.encryptedContent;s.idBlock.tagClass=3,s.idBlock.tagNumber=0,s.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(s)}return new r.T9({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw new Error("Parameter 'encryptedContent' is undefined");return r.fi.prototype.getValue.call(this.encryptedContent)}}zs.CLASS_NAME="EncryptedContentInfo";const Ws="hashAlgorithm",Gs="maskGenAlgorithm",Zs="saltLength",Ys="trailerField",Qs=[Ws,Gs,Zs,Ys];class Xs extends f{constructor(e={}){super(),this.hashAlgorithm=n.H$(e,Ws,Xs.defaultValues(Ws)),this.maskGenAlgorithm=n.H$(e,Gs,Xs.defaultValues(Gs)),this.saltLength=n.H$(e,Zs,Xs.defaultValues(Zs)),this.trailerField=n.H$(e,Ys,Xs.defaultValues(Ys)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ws:return new K({algorithmId:"1.3.14.3.2.26",algorithmParams:new r.p2});case Gs:return new K({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new K({algorithmId:"1.3.14.3.2.26",algorithmParams:new r.p2}).toSchema()});case Zs:return 20;case Ys:return 1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[K.schema(t.hashAlgorithm||{})]}),new r.FC({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[K.schema(t.maskGenAlgorithm||{})]}),new r.FC({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new r.z8({name:t.saltLength||u})]}),new r.FC({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new r.z8({name:t.trailerField||u})]})]})}fromSchema(e){n.ze(e,Qs);const t=r.eN(e,e,Xs.schema({names:{hashAlgorithm:{names:{blockName:Ws}},maskGenAlgorithm:{names:{blockName:Gs}},saltLength:Zs,trailerField:Ys}}));m.assertSchema(t,this.className),Ws in t.result&&(this.hashAlgorithm=new K({schema:t.result.hashAlgorithm})),Gs in t.result&&(this.maskGenAlgorithm=new K({schema:t.result.maskGenAlgorithm})),Zs in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),Ys in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Xs.defaultValues(Ws))||e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Xs.defaultValues(Gs))||e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Xs.defaultValues(Zs)&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:[new r.z8({value:this.saltLength})]})),this.trailerField!==Xs.defaultValues(Ys)&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:3},value:[new r.z8({value:this.trailerField})]})),new r.T9({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Xs.defaultValues(Ws))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Xs.defaultValues(Gs))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Xs.defaultValues(Zs)&&(e.saltLength=this.saltLength),this.trailerField!==Xs.defaultValues(Ys)&&(e.trailerField=this.trailerField),e}}Xs.CLASS_NAME="RSASSAPSSParams";const er="salt",tr="iterationCount",sr="keyLength",rr="prf",ar=[er,tr,sr,rr];class nr extends f{constructor(e={}){super(),this.salt=n.H$(e,er,nr.defaultValues(er)),this.iterationCount=n.H$(e,tr,nr.defaultValues(tr)),sr in e&&(this.keyLength=n.H$(e,sr,nr.defaultValues(sr))),rr in e&&(this.prf=n.H$(e,rr,nr.defaultValues(rr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case er:return{};case tr:return-1;case sr:return 0;case rr:return new K({algorithmId:"1.3.14.3.2.26",algorithmParams:new r.p2});default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.Lv({value:[new r.fi({name:t.saltPrimitive||u}),K.schema(t.saltConstructed||{})]}),new r.z8({name:t.iterationCount||u}),new r.z8({name:t.keyLength||u,optional:!0}),K.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){n.ze(e,ar);const t=r.eN(e,e,nr.schema({names:{saltPrimitive:er,saltConstructed:{names:{blockName:er}},iterationCount:tr,keyLength:sr,prf:{names:{blockName:rr,optional:!0}}}}));m.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,sr in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),rr in t.result&&(this.prf=new K({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new r.z8({value:this.iterationCount})),sr in this&&nr.defaultValues(sr)!==this.keyLength&&e.push(new r.z8({value:this.keyLength})),this.prf&&!1===nr.defaultValues(rr).isEqual(this.prf)&&e.push(this.prf.toSchema()),new r.T9({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return sr in this&&nr.defaultValues(sr)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&!1===nr.defaultValues(rr).isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}nr.CLASS_NAME="PBKDF2Params";const ir="keyDerivationFunc",or="encryptionScheme",lr=[ir,or];class ur extends f{constructor(e={}){super(),this.keyDerivationFunc=n.H$(e,ir,ur.defaultValues(ir)),this.encryptionScheme=n.H$(e,or,ur.defaultValues(or)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ir:case or:return new K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.keyDerivationFunc||{}),K.schema(t.encryptionScheme||{})]})}fromSchema(e){n.ze(e,lr);const t=r.eN(e,e,ur.schema({names:{keyDerivationFunc:{names:{blockName:ir}},encryptionScheme:{names:{blockName:or}}}}));m.assertSchema(t,this.className),this.keyDerivationFunc=new K({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new K({schema:t.result.encryptionScheme})}toSchema(){return new r.T9({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}ur.CLASS_NAME="PBES2Params";async function cr(e,t,s,r,a,n){let i,o;const l=[];switch(t.toUpperCase()){case"SHA-1":i=20,o=64;break;case"SHA-256":i=32,o=64;break;case"SHA-384":i=48,o=128;break;case"SHA-512":i=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const u=new Uint8Array(r),c=new ArrayBuffer(2*r.byteLength+2),h=new Uint8Array(c);for(let e=0;e<u.length;e++)h[2*e]=0,h[2*e+1]=u[e];h[h.length-2]=0,h[h.length-1]=0,r=c.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;const d=a.byteLength,g=o*Math.ceil(d/o),p=new ArrayBuffer(g),w=new Uint8Array(p),y=new Uint8Array(a);for(let e=0;e<g;e++)w[e]=y[e%d];const v=r.byteLength,b=o*Math.ceil(v/o),S=new ArrayBuffer(b),A=new Uint8Array(S),k=new Uint8Array(r);for(let e=0;e<b;e++)A[e]=k[e%v];const N=p.byteLength+S.byteLength;let C=new ArrayBuffer(N),B=new Uint8Array(C);B.set(w),B.set(A,w.length);const V=Math.ceil((s>>3)/i);let I=Promise.resolve(C);for(let s=0;s<=V;s++){I=I.then((e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),s=new Uint8Array(t);return s.set(f),s.set(B,f.length),t}));for(let s=0;s<n;s++)I=I.then((s=>e.digest({name:t},new Uint8Array(s))));I=I.then((e=>{const t=new ArrayBuffer(o),s=new Uint8Array(t);for(let r=0;r<t.byteLength;r++)s[r]=e[r%e.byteLength];const r=Math.ceil(d/o)+Math.ceil(v/o),a=[];let n=0,i=o;for(let e=0;e<r;e++){const e=Array.from(new Uint8Array(C.slice(n,n+i)));n+=o,n+o>C.byteLength&&(i=C.byteLength-n);let r=511;for(let a=t.byteLength-1;a>=0;a--)r>>=8,r+=s[a]+e[a],e[a]=255&r;a.push(...e)}return C=new ArrayBuffer(a.length),B=new Uint8Array(C),B.set(a),l.push(...new Uint8Array(e)),C}))}return I=I.then((()=>{const e=new ArrayBuffer(s>>3);return new Uint8Array(e).set(new Uint8Array(l).slice(0,s>>3)),e})),I}function hr(e){const t="string"==typeof e?{name:e}:e;return"hash"in t?{...t,hash:hr(t.hash)}:t}class mr extends class{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=n.H$(e,"name",u)}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){return this.crypto.getRandomValues(e)}}{async importKey(e,t,s,i,o){var l,u,f,d,g,p;let w={};const y=hr(s);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,s,i,o);case"spki":{const e=r.sc(a.vJ.toArrayBuffer(t));m.assert(e,"keyData");const s=new ms;try{s.fromSchema(e.result)}catch{throw new c("Incorrect keyData")}switch(y.name.toUpperCase()){case"RSA-PSS":if(!y.hash)throw new h("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":w.alg="PS1";break;case"SHA-256":w.alg="PS256";break;case"SHA-384":w.alg="PS384";break;case"SHA-512":w.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(o=["verify"],w.kty="RSA",w.ext=i,w.key_ops=o,"1.2.840.113549.1.1.1"!==s.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${s.algorithm.algorithmId}`);if(!w.alg){if(!y.hash)throw new h("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":w.alg="RS1";break;case"SHA-256":w.alg="RS256";break;case"SHA-384":w.alg="RS384";break;case"SHA-512":w.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}const e=s.toJSON();Object.assign(w,e)}break;case"ECDSA":o=["verify"];case"ECDH":{if(w={kty:"EC",ext:i,key_ops:o},"1.2.840.10045.2.1"!==s.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${s.algorithm.algorithmId}`);const e=s.toJSON();Object.assign(w,e)}break;case"RSA-OAEP":{if(w.kty="RSA",w.ext=i,w.key_ops=o,"safari"===this.name.toLowerCase())w.alg="RSA-OAEP";else{if(!y.hash)throw new h("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":w.alg="RSA-OAEP";break;case"SHA-256":w.alg="RSA-OAEP-256";break;case"SHA-384":w.alg="RSA-OAEP-384";break;case"SHA-512":w.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}const e=s.toJSON();Object.assign(w,e)}break;case"RSAES-PKCS1-V1_5":{w.kty="RSA",w.ext=i,w.key_ops=o,w.alg="PS1";const e=s.toJSON();Object.assign(w,e)}break;default:throw new Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new _s,s=r.sc(a.vJ.toArrayBuffer(t));m.assert(s,"keyData");try{e.fromSchema(s.result)}catch(e){throw new Error("Incorrect keyData")}if(!e.parsedKey)throw new Error("Incorrect keyData");switch(y.name.toUpperCase()){case"RSA-PSS":switch(null===(l=y.hash)||void 0===l?void 0:l.name.toUpperCase()){case"SHA-1":w.alg="PS1";break;case"SHA-256":w.alg="PS256";break;case"SHA-384":w.alg="PS384";break;case"SHA-512":w.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(u=y.hash)||void 0===u?void 0:u.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(o=["sign"],w.kty="RSA",w.ext=i,w.key_ops=o,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in w==!1)switch(null===(f=y.hash)||void 0===f?void 0:f.name.toUpperCase()){case"SHA-1":w.alg="RS1";break;case"SHA-256":w.alg="RS256";break;case"SHA-384":w.alg="RS384";break;case"SHA-512":w.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(d=y.hash)||void 0===d?void 0:d.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(w,t)}break;case"ECDSA":o=["sign"];case"ECDH":{if(w={kty:"EC",ext:i,key_ops:o},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();Object.assign(w,t)}break;case"RSA-OAEP":{if(w.kty="RSA",w.ext=i,w.key_ops=o,"safari"===this.name.toLowerCase())w.alg="RSA-OAEP";else switch(null===(g=y.hash)||void 0===g?void 0:g.name.toUpperCase()){case"SHA-1":w.alg="RSA-OAEP";break;case"SHA-256":w.alg="RSA-OAEP-256";break;case"SHA-384":w.alg="RSA-OAEP-384";break;case"SHA-512":w.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(p=y.hash)||void 0===p?void 0:p.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(w,t)}break;case"RSAES-PKCS1-V1_5":{o=["decrypt"],w.kty="RSA",w.ext=i,w.key_ops=o,w.alg="PS1";const t=e.toJSON();Object.assign(w,t)}break;default:throw new Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"jwk":w=t;break;default:throw new Error(`Incorrect format: ${e}`)}if("safari"===this.name.toLowerCase())try{return this.subtle.importKey("jwk",n.gG(JSON.stringify(w)),s,i,o)}catch{return this.subtle.importKey("jwk",w,s,i,o)}return this.subtle.importKey("jwk",w,s,i,o)}async exportKey(e,t){let s=await this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&s instanceof ArrayBuffer&&(s=JSON.parse(n.lE(s))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{const e=new ms;try{e.fromJSON(s)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"pkcs8":{const e=new _s;try{e.fromJSON(s)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"jwk":return s;default:throw new Error(`Incorrect format: ${e}`)}}async convert(e,t,s,r,a,n){if(e.toLowerCase()===t.toLowerCase())return s;const i=await this.importKey(e,s,r,a,n);return this.exportKey(t,i)}getAlgorithmByOID(e,t=!1,s){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw new Error(`Unsupported algorithm identifier ${s?`for ${s} `:u}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,s){let r=u;switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":r="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":r="1.2.840.113549.1.1.5";break;case"SHA-256":r="1.2.840.113549.1.1.11";break;case"SHA-384":r="1.2.840.113549.1.1.12";break;case"SHA-512":r="1.2.840.113549.1.1.13"}break;case"RSA-PSS":r="1.2.840.113549.1.1.10";break;case"RSA-OAEP":r="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":r="1.2.840.10045.4.1";break;case"SHA-256":r="1.2.840.10045.4.3.2";break;case"SHA-384":r="1.2.840.10045.4.3.3";break;case"SHA-512":r="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":r="1.3.133.16.840.63.0.2";break;case"SHA-256":r="1.3.132.1.11.1";break;case"SHA-384":r="1.3.132.1.11.2";break;case"SHA-512":r="1.3.132.1.11.3"}break;case"AES-CTR":case"AES-CMAC":case"CONCAT":case"HKDF":break;case"AES-CBC":switch(e.length){case 128:r="2.16.840.1.101.3.4.1.2";break;case 192:r="2.16.840.1.101.3.4.1.22";break;case 256:r="2.16.840.1.101.3.4.1.42"}break;case"AES-GCM":switch(e.length){case 128:r="2.16.840.1.101.3.4.1.6";break;case 192:r="2.16.840.1.101.3.4.1.26";break;case 256:r="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:r="2.16.840.1.101.3.4.1.4";break;case 192:r="2.16.840.1.101.3.4.1.24";break;case 256:r="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:r="2.16.840.1.101.3.4.1.5";break;case 192:r="2.16.840.1.101.3.4.1.25";break;case 256:r="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":r="1.2.840.113549.2.7";break;case"SHA-256":r="1.2.840.113549.2.9";break;case"SHA-384":r="1.2.840.113549.2.10";break;case"SHA-512":r="1.2.840.113549.2.11"}break;case"DH":r="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":r="1.3.14.3.2.26";break;case"SHA-256":r="2.16.840.1.101.3.4.2.1";break;case"SHA-384":r="2.16.840.1.101.3.4.2.2";break;case"SHA-512":r="2.16.840.1.101.3.4.2.3";break;case"PBKDF2":r="1.2.840.113549.1.5.12";break;case"P-256":r="1.2.840.10045.3.1.7";break;case"P-384":r="1.3.132.0.34";break;case"P-521":r="1.3.132.0.35"}if(!r&&t)throw new Error(`Unsupported algorithm ${s?`for ${s} `:u}: ${e.name}`);return r}getAlgorithmParameters(e,t){let s={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":s={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":s={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":s={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":s={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":s={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":s={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":s={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":s={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"HKDF"},usages:[]};s={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;case"PBKDF2":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"PBKDF2"},usages:[]};s={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]}}return s}getHashAlgorithm(e){let t=u;switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const s=new Xs({schema:e.algorithmParams});if(s.hashAlgorithm){const e=this.getAlgorithmByOID(s.hashAlgorithm.algorithmId);if(!("name"in e))return u;t=e.name}else t="SHA-1"}catch{}}return t}async encryptEncryptedContentInfo(e){h.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),s=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),a=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),n=new ArrayBuffer(16),i=new Uint8Array(n);this.getRandomValues(i);const o=new ArrayBuffer(64),l=new Uint8Array(o);this.getRandomValues(l);const u=new Uint8Array(e.contentToEncrypt),c=new nr({salt:new r.fi({valueHex:o}),iterationCount:e.iterationCount,prf:new K({algorithmId:a,algorithmParams:new r.p2})}),m=new Uint8Array(e.password),f=await this.importKey("raw",m,"PBKDF2",!1,["deriveKey"]),d=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},f,e.contentEncryptionAlgorithm,!1,["encrypt"]),g=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},d,u),p=new ur({keyDerivationFunc:new K({algorithmId:s,algorithmParams:c.toSchema()}),encryptionScheme:new K({algorithmId:t,algorithmParams:new r.fi({valueHex:n})})});return new zs({contentType:e.contentType,contentEncryptionAlgorithm:new K({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:p.toSchema()}),encryptedContent:new r.fi({valueHex:g})})}async decryptEncryptedContentInfo(e){if(h.assert(e,"password","encryptedContentInfo"),"1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)throw new Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,s;try{t=new ur({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbes2Parameters"')}try{s=new nr({schema:t.keyDerivationFunc.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbkdf2Params"')}const r=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),a=t.encryptionScheme.algorithmParams.valueBlock.valueHex,n=new Uint8Array(a),i=s.salt.valueBlock.valueHex,o=new Uint8Array(i),l=s.iterationCount;let u="SHA-1";if(s.prf){u=this.getAlgorithmByOID(s.prf.algorithmId,!0).hash.name}const c=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),m=await this.deriveKey({name:"PBKDF2",hash:{name:u},salt:o,iterations:l},c,r,!1,["decrypt"]),f=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:r.name,iv:n},m,f)}async stampDataWithPassword(e){if(e instanceof Object==!1)throw new Error('Parameters must have type "Object"');let t;switch(h.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp"),e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},r=await cr(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(r),s,!1,["sign"]);return this.sign(s,a,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){h.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},r=await cr(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(r),s,!1,["verify"]);return this.verify(s,a,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");const s=new K,a=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(a.algorithm).length)throw new Error("Parameter 'algorithm' is empty");const n=a.algorithm;switch(n.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(n,!0);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":n.saltLength=32;break;case"SHA-384":n.saltLength=48;break;case"SHA-512":n.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const s=this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");e.hashAlgorithm=new K({algorithmId:s,algorithmParams:new r.p2}),e.maskGenAlgorithm=new K({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==n.saltLength&&(e.saltLength=n.saltLength);const a=new Xs(e);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=a.toSchema()}break;default:throw new Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:s,parameters:a}}async signWithPrivateKey(e,t,s){const a=await this.sign(s.algorithm,t,e);return"ECDSA"===s.algorithm.name?function(e){if(e.byteLength%2!=0)return l;const t=e.byteLength/2,s=new ArrayBuffer(t);new Uint8Array(s).set(new Uint8Array(e,0,t));const a=new r.z8({valueHex:s}),n=new ArrayBuffer(t);new Uint8Array(n).set(new Uint8Array(e,t,t));const i=new r.z8({valueHex:n});return new r.T9({value:[a.convertToDER(),i.convertToDER()]}).toBER(!1)}(a):a}fillPublicKeyParameters(e,t){const s={},r=this.getHashAlgorithm(t);if(r===u)throw new Error(`Unsupported signature algorithm: ${t.algorithmId}`);let a;a="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const n=this.getAlgorithmByOID(a,!0);if(s.algorithm=this.getAlgorithmParameters(n.name,"importKey"),"hash"in s.algorithm.algorithm&&(s.algorithm.algorithm.hash.name=r),"ECDSA"===n.name){const t=e.algorithm;if(!t.algorithmParams)throw new Error("Algorithm parameters for ECDSA public key are missed");const r=t.algorithmParams;if("idBlock"in t.algorithmParams&&(1!==r.idBlock.tagClass||6!==r.idBlock.tagNumber))throw new Error("Incorrect type for ECDSA public key parameters");const a=this.getAlgorithmByOID(r.valueBlock.toString(),!0);s.algorithm.algorithm.namedCurve=a.name}return s}async getPublicKey(e,t,s){s||(s=this.fillPublicKeyParameters(e,t));const r=e.toSchema().toBER(!1);return this.importKey("spki",r,s.algorithm.algorithm,!0,s.algorithm.usages)}async verifyWithPublicKey(e,t,s,a,n){let i;if(n){const e={};let t;t="1.2.840.113549.1.1.10"===a.algorithmId?a.algorithmId:s.algorithm.algorithmId;const r=this.getAlgorithmByOID(t,!0);if(e.algorithm=this.getAlgorithmParameters(r.name,"importKey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=n),"ECDSA"===r.name){let t=!1;if("algorithmParams"in s.algorithm==!0&&"idBlock"in s.algorithm.algorithmParams&&1===s.algorithm.algorithmParams.idBlock.tagClass&&6===s.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)throw new Error("Incorrect type for ECDSA public key parameters");const r=this.getAlgorithmByOID(s.algorithm.algorithmParams.valueBlock.toString(),!0);e.algorithm.algorithm.namedCurve=r.name}i=await this.getPublicKey(s,null,e)}else{if(!(n=this.getHashAlgorithm(a)))throw new Error(`Unsupported signature algorithm: ${a.algorithmId}`);i=await this.getPublicKey(s,a)}const o=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in o.algorithm&&(o.algorithm.hash.name=n);let u=t.valueBlock.valueHexView;if("ECDSA"===i.algorithm.name){const e=es.find(i.algorithm.namedCurve);if(!e)throw new Error("Unsupported named curve in use");const t=r.sc(u);m.assert(t,"Signature value"),u=function(e,t){if(!(e instanceof r.T9&&2===e.valueBlock.value.length&&e.valueBlock.value[0]instanceof r.z8&&e.valueBlock.value[1]instanceof r.z8))return l;const s=e.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,a=e.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,n=new Uint8Array(2*t);return n.set(s,t-s.byteLength),n.set(a,2*t-a.byteLength),n.buffer}(t.result,e.size)}if("RSA-PSS"===i.algorithm.name){const e=new Xs({schema:a.algorithmParams});o.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){t=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId,!0).name}o.algorithm.hash.name=t}return this.verify(o.algorithm,i,u,e)}}let fr={name:"none",crypto:null};function dr(e){return!(!e||"object"!=typeof e||!("crypto"in e))}function gr(e,...t){let r=null;if(1===t.length)r=t[0];else{const e=t[0],s=t[1];dr(s)&&(r=s),dr(e)&&(r=e),"subtle"in e&&"getRandomValues"in e&&(r=new mr({crypto:e}))}if("undefined"!=typeof process&&"pid"in process&&void 0!==s.g&&"undefined"==typeof window){if(void 0===s.g[process.pid])s.g[process.pid]={};else if("object"!=typeof s.g[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===s.g[process.pid].pkijs)s.g[process.pid].pkijs={};else if("object"!=typeof s.g[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);s.g[process.pid].pkijs.engine={name:e,crypto:r}}else fr.name!==e&&(fr={name:e,crypto:r})}function pr(e=!1){const t=function(){if("undefined"!=typeof process&&"pid"in process&&void 0!==s.g&&"undefined"==typeof window){let e;try{e=s.g[process.pid].pkijs.engine}catch(e){throw new Error("Please call 'setEngine' before call to 'getEngine'")}return e}return fr}();if(!t.crypto&&e)throw new Error("Unable to create WebCrypto object");return t.crypto}async function wr(e,t,s,r,a){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new c(`Unknown hash function: ${e}`)}if(c.assert(t,"zBuffer","ArrayBuffer"),0===t.byteLength)throw new c("'zBuffer' has zero length, error");if(c.assert(r,"SharedInfo","ArrayBuffer"),s>255)throw new c("Please set 'Counter' argument to value less or equal to 255");const i=new ArrayBuffer(4),o=new Uint8Array(i);o[0]=0,o[1]=0,o[2]=0,o[3]=s;let u=l;u=n.hk(u,t),u=n.hk(u,i),u=n.hk(u,r);return{counter:s,result:await a.digest({name:e},u)}}async function yr(e,t,s,r,a=pr(!0)){let i=0,o=1;switch(e.toUpperCase()){case"SHA-1":i=160;break;case"SHA-256":i=256;break;case"SHA-384":i=384;break;case"SHA-512":i=512;break;default:throw new c(`Unknown hash function: ${e}`)}if(c.assert(t,"Zbuffer","ArrayBuffer"),0===t.byteLength)throw new c("'Zbuffer' has zero length, error");c.assert(r,"SharedInfo","ArrayBuffer");const u=s/i;Math.floor(u)>0&&(o=Math.floor(u),u-o>0&&o++);const h=[];for(let s=1;s<=o;s++)h.push(await wr(e,t,s,r,a));let m=l,f=1,d=!0;for(;d;){d=!1;for(const e of h)if(e.counter===f){m=n.hk(m,e.result),d=!0;break}f++}if(s>>=3,m.byteLength>s){const e=new ArrayBuffer(s),t=new Uint8Array(e),r=new Uint8Array(m);for(let e=0;e<s;e++)t[e]=r[e];return e}return m}const vr="version",br="logID",Sr="extensions",Ar="timestamp",kr="hashAlgorithm",Nr="signatureAlgorithm",Cr="signature",Br="none",Vr="sha1",Ir="sha224",Er="sha256",Hr="sha384",xr="sha512",Dr="anonymous",Or="ecdsa";class Tr extends f{constructor(e={}){super(),this.version=n.H$(e,vr,Tr.defaultValues(vr)),this.logID=n.H$(e,br,Tr.defaultValues(br)),this.timestamp=n.H$(e,Ar,Tr.defaultValues(Ar)),this.extensions=n.H$(e,Sr,Tr.defaultValues(Sr)),this.hashAlgorithm=n.H$(e,kr,Tr.defaultValues(kr)),this.signatureAlgorithm=n.H$(e,Nr,Tr.defaultValues(Nr)),this.signature=n.H$(e,Cr,Tr.defaultValues(Cr)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vr:return 0;case br:case Sr:return l;case Ar:return new Date(0);case kr:case Nr:return u;case Cr:return new r.IK;default:return super.defaultValues(e)}}fromSchema(e){if(e instanceof r.Gh==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new o({stream:new i({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(n.r9(new Uint8Array(e.getBlock(8)),8));const s=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(s)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=Br;break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm=Vr;break;case 3:this.hashAlgorithm=Ir;break;case 4:this.hashAlgorithm=Er;break;case 5:this.hashAlgorithm=Hr;break;case 6:this.hashAlgorithm=xr;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=Dr;break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm=Or;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const a=e.getUint16(),i=new Uint8Array(e.getBlock(a)).buffer.slice(0),o=r.sc(i);if(m.assert(o,"SignedCertificateTimestamp"),this.signature=o.result,t!==47+s+a)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new r.Gh({data:e.stream.buffer})}toStream(){const e=new o;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecodeView.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),s=new Uint8Array(t),r=n.lL(this.timestamp.valueOf(),8);let a,i;switch(s.set(new Uint8Array(r),8-r.byteLength),e.appendView(s),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case Br:a=0;break;case"md5":a=1;break;case Vr:a=2;break;case Ir:a=3;break;case Er:a=4;break;case Hr:a=5;break;case xr:a=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(e.appendChar(a),this.signatureAlgorithm.toLowerCase()){case Dr:i=0;break;case"rsa":i=1;break;case"dsa":i=2;break;case Or:i=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}e.appendChar(i);const l=this.signature.toBER(!1);return e.appendUint16(l.byteLength),e.appendView(new Uint8Array(l)),e}toJSON(){return{version:this.version,logID:n.RH(this.logID),timestamp:this.timestamp,extensions:n.RH(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,s=0,r=pr(!0)){const a=n.s3(n.lE(this.logID));let i=null;const l=new o;for(const t of e)if(t.log_id===a){i=t.key;break}if(!i)throw new Error(`Public key not found for CT with logId: ${a}`);const c=n.gG(n.Gh(i)),h=ms.fromBER(c);l.appendChar(0),l.appendChar(0);const m=new ArrayBuffer(8),f=new Uint8Array(m),d=n.lL(this.timestamp.valueOf(),8);return f.set(new Uint8Array(d),8-d.byteLength),l.appendView(f),l.appendUint16(s),0===s&&l.appendUint24(t.byteLength),l.appendView(new Uint8Array(t)),l.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&l.appendView(new Uint8Array(this.extensions)),r.verifyWithPublicKey(l.buffer.slice(0,l.length),{valueBlock:{valueHex:this.signature.toBER(!1)}},h,{algorithmId:u},"SHA-256")}}Tr.CLASS_NAME="SignedCertificateTimestamp";const Pr="timestamps";class Ur extends f{constructor(e={}){super(),this.timestamps=n.H$(e,Pr,Ur.defaultValues(Pr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Pr?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Pr?0===t.length:super.defaultValues(e)}static schema(e={}){var t;const s=n.H$(e,"names",{});return null!==(t=s.optional)&&void 0!==t||(s.optional=!1),new r.fi({name:s.blockName||"SignedCertificateTimestampList",optional:s.optional})}fromSchema(e){if(e instanceof r.fi==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new o({stream:new i({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new Tr({stream:t}))}toSchema(){const e=new o;let t=0;const s=[];for(const e of this.timestamps){const r=e.toStream();s.push(r),t+=r.stream.buffer.byteLength}e.appendUint16(t);for(const t of s)e.appendView(t.stream.view);return new r.fi({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,(e=>e.toJSON()))}}}Ur.CLASS_NAME="SignedCertificateTimestampList";const $r="attributes",Lr=[$r];class Rr extends f{constructor(e={}){super(),this.attributes=n.H$(e,$r,Rr.defaultValues($r)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===$r?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.attributes||u,value:z.schema()})]})}fromSchema(e){n.ze(e,Lr);const t=r.eN(e,e,Rr.schema({names:{attributes:$r}}));m.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,(e=>new z({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.attributes,(e=>e.toSchema()))})}toJSON(){return{attributes:Array.from(this.attributes,(e=>e.toJSON()))}}}Rr.CLASS_NAME="SubjectDirectoryAttributes";class Kr{static getItems(){return this.types||(this.types={},Kr.register(te,"SubjectAltName",F),Kr.register(se,"IssuerAltName",F),Kr.register(me,"AuthorityKeyIdentifier",Ee),Kr.register(re,"BasicConstraints",De),Kr.register("1.3.6.1.4.1.311.21.1","MicrosoftCaVersion",Pe),Kr.register(ue,"CertificatePolicies",qe),Kr.register("1.3.6.1.4.1.311.21.10","CertificatePoliciesMicrosoft",qe),Kr.register("1.3.6.1.4.1.311.21.7","MicrosoftCertTemplateV2",Ye),Kr.register(oe,"CRLDistributionPoints",ot),Kr.register(le,"FreshestCRL",ot),Kr.register("2.5.29.37","ExtKeyUsage",ct),Kr.register(ne,"CertificateIssuer",ee),Kr.register(de,"AuthorityInfoAccess",mt),Kr.register("1.3.6.1.5.5.7.1.11","SubjectInfoAccess",mt),Kr.register(ae,"IssuingDistributionPoint",St),Kr.register(ie,"NameConstraints",Ht),Kr.register(fe,"PolicyConstraints",Tt),Kr.register(he,"PolicyMappings",Jt),Kr.register("2.5.29.16","PrivateKeyUsagePeriod",jt),Kr.register("1.3.6.1.5.5.7.1.3","QCStatements",Qt),Kr.register(ge,"SignedCertificateTimestampList",Ur),Kr.register("2.5.29.9","SubjectDirectoryAttributes",Rr)),this.types}static fromBER(e,t){const s=r.sc(t);if(-1===s.offset)return null;const a=this.find(e);if(a)try{return new a.type({schema:s.result})}catch(t){const s=new a.type;return s.parsingError=`Incorrectly formatted value of extension ${a.name} (${e})`,s}return s.result}static find(e){return this.getItems()[e]||null}static register(e,t,s){this.getItems()[e]={name:t,type:s}}}const Jr="extnID",_r="critical",Fr="extnValue",Mr="parsedValue",jr=[Jr,_r,Fr];class qr extends f{constructor(e={}){super(),this.extnID=n.H$(e,Jr,qr.defaultValues(Jr)),this.critical=n.H$(e,_r,qr.defaultValues(_r)),this.extnValue=Fr in e?new r.fi({valueHex:e.extnValue}):qr.defaultValues(Fr),Mr in e&&(this.parsedValue=n.H$(e,Mr,qr.defaultValues(Mr))),e.schema&&this.fromSchema(e.schema)}get parsedValue(){if(void 0===this._parsedValue){const e=Kr.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}static defaultValues(e){switch(e){case Jr:return u;case _r:return!1;case Fr:return new r.fi;case Mr:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.extnID||u}),new r.ge({name:t.critical||u,optional:!0}),new r.fi({name:t.extnValue||u})]})}fromSchema(e){n.ze(e,jr);const t=r.eN(e,e,qr.schema({names:{extnID:Jr,critical:_r,extnValue:Fr}}));m.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),_r in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){const e=[];return e.push(new r.rP({value:this.extnID})),this.critical!==qr.defaultValues(_r)&&e.push(new r.ge({value:this.critical})),e.push(this.extnValue),new r.T9({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==qr.defaultValues(_r)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}}qr.CLASS_NAME="Extension";const zr="extensions",Wr=[zr];class Gr extends f{constructor(e={}){super(),this.extensions=n.H$(e,zr,Gr.defaultValues(zr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===zr?[]:super.defaultValues(e)}static schema(e={},t=!1){const s=n.H$(e,"names",{});return new r.T9({optional:t,name:s.blockName||u,value:[new r.ZD({name:s.extensions||u,value:qr.schema(s.extension||{})})]})}fromSchema(e){n.ze(e,Wr);const t=r.eN(e,e,Gr.schema({names:{extensions:zr}}));m.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,(e=>new qr({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.extensions,(e=>e.toSchema()))})}toJSON(){return{extensions:this.extensions.map((e=>e.toJSON()))}}}Gr.CLASS_NAME="Extensions";const Zr="issuer",Yr="serialNumber",Qr="issuerUID",Xr=[Zr,Yr,Qr];class ea extends f{constructor(e={}){super(),this.issuer=n.H$(e,Zr,ea.defaultValues(Zr)),this.serialNumber=n.H$(e,Yr,ea.defaultValues(Yr)),Qr in e&&(this.issuerUID=n.H$(e,Qr,ea.defaultValues(Qr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zr:return new ee;case Yr:return new r.z8;case Qr:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[ee.schema(t.issuer||{}),new r.z8({name:t.serialNumber||u}),new r._K({optional:!0,name:t.issuerUID||u})]})}fromSchema(e){n.ze(e,Xr);const t=r.eN(e,e,ea.schema({names:{issuer:{names:{blockName:Zr}},serialNumber:Yr,issuerUID:Qr}}));m.assertSchema(t,this.className),this.issuer=new ee({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,Qr in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){const e=new r.T9({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){const e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}}ea.CLASS_NAME="IssuerSerial";const ta="version",sa="baseCertificateID",ra="subjectName",aa="issuer",na="signature",ia="serialNumber",oa="attrCertValidityPeriod",la="attributes",ua="issuerUniqueID",ca="extensions",ha=[ta,sa,ra,aa,na,ia,oa,la,ua,ca];class ma extends f{constructor(e={}){super(),this.version=n.H$(e,ta,ma.defaultValues(ta)),sa in e&&(this.baseCertificateID=n.H$(e,sa,ma.defaultValues(sa))),ra in e&&(this.subjectName=n.H$(e,ra,ma.defaultValues(ra))),this.issuer=n.H$(e,aa,ma.defaultValues(aa)),this.signature=n.H$(e,na,ma.defaultValues(na)),this.serialNumber=n.H$(e,ia,ma.defaultValues(ia)),this.attrCertValidityPeriod=n.H$(e,oa,ma.defaultValues(oa)),this.attributes=n.H$(e,la,ma.defaultValues(la)),ua in e&&(this.issuerUniqueID=n.H$(e,ua,ma.defaultValues(ua))),ca in e&&(this.extensions=n.H$(e,ca,ma.defaultValues(ca))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ta:return 0;case sa:return new ea;case ra:case aa:return new ee;case na:return new K;case ia:return new r.z8;case oa:return new Y;case la:return[];case ua:return new r._K;case ca:return new Gr;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.Lv({value:[new r.FC({name:t.baseCertificateID||u,idBlock:{tagClass:3,tagNumber:0},value:ea.schema().valueBlock.value}),new r.FC({name:t.subjectName||u,idBlock:{tagClass:3,tagNumber:1},value:ee.schema().valueBlock.value})]}),ee.schema({names:{blockName:t.issuer||u}}),K.schema(t.signature||{}),new r.z8({name:t.serialNumber||u}),Y.schema(t.attrCertValidityPeriod||{}),new r.T9({name:t.attributes||u,value:[new r.ZD({value:z.schema()})]}),new r._K({optional:!0,name:t.issuerUniqueID||u}),Gr.schema(t.extensions||{},!0)]})}fromSchema(e){n.ze(e,ha);const t=r.eN(e,e,ma.schema({names:{version:ta,baseCertificateID:sa,subjectName:ra,issuer:aa,signature:{names:{blockName:na}},serialNumber:ia,attrCertValidityPeriod:{names:{blockName:oa}},attributes:la,issuerUniqueID:ua,extensions:{names:{blockName:ca}}}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,sa in t.result&&(this.baseCertificateID=new ea({schema:new r.T9({value:t.result.baseCertificateID.valueBlock.value})})),ra in t.result&&(this.subjectName=new ee({schema:new r.T9({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new K({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new Y({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,(e=>new z({schema:e}))),ua in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),ca in t.result&&(this.extensions=new Gr({schema:t.result.extensions}))}toSchema(){const e=new r.T9({value:[new r.z8({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new r.T9({value:Array.from(this.attributes,(e=>e.toSchema()))})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,(e=>e.toJSON())),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}ma.CLASS_NAME="AttributeCertificateInfoV1";const fa="acinfo",da="signatureAlgorithm",ga="signatureValue",pa=[fa,ga,da];class wa extends f{constructor(e={}){super(),this.acinfo=n.H$(e,fa,wa.defaultValues(fa)),this.signatureAlgorithm=n.H$(e,da,wa.defaultValues(da)),this.signatureValue=n.H$(e,ga,wa.defaultValues(ga)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fa:return new ma;case da:return new K;case ga:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[ma.schema(t.acinfo||{}),K.schema(t.signatureAlgorithm||{}),new r._K({name:t.signatureValue||u})]})}fromSchema(e){n.ze(e,pa);const t=r.eN(e,e,wa.schema({names:{acinfo:{names:{blockName:fa}},signatureAlgorithm:{names:{blockName:da}},signatureValue:ga}}));m.assertSchema(t,this.className),this.acinfo=new ma({schema:t.result.acinfo}),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new r.T9({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}wa.CLASS_NAME="AttributeCertificateV1";const ya="digestedObjectType",va="otherObjectTypeID",ba="digestAlgorithm",Sa="objectDigest",Aa=[ya,va,ba,Sa];class ka extends f{constructor(e={}){super(),this.digestedObjectType=n.H$(e,ya,ka.defaultValues(ya)),va in e&&(this.otherObjectTypeID=n.H$(e,va,ka.defaultValues(va))),this.digestAlgorithm=n.H$(e,ba,ka.defaultValues(ba)),this.objectDigest=n.H$(e,Sa,ka.defaultValues(Sa)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ya:return new r.WC;case va:return new r.rP;case ba:return new K;case Sa:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.WC({name:t.digestedObjectType||u}),new r.rP({optional:!0,name:t.otherObjectTypeID||u}),K.schema(t.digestAlgorithm||{}),new r._K({name:t.objectDigest||u})]})}fromSchema(e){n.ze(e,Aa);const t=r.eN(e,e,ka.schema({names:{digestedObjectType:ya,otherObjectTypeID:va,digestAlgorithm:{names:{blockName:ba}},objectDigest:Sa}}));m.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,va in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new K({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){const e=new r.T9({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){const e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}}ka.CLASS_NAME="ObjectDigestInfo";const Na="issuerName",Ca="baseCertificateID",Ba="objectDigestInfo",Va=[Na,Ca,Ba];class Ia extends f{constructor(e={}){super(),Na in e&&(this.issuerName=n.H$(e,Na,Ia.defaultValues(Na))),Ca in e&&(this.baseCertificateID=n.H$(e,Ca,Ia.defaultValues(Ca))),Ba in e&&(this.objectDigestInfo=n.H$(e,Ba,Ia.defaultValues(Ba))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Na:return new ee;case Ca:return new ea;case Ba:return new ka;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[ee.schema({names:{blockName:t.issuerName}},!0),new r.FC({optional:!0,name:t.baseCertificateID||u,idBlock:{tagClass:3,tagNumber:0},value:ea.schema().valueBlock.value}),new r.FC({optional:!0,name:t.objectDigestInfo||u,idBlock:{tagClass:3,tagNumber:1},value:ka.schema().valueBlock.value})]})}fromSchema(e){n.ze(e,Va);const t=r.eN(e,e,Ia.schema({names:{issuerName:Na,baseCertificateID:Ca,objectDigestInfo:Ba}}));m.assertSchema(t,this.className),Na in t.result&&(this.issuerName=new ee({schema:t.result.issuerName})),Ca in t.result&&(this.baseCertificateID=new ea({schema:new r.T9({value:t.result.baseCertificateID.valueBlock.value})})),Ba in t.result&&(this.objectDigestInfo=new ka({schema:new r.T9({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new r.T9;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}Ia.CLASS_NAME="V2Form";const Ea="baseCertificateID",Ha="entityName",xa="objectDigestInfo",Da=[Ea,Ha,xa];class Oa extends f{constructor(e={}){super(),Ea in e&&(this.baseCertificateID=n.H$(e,Ea,Oa.defaultValues(Ea))),Ha in e&&(this.entityName=n.H$(e,Ha,Oa.defaultValues(Ha))),xa in e&&(this.objectDigestInfo=n.H$(e,xa,Oa.defaultValues(xa))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ea:return new ea;case Ha:return new ee;case xa:return new ka;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({optional:!0,name:t.baseCertificateID||u,idBlock:{tagClass:3,tagNumber:0},value:ea.schema().valueBlock.value}),new r.FC({optional:!0,name:t.entityName||u,idBlock:{tagClass:3,tagNumber:1},value:ee.schema().valueBlock.value}),new r.FC({optional:!0,name:t.objectDigestInfo||u,idBlock:{tagClass:3,tagNumber:2},value:ka.schema().valueBlock.value})]})}fromSchema(e){n.ze(e,Da);const t=r.eN(e,e,Oa.schema({names:{baseCertificateID:Ea,entityName:Ha,objectDigestInfo:xa}}));m.assertSchema(t,this.className),Ea in t.result&&(this.baseCertificateID=new ea({schema:new r.T9({value:t.result.baseCertificateID.valueBlock.value})})),Ha in t.result&&(this.entityName=new ee({schema:new r.T9({value:t.result.entityName.valueBlock.value})})),xa in t.result&&(this.objectDigestInfo=new ka({schema:new r.T9({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new r.T9;return this.baseCertificateID&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}Oa.CLASS_NAME="Holder";const Ta="version",Pa="holder",Ua="issuer",$a="signature",La="serialNumber",Ra="attrCertValidityPeriod",Ka="attributes",Ja="issuerUniqueID",_a="extensions",Fa=[Ta,Pa,Ua,$a,La,Ra,Ka,Ja,_a];class Ma extends f{constructor(e={}){super(),this.version=n.H$(e,Ta,Ma.defaultValues(Ta)),this.holder=n.H$(e,Pa,Ma.defaultValues(Pa)),this.issuer=n.H$(e,Ua,Ma.defaultValues(Ua)),this.signature=n.H$(e,$a,Ma.defaultValues($a)),this.serialNumber=n.H$(e,La,Ma.defaultValues(La)),this.attrCertValidityPeriod=n.H$(e,Ra,Ma.defaultValues(Ra)),this.attributes=n.H$(e,Ka,Ma.defaultValues(Ka)),Ja in e&&(this.issuerUniqueID=n.H$(e,Ja,Ma.defaultValues(Ja))),_a in e&&(this.extensions=n.H$(e,_a,Ma.defaultValues(_a))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ta:return 1;case Pa:return new Oa;case Ua:return{};case $a:return new K;case La:return new r.z8;case Ra:return new Y;case Ka:return[];case Ja:return new r._K;case _a:return new Gr;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),Oa.schema(t.holder||{}),new r.Lv({value:[ee.schema({names:{blockName:t.issuer||u}}),new r.FC({name:t.issuer||u,idBlock:{tagClass:3,tagNumber:0},value:Ia.schema().valueBlock.value})]}),K.schema(t.signature||{}),new r.z8({name:t.serialNumber||u}),Y.schema(t.attrCertValidityPeriod||{}),new r.T9({name:t.attributes||u,value:[new r.ZD({value:z.schema()})]}),new r._K({optional:!0,name:t.issuerUniqueID||u}),Gr.schema(t.extensions||{},!0)]})}fromSchema(e){n.ze(e,Fa);const t=r.eN(e,e,Ma.schema({names:{version:Ta,holder:{names:{blockName:Pa}},issuer:Ua,signature:{names:{blockName:$a}},serialNumber:La,attrCertValidityPeriod:{names:{blockName:Ra}},attributes:Ka,issuerUniqueID:Ja,extensions:{names:{blockName:_a}}}}));if(m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new Oa({schema:t.result.holder}),3!==t.result.issuer.idBlock.tagClass)throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");this.issuer=new Ia({schema:new r.T9({value:t.result.issuer.valueBlock.value})}),this.signature=new K({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new Y({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,(e=>new z({schema:e}))),Ja in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),_a in t.result&&(this.extensions=new Gr({schema:t.result.extensions}))}toSchema(){const e=new r.T9({value:[new r.z8({value:this.version}),this.holder.toSchema(),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new r.T9({value:Array.from(this.attributes,(e=>e.toSchema()))})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,(e=>e.toJSON()))};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}Ma.CLASS_NAME="AttributeCertificateInfoV2";const ja="acinfo",qa="signatureAlgorithm",za="signatureValue",Wa=[ja,qa,za];class Ga extends f{constructor(e={}){super(),this.acinfo=n.H$(e,ja,Ga.defaultValues(ja)),this.signatureAlgorithm=n.H$(e,qa,Ga.defaultValues(qa)),this.signatureValue=n.H$(e,za,Ga.defaultValues(za)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ja:return new Ma;case qa:return new K;case za:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[Ma.schema(t.acinfo||{}),K.schema(t.signatureAlgorithm||{}),new r._K({name:t.signatureValue||u})]})}fromSchema(e){n.ze(e,Wa);const t=r.eN(e,e,Ga.schema({names:{acinfo:{names:{blockName:ja}},signatureAlgorithm:{names:{blockName:qa}},signatureValue:za}}));m.assertSchema(t,this.className),this.acinfo=new Ma({schema:t.result.acinfo}),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new r.T9({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}Ga.CLASS_NAME="AttributeCertificateV2";const Za="contentType",Ya="content",Qa=[Za,Ya];class Xa extends f{constructor(e={}){super(),this.contentType=n.H$(e,Za,Xa.defaultValues(Za)),this.content=n.H$(e,Ya,Xa.defaultValues(Ya)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Za:return u;case Ya:return new r.IK;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Za:return"string"==typeof t&&t===this.defaultValues(Za);case Ya:return t instanceof r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new r.T9({name:t.blockName||"ContentInfo",optional:t.optional,value:[new r.rP({name:t.contentType||Za}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.content||Ya})]})]})}fromSchema(e){n.ze(e,Qa);const t=r.eN(e,e,Xa.schema());m.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new r.T9({value:[new r.rP({value:this.contentType}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){const e={contentType:this.contentType};return this.content instanceof r.IK||(e.content=this.content.toJSON()),e}}Xa.CLASS_NAME="ContentInfo",Xa.DATA=pe,Xa.SIGNED_DATA=we,Xa.ENVELOPED_DATA=ye,Xa.ENCRYPTED_DATA=ve;const en="type",tn="value",sn="utcTimeName",rn="generalTimeName",an=[sn,rn];var nn;!function(e){e[e.UTCTime=0]="UTCTime",e[e.GeneralizedTime=1]="GeneralizedTime",e[e.empty=2]="empty"}(nn||(nn={}));class on extends f{constructor(e={}){super(),this.type=n.H$(e,en,on.defaultValues(en)),this.value=n.H$(e,tn,on.defaultValues(tn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case en:return 0;case tn:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){const s=n.H$(e,"names",{});return new r.Lv({optional:t,value:[new r.BD({name:s.utcTimeName||u}),new r.Yw({name:s.generalTimeName||u})]})}fromSchema(e){n.ze(e,an);const t=r.eN(e,e,on.schema({names:{utcTimeName:sn,generalTimeName:rn}}));m.assertSchema(t,this.className),sn in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),rn in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return 0===this.type?new r.BD({valueDate:this.value}):1===this.type?new r.Yw({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}}on.CLASS_NAME="Time";const ln="tbs",un="version",cn="serialNumber",hn="signature",mn="issuer",fn="notBefore",dn="notAfter",gn="subject",pn="subjectPublicKeyInfo",wn="issuerUniqueID",yn="subjectUniqueID",vn="extensions",bn="signatureAlgorithm",Sn="signatureValue",An="tbsCertificate",kn="tbsCertificate.version",Nn="tbsCertificate.serialNumber",Cn="tbsCertificate.signature",Bn="tbsCertificate.issuer",Vn="tbsCertificate.notBefore",In="tbsCertificate.notAfter",En="tbsCertificate.subject",Hn="tbsCertificate.subjectPublicKeyInfo",xn="tbsCertificate.issuerUniqueID",Dn="tbsCertificate.subjectUniqueID",On="tbsCertificate.extensions",Tn=[An,kn,Nn,Cn,Bn,Vn,In,En,Hn,xn,Dn,On,bn,Sn];function Pn(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||An,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({name:t.tbsCertificateVersion||kn})]}),new r.z8({name:t.tbsCertificateSerialNumber||Nn}),K.schema(t.signature||{names:{blockName:Cn}}),b.schema(t.issuer||{names:{blockName:Bn}}),new r.T9({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[on.schema(t.notBefore||{names:{utcTimeName:Vn,generalTimeName:Vn}}),on.schema(t.notAfter||{names:{utcTimeName:In,generalTimeName:In}})]}),b.schema(t.subject||{names:{blockName:En}}),ms.schema(t.subjectPublicKeyInfo||{names:{blockName:Hn}}),new r.WV({name:t.tbsCertificateIssuerUniqueID||xn,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new r.WV({name:t.tbsCertificateSubjectUniqueID||Dn,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Gr.schema(t.extensions||{names:{blockName:On}})]})]})}class Un extends f{constructor(e={}){super(),this.tbsView=new Uint8Array(n.H$(e,ln,Un.defaultValues(ln))),this.version=n.H$(e,un,Un.defaultValues(un)),this.serialNumber=n.H$(e,cn,Un.defaultValues(cn)),this.signature=n.H$(e,hn,Un.defaultValues(hn)),this.issuer=n.H$(e,mn,Un.defaultValues(mn)),this.notBefore=n.H$(e,fn,Un.defaultValues(fn)),this.notAfter=n.H$(e,dn,Un.defaultValues(dn)),this.subject=n.H$(e,gn,Un.defaultValues(gn)),this.subjectPublicKeyInfo=n.H$(e,pn,Un.defaultValues(pn)),wn in e&&(this.issuerUniqueID=n.H$(e,wn,Un.defaultValues(wn))),yn in e&&(this.subjectUniqueID=n.H$(e,yn,Un.defaultValues(yn))),vn in e&&(this.extensions=n.H$(e,vn,Un.defaultValues(vn))),this.signatureAlgorithm=n.H$(e,bn,Un.defaultValues(bn)),this.signatureValue=n.H$(e,Sn,Un.defaultValues(Sn)),e.schema&&this.fromSchema(e.schema)}get tbs(){return a.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case ln:return l;case un:return 0;case cn:return new r.z8;case hn:return new K;case mn:return new b;case fn:case dn:return new on;case gn:return new b;case pn:return new ms;case wn:case yn:return l;case vn:return[];case bn:return new K;case Sn:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[Pn(t.tbsCertificate),K.schema(t.signatureAlgorithm||{names:{blockName:bn}}),new r._K({name:t.signatureValue||Sn})]})}fromSchema(e){n.ze(e,Tn);const t=r.eN(e,e,Un.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:On}}}}}}));m.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,kn in t.result&&(this.version=t.result[kn].valueBlock.valueDec),this.serialNumber=t.result[Nn],this.signature=new K({schema:t.result[Cn]}),this.issuer=new b({schema:t.result[Bn]}),this.notBefore=new on({schema:t.result[Vn]}),this.notAfter=new on({schema:t.result[In]}),this.subject=new b({schema:t.result[En]}),this.subjectPublicKeyInfo=new ms({schema:t.result[Hn]}),xn in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),Dn in t.result&&(this.subjectUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),On in t.result&&(this.extensions=Array.from(t.result[On],(e=>new qr({schema:e})))),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return un in this&&this.version!==Un.defaultValues(un)&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new r.T9({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new r.WV({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new r.T9({value:Array.from(this.extensions,(e=>e.toSchema()))})]})),new r.T9({value:e})}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return Un.schema().value[0];const e=r.sc(this.tbsView);m.assert(e,"TBS Certificate"),t=e.result}else t=this.encodeTBS();return new r.T9({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:a.ep.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return un in this&&this.version!==Un.defaultValues(un)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=a.ep.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=a.ep.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,(e=>e.toJSON()))),e}async getPublicKey(e,t=pr(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=pr(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",s=pr(!0)){if(!e)throw new Error("Need to provide a private key for signing");const a=await s.getSignatureParameters(e,t),n=a.parameters;this.signature=a.signatureAlgorithm,this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await s.signWithPrivateKey(this.tbsView,e,n);this.signatureValue=new r._K({valueHex:i})}async verify(e,t=pr(!0)){let s;if(e?s=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(s=this.subjectPublicKeyInfo),!(s instanceof ms))throw new Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,s,this.signatureAlgorithm)}}function $n(e,t=null){if(t&&e.issuer.isEqual(t.issuer)&&e.serialNumber.isEqual(t.serialNumber))return null;let s=!1;if(e.extensions)for(const t of e.extensions)if(t.extnID===re&&t.parsedValue instanceof De&&t.parsedValue.cA){s=!0;break}return s?e:null}Un.CLASS_NAME="Certificate";const Ln="certId",Rn="certValue",Kn="parsedValue",Jn=[Ln,Rn];class _n extends f{constructor(e={}){super(),this.certId=n.H$(e,Ln,_n.defaultValues(Ln)),this.certValue=n.H$(e,Rn,_n.defaultValues(Rn)),Kn in e&&(this.parsedValue=n.H$(e,Kn,_n.defaultValues(Kn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ln:return u;case Rn:return new r.IK;case Kn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ln:return t===u;case Rn:return t instanceof r.IK;case Kn:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.id||"id"}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.value||"value"})]})]})}fromSchema(e){n.ze(e,Jn);const t=r.eN(e,e,_n.schema({names:{id:Ln,value:Rn}}));m.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;const s=this.certValue.valueBlock.valueHexView;switch(this.certId){case be:try{this.parsedValue=Un.fromBER(s)}catch(e){Ga.fromBER(s)}break;case Se:this.parsedValue=Ga.fromBER(s);break;default:throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return Kn in this&&("acinfo"in this.parsedValue?this.certId=Se:this.certId=be,this.certValue=new r.fi({valueHex:this.parsedValue.toSchema().toBER(!1)})),new r.T9({value:[new r.rP({value:this.certId}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}_n.CLASS_NAME="CertBag";const Fn="userCertificate",Mn="revocationDate",jn="crlEntryExtensions",qn=[Fn,Mn,jn];class zn extends f{constructor(e={}){super(),this.userCertificate=n.H$(e,Fn,zn.defaultValues(Fn)),this.revocationDate=n.H$(e,Mn,zn.defaultValues(Mn)),jn in e&&(this.crlEntryExtensions=n.H$(e,jn,zn.defaultValues(jn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fn:return new r.z8;case Mn:return new on;case jn:return new Gr;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.userCertificate||Fn}),on.schema({names:{utcTimeName:t.revocationDate||Mn,generalTimeName:t.revocationDate||Mn}}),Gr.schema({names:{blockName:t.crlEntryExtensions||jn}},!0)]})}fromSchema(e){n.ze(e,qn);const t=r.eN(e,e,zn.schema());m.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new on({schema:t.result.revocationDate}),jn in t.result&&(this.crlEntryExtensions=new Gr({schema:t.result.crlEntryExtensions}))}toSchema(){const e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new r.T9({value:e})}toJSON(){const e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}zn.CLASS_NAME="RevokedCertificate";const Wn="tbs",Gn="version",Zn="signature",Yn="issuer",Qn="thisUpdate",Xn="nextUpdate",ei="revokedCertificates",ti="crlExtensions",si="signatureAlgorithm",ri="signatureValue",ai="tbsCertList",ni="tbsCertList.version",ii="tbsCertList.signature",oi="tbsCertList.issuer",li="tbsCertList.thisUpdate",ui="tbsCertList.nextUpdate",ci="tbsCertList.revokedCertificates",hi="tbsCertList.extensions",mi=[ai,ni,ii,oi,li,ui,ci,hi,si,ri];function fi(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||ai,value:[new r.z8({optional:!0,name:t.tbsCertListVersion||ni,value:2}),K.schema(t.signature||{names:{blockName:ii}}),b.schema(t.issuer||{names:{blockName:oi}}),on.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:li,generalTimeName:li}}),on.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:ui,generalTimeName:ui}},!0),new r.T9({optional:!0,value:[new r.ZD({name:t.tbsCertListRevokedCertificates||ci,value:new r.T9({value:[new r.z8,on.schema(),Gr.schema({},!0)]})})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Gr.schema(t.crlExtensions||{names:{blockName:hi}})]})]})}const di=[me,se,"2.5.29.20","2.5.29.27",ae,le,de,"2.5.29.21","2.5.29.24",ne];class gi extends f{constructor(e={}){super(),this.tbsView=new Uint8Array(n.H$(e,Wn,gi.defaultValues(Wn))),this.version=n.H$(e,Gn,gi.defaultValues(Gn)),this.signature=n.H$(e,Zn,gi.defaultValues(Zn)),this.issuer=n.H$(e,Yn,gi.defaultValues(Yn)),this.thisUpdate=n.H$(e,Qn,gi.defaultValues(Qn)),Xn in e&&(this.nextUpdate=n.H$(e,Xn,gi.defaultValues(Xn))),ei in e&&(this.revokedCertificates=n.H$(e,ei,gi.defaultValues(ei))),ti in e&&(this.crlExtensions=n.H$(e,ti,gi.defaultValues(ti))),this.signatureAlgorithm=n.H$(e,si,gi.defaultValues(si)),this.signatureValue=n.H$(e,ri,gi.defaultValues(ri)),e.schema&&this.fromSchema(e.schema)}get tbs(){return a.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case Wn:return l;case Gn:return 0;case Zn:return new K;case Yn:return new b;case Qn:case Xn:return new on;case ei:return[];case ti:return new Gr;case si:return new K;case ri:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||"CertificateList",value:[fi(e),K.schema(t.signatureAlgorithm||{names:{blockName:si}}),new r._K({name:t.signatureValue||ri})]})}fromSchema(e){n.ze(e,mi);const t=r.eN(e,e,gi.schema());m.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,ni in t.result&&(this.version=t.result[ni].valueBlock.valueDec),this.signature=new K({schema:t.result[ii]}),this.issuer=new b({schema:t.result[oi]}),this.thisUpdate=new on({schema:t.result["tbsCertList.thisUpdate"]}),ui in t.result&&(this.nextUpdate=new on({schema:t.result["tbsCertList.nextUpdate"]})),ci in t.result&&(this.revokedCertificates=Array.from(t.result["tbsCertList.revokedCertificates"],(e=>new zn({schema:e})))),hi in t.result&&(this.crlExtensions=new Gr({schema:t.result[hi]})),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return this.version!==gi.defaultValues(Gn)&&e.push(new r.z8({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new r.T9({value:Array.from(this.revokedCertificates,(e=>e.toSchema()))})),this.crlExtensions&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new r.T9({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return gi.schema();const e=r.sc(this.tbsView);m.assert(e,"TBS Certificate Revocation List"),t=e.result}return new r.T9({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:a.ep.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==gi.defaultValues(Gn)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,(e=>e.toJSON()))),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer))return!1;if(!this.revokedCertificates)return!1;for(const t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",s=pr(!0)){if(!e)throw new Error("Need to provide a private key for signing");const a=await s.getSignatureParameters(e,t),{parameters:n}=a;this.signature=a.signatureAlgorithm,this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await s.signWithPrivateKey(this.tbsView,e,n);this.signatureValue=new r._K({valueHex:i})}async verify(e={},t=pr(!0)){let s;if(e.issuerCertificate&&(s=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(s=e.publicKeyInfo),!s)throw new Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions)for(const e of this.crlExtensions.extensions)if(e.critical&&!di.includes(e.extnID))return!1;return t.verifyWithPublicKey(this.tbsView,this.signatureValue,s,this.signatureAlgorithm)}}gi.CLASS_NAME="CertificateRevocationList";const pi="crlId",wi="crlValue",yi="parsedValue",vi=[pi,wi];class bi extends f{constructor(e={}){super(),this.crlId=n.H$(e,pi,bi.defaultValues(pi)),this.crlValue=n.H$(e,wi,bi.defaultValues(wi)),yi in e&&(this.parsedValue=n.H$(e,yi,bi.defaultValues(yi))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pi:return u;case wi:return new r.IK;case yi:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pi:return t===u;case wi:return t instanceof r.IK;case yi:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.id||"id"}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.value||"value"})]})]})}fromSchema(e){n.ze(e,vi);const t=r.eN(e,e,bi.schema({names:{id:pi,value:wi}}));if(m.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId!==Ae)throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);this.parsedValue=gi.fromBER(this.certValue.valueBlock.valueHex)}toSchema(){return this.parsedValue&&(this.crlId=Ae,this.crlValue=new r.fi({valueHex:this.parsedValue.toSchema().toBER(!1)})),new r.T9({value:[new r.rP({value:this.crlId}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}bi.CLASS_NAME="CRLBag";const Si="version",Ai="encryptedContentInfo",ki="unprotectedAttrs",Ni=[Si,Ai,ki];class Ci extends f{constructor(e={}){super(),this.version=n.H$(e,Si,Ci.defaultValues(Si)),this.encryptedContentInfo=n.H$(e,Ai,Ci.defaultValues(Ai)),ki in e&&(this.unprotectedAttrs=n.H$(e,ki,Ci.defaultValues(ki))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Si:return 0;case Ai:return new zs;case ki:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Si:return 0===t;case Ai:return zs.compareWithDefault("contentType",t.contentType)&&zs.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&zs.compareWithDefault("encryptedContent",t.encryptedContent);case ki:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),zs.schema(t.encryptedContentInfo||{}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.ZD({name:t.unprotectedAttrs||u,value:z.schema()})]})]})}fromSchema(e){n.ze(e,Ni);const t=r.eN(e,e,Ci.schema({names:{version:Si,encryptedContentInfo:{names:{blockName:Ai}},unprotectedAttrs:ki}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new zs({schema:t.result.encryptedContentInfo}),ki in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,(e=>new z({schema:e}))))}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,(e=>e.toJSON()))),e}async encrypt(e){c.assert(e,"parameters","object");const t={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await pr(!0).encryptEncryptedContentInfo(t)}async decrypt(e,t=pr(!0)){c.assert(e,"parameters","object");const s={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(s)}}Ci.CLASS_NAME="EncryptedData";const Bi="encryptionAlgorithm",Vi="encryptedData",Ii="parsedValue",Ei=[Bi,Vi];class Hi extends f{constructor(e={}){super(),this.encryptionAlgorithm=n.H$(e,Bi,Hi.defaultValues(Bi)),this.encryptedData=n.H$(e,Vi,Hi.defaultValues(Vi)),Ii in e&&(this.parsedValue=n.H$(e,Ii,Hi.defaultValues(Ii))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bi:return new K;case Vi:return new r.fi;case Ii:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Bi:return K.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case Vi:return t.isEqual(Hi.defaultValues(e));case Ii:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.encryptionAlgorithm||{names:{blockName:Bi}}),new r.Lv({value:[new r.fi({name:t.encryptedData||Vi}),new r.fi({idBlock:{isConstructed:!0},name:t.encryptedData||Vi})]})]})}fromSchema(e){n.ze(e,Ei);const t=r.eN(e,e,Hi.schema({names:{encryptionAlgorithm:{names:{blockName:Bi}},encryptedData:Vi}}));m.assertSchema(t,this.className),this.encryptionAlgorithm=new K({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new r.T9({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=pr(!0)){const s=new Ci({encryptedContentInfo:new zs({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}),r=await s.decrypt(e,t);this.parsedValue=_s.fromBER(r)}async makeInternalValues(e){if(!this.parsedValue)throw new Error('Please initialize "parsedValue" first');const t=new Ci,s={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await t.encrypt(s),!t.encryptedContentInfo.encryptedContent)throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=t.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=t.encryptedContentInfo.encryptedContent}}Hi.CLASS_NAME="PKCS8ShroudedKeyBag";const xi="secretTypeId",Di="secretValue",Oi=[xi,Di];class Ti extends f{constructor(e={}){super(),this.secretTypeId=n.H$(e,xi,Ti.defaultValues(xi)),this.secretValue=n.H$(e,Di,Ti.defaultValues(Di)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xi:return u;case Di:return new r.IK;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xi:return t===u;case Di:return t instanceof r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.id||"id"}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.value||"value"})]})]})}fromSchema(e){n.ze(e,Oi);const t=r.eN(e,e,Ti.schema({names:{id:xi,value:Di}}));m.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new r.T9({value:[new r.rP({value:this.secretTypeId}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}Ti.CLASS_NAME="SecretBag";class Pi{static getItems(){return this.items||(this.items={},Pi.register("1.2.840.113549.1.12.10.1.1",_s),Pi.register("1.2.840.113549.1.12.10.1.2",Hi),Pi.register("1.2.840.113549.1.12.10.1.3",_n),Pi.register("1.2.840.113549.1.12.10.1.4",bi),Pi.register("1.2.840.113549.1.12.10.1.5",Ti),Pi.register("1.2.840.113549.1.12.10.1.6",_i)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}}const Ui="bagId",$i="bagValue",Li="bagAttributes",Ri=[Ui,$i,Li];class Ki extends f{constructor(e={}){super(),this.bagId=n.H$(e,Ui,Ki.defaultValues(Ui)),this.bagValue=n.H$(e,$i,Ki.defaultValues($i)),Li in e&&(this.bagAttributes=n.H$(e,Li,Ki.defaultValues(Li))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ui:return u;case $i:return new r.IK;case Li:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ui:return t===u;case $i:return t instanceof r.IK;case Li:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.bagId||Ui}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.bagValue||$i})]}),new r.l4({optional:!0,value:[new r.ZD({name:t.bagAttributes||Li,value:z.schema()})]})]})}fromSchema(e){n.ze(e,Ri);const t=r.eN(e,e,Ki.schema({names:{bagId:Ui,bagValue:$i,bagAttributes:Li}}));m.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();const s=Pi.find(this.bagId);if(!s)throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new s({schema:t.result.bagValue}),Li in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,(e=>new z({schema:e}))))}toSchema(){const e=[new r.rP({value:this.bagId}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new r.l4({value:Array.from(this.bagAttributes,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,(e=>e.toJSON()))),e}}Ki.CLASS_NAME="SafeBag";const Ji="safeBags";class _i extends f{constructor(e={}){super(),this.safeBags=n.H$(e,Ji,_i.defaultValues(Ji)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Ji?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Ji?0===t.length:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.safeBags||u,value:Ki.schema()})]})}fromSchema(e){n.ze(e,[Ji]);const t=r.eN(e,e,_i.schema({names:{safeBags:Ji}}));m.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,(e=>new Ki({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.safeBags,(e=>e.toSchema()))})}toJSON(){return{safeBags:Array.from(this.safeBags,(e=>e.toJSON()))}}}_i.CLASS_NAME="SafeContents";const Fi="otherCertFormat",Mi="otherCert",ji=[Fi,Mi];class qi extends f{constructor(e={}){super(),this.otherCertFormat=n.H$(e,Fi,qi.defaultValues(Fi)),this.otherCert=n.H$(e,Mi,qi.defaultValues(Mi)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fi:return u;case Mi:return new r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.otherCertFormat||Fi}),new r.IK({name:t.otherCert||Mi})]})}fromSchema(e){n.ze(e,ji);const t=r.eN(e,e,qi.schema());m.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new r.T9({value:[new r.rP({value:this.otherCertFormat}),this.otherCert]})}toJSON(){const e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof r.IK||(e.otherCert=this.otherCert.toJSON()),e}}const zi="certificates",Wi=[zi];class Gi extends f{constructor(e={}){super(),this.certificates=n.H$(e,zi,Gi.defaultValues(zi)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===zi?[]:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.l4({name:t.blockName||u,value:[new r.ZD({name:t.certificates||zi,value:new r.Lv({value:[Un.schema(),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.IK]}),new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[new r.T9]}),new r.FC({idBlock:{tagClass:3,tagNumber:2},value:Ga.schema().valueBlock.value}),new r.FC({idBlock:{tagClass:3,tagNumber:3},value:qi.schema().valueBlock.value})]})})]})}fromSchema(e){n.ze(e,Wi);const t=r.eN(e,e,Gi.schema());m.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],(e=>{const t=e.idBlock.tagNumber;if(1===e.idBlock.tagClass)return new Un({schema:e});const s=new r.T9({value:e.valueBlock.value});switch(t){case 1:return 1===s.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec?new Ga({schema:s}):new wa({schema:s});case 2:return new Ga({schema:s});case 3:return new qi({schema:s})}return e}))}toSchema(){return new r.l4({value:Array.from(this.certificates,(e=>{switch(!0){case e instanceof Un:return e.toSchema();case e instanceof wa:return new r.FC({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof Ga:return new r.FC({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof qi:return new r.FC({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()}))})}toJSON(){return{certificates:Array.from(this.certificates,(e=>e.toJSON()))}}}Gi.CLASS_NAME="CertificateSet";const Zi="otherRevInfoFormat",Yi="otherRevInfo",Qi=[Zi,Yi];class Xi extends f{constructor(e={}){super(),this.otherRevInfoFormat=n.H$(e,Zi,Xi.defaultValues(Zi)),this.otherRevInfo=n.H$(e,Yi,Xi.defaultValues(Yi)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zi:return u;case Yi:return new r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.otherRevInfoFormat||Zi}),new r.IK({name:t.otherRevInfo||Yi})]})}fromSchema(e){n.ze(e,Qi);const t=r.eN(e,e,Xi.schema());m.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new r.T9({value:[new r.rP({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){const e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof r.IK||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}Xi.CLASS_NAME="OtherRevocationInfoFormat";const eo="crls",to="otherRevocationInfos",so=[eo];class ro extends f{constructor(e={}){super(),this.crls=n.H$(e,eo,ro.defaultValues(eo)),this.otherRevocationInfos=n.H$(e,to,ro.defaultValues(to)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eo:case to:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.l4({name:t.blockName||u,value:[new r.ZD({name:t.crls||u,value:new r.Lv({value:[gi.schema(),new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[new r.rP,new r.IK]})]})})]})}fromSchema(e){n.ze(e,so);const t=r.eN(e,e,ro.schema({names:{crls:eo}}));if(m.assertSchema(t,this.className),t.result.crls)for(const e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new gi({schema:e})):this.otherRevocationInfos.push(new Xi({schema:e}))}toSchema(){const e=[];return e.push(...Array.from(this.crls,(e=>e.toSchema()))),e.push(...Array.from(this.otherRevocationInfos,(e=>{const t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t}))),new r.l4({value:e})}toJSON(){return{crls:Array.from(this.crls,(e=>e.toJSON())),otherRevocationInfos:Array.from(this.otherRevocationInfos,(e=>e.toJSON()))}}}ro.CLASS_NAME="RevocationInfoChoices";const ao="certs",no="crls",io=[ao,no];class oo extends f{constructor(e={}){super(),this.crls=n.H$(e,no,oo.defaultValues(no)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ao:return new Gi;case no:return new ro;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ao:return 0===t.certificates.length;case no:return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({name:t.certs||u,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Gi.schema().valueBlock.value}),new r.FC({name:t.crls||u,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:ro.schema().valueBlock.value})]})}fromSchema(e){n.ze(e,io);const t=r.eN(e,e,oo.schema({names:{certs:ao,crls:no}}));m.assertSchema(t,this.className),ao in t.result&&(this.certs=new Gi({schema:new r.l4({value:t.result.certs.valueBlock.value})})),no in t.result&&(this.crls=new ro({schema:new r.l4({value:t.result.crls.valueBlock.value})}))}toSchema(){const e=[];return this.certs&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new r.T9({value:e})}toJSON(){const e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}}oo.CLASS_NAME="OriginatorInfo";const lo="issuer",uo="serialNumber",co=[lo,uo];class ho extends f{constructor(e={}){super(),this.issuer=n.H$(e,lo,ho.defaultValues(lo)),this.serialNumber=n.H$(e,uo,ho.defaultValues(uo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lo:return new b;case uo:return new r.z8;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[b.schema(t.issuer||{}),new r.z8({name:t.serialNumber||u})]})}fromSchema(e){n.ze(e,co);const t=r.eN(e,e,ho.schema({names:{issuer:{names:{blockName:lo}},serialNumber:uo}}));m.assertSchema(t,this.className),this.issuer=new b({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new r.T9({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}ho.CLASS_NAME="IssuerAndSerialNumber";const mo="variant",fo="value",go=["blockName"];class po extends f{constructor(e={}){super(),this.variant=n.H$(e,mo,po.defaultValues(mo)),fo in e&&(this.value=n.H$(e,fo,po.defaultValues(fo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case mo:return-1;case fo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case mo:return-1===t;case fo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.Lv({value:[ho.schema({names:{blockName:t.blockName||u}}),new r.WV({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){n.ze(e,go);const t=r.eN(e,e,po.schema({names:{blockName:"blockName"}}));m.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new ho({schema:t.result.blockName})):(this.variant=2,this.value=new r.fi({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof ho))throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof r.fi))throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new r.WV({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new r.IK}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||!this.value||(e.value=this.value.toJSON()),e}}po.CLASS_NAME="RecipientIdentifier";const wo="version",yo="rid",vo="keyEncryptionAlgorithm",bo="encryptedKey",So="recipientCertificate",Ao=[wo,yo,vo,bo];class ko extends f{constructor(e={}){super(),this.version=n.H$(e,wo,ko.defaultValues(wo)),this.rid=n.H$(e,yo,ko.defaultValues(yo)),this.keyEncryptionAlgorithm=n.H$(e,vo,ko.defaultValues(vo)),this.encryptedKey=n.H$(e,bo,ko.defaultValues(bo)),this.recipientCertificate=n.H$(e,So,ko.defaultValues(So)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wo:return-1;case yo:return{};case vo:return new K;case bo:return new r.fi;case So:return new Un;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case wo:return t===ko.defaultValues(wo);case yo:return 0===Object.keys(t).length;case vo:case bo:return t.isEqual(ko.defaultValues(e));case So:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),po.schema(t.rid||{}),K.schema(t.keyEncryptionAlgorithm||{}),new r.fi({name:t.encryptedKey||u})]})}fromSchema(e){n.ze(e,Ao);const t=r.eN(e,e,ko.schema({names:{version:wo,rid:{names:{blockName:yo}},keyEncryptionAlgorithm:{names:{blockName:vo}},encryptedKey:bo}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=new r.fi({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new ho({schema:t.result.rid}),this.keyEncryptionAlgorithm=new K({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return this.rid instanceof ho?(this.version=0,e.push(new r.z8({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new r.z8({value:this.version})),e.push(new r.WV({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new r.T9({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}ko.CLASS_NAME="KeyTransRecipientInfo";const No="algorithm",Co="publicKey",Bo=[No,Co];class Vo extends f{constructor(e={}){super(),this.algorithm=n.H$(e,No,Vo.defaultValues(No)),this.publicKey=n.H$(e,Co,Vo.defaultValues(Co)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case No:return new K;case Co:return new r._K;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case No:case Co:return t.isEqual(Vo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.algorithm||{}),new r._K({name:t.publicKey||u})]})}fromSchema(e){n.ze(e,Bo);const t=r.eN(e,e,Vo.schema({names:{algorithm:{names:{blockName:No}},publicKey:Co}}));m.assertSchema(t,this.className),this.algorithm=new K({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new r.T9({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}Vo.CLASS_NAME="OriginatorPublicKey";const Io="variant",Eo="value",Ho=["blockName"];class xo extends f{constructor(e={}){super(),this.variant=n.H$(e,Io,xo.defaultValues(Io)),Eo in e&&(this.value=n.H$(e,Eo,xo.defaultValues(Eo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Io:return-1;case Eo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Io:return-1===t;case Eo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.Lv({value:[ho.schema({names:{blockName:t.blockName||u}}),new r.WV({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||u}),new r.FC({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||u,value:Vo.schema().valueBlock.value})]})}fromSchema(e){n.ze(e,Ho);const t=r.eN(e,e,xo.schema({names:{blockName:"blockName"}}));m.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new ho({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new Vo({schema:new r.T9({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{const e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new r.IK}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant&&3!==this.variant||(e.value=this.value.toJSON()),e}}xo.CLASS_NAME="OriginatorIdentifierOrKey";const Do="keyAttrId",Oo="keyAttr",To=[Do,Oo];class Po extends f{constructor(e={}){super(),this.keyAttrId=n.H$(e,Do,Po.defaultValues(Do)),Oo in e&&(this.keyAttr=n.H$(e,Oo,Po.defaultValues(Oo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Do:return u;case Oo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Do:return"string"==typeof t&&t===u;case Oo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({optional:t.optional||!0,name:t.blockName||u,value:[new r.rP({name:t.keyAttrId||u}),new r.IK({optional:!0,name:t.keyAttr||u})]})}fromSchema(e){n.ze(e,To);const t=r.eN(e,e,Po.schema({names:{keyAttrId:Do,keyAttr:Oo}}));m.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),Oo in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){const e=[];return e.push(new r.rP({value:this.keyAttrId})),Oo in this&&e.push(this.keyAttr),new r.T9({value:e})}toJSON(){const e={keyAttrId:this.keyAttrId};return Oo in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}Po.CLASS_NAME="OtherKeyAttribute";const Uo="subjectKeyIdentifier",$o="date",Lo="other",Ro=[Uo,$o,Lo];class Ko extends f{constructor(e={}){super(),this.subjectKeyIdentifier=n.H$(e,Uo,Ko.defaultValues(Uo)),$o in e&&(this.date=n.H$(e,$o,Ko.defaultValues($o))),Lo in e&&(this.other=n.H$(e,Lo,Ko.defaultValues(Lo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Uo:return new r.fi;case $o:return new r.Yw;case Lo:return new Po;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Uo:return t.isEqual(Ko.defaultValues(Uo));case $o:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case Lo:return t.keyAttrId===u&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.fi({name:t.subjectKeyIdentifier||u}),new r.Yw({optional:!0,name:t.date||u}),Po.schema(t.other||{})]})}fromSchema(e){n.ze(e,Ro);const t=r.eN(e,e,Ko.schema({names:{subjectKeyIdentifier:Uo,date:$o,other:{names:{blockName:Lo}}}}));m.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,$o in t.result&&(this.date=t.result.date),Lo in t.result&&(this.other=new Po({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new r.T9({value:e})}toJSON(){const e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}}Ko.CLASS_NAME="RecipientKeyIdentifier";const Jo="variant",_o="value",Fo=["blockName"];class Mo extends f{constructor(e={}){super(),this.variant=n.H$(e,Jo,Mo.defaultValues(Jo)),this.value=n.H$(e,_o,Mo.defaultValues(_o)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jo:return-1;case _o:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Jo:return-1===t;case _o:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.Lv({value:[ho.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||u}}),new r.FC({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:0},value:Ko.schema(t.rKeyId||{names:{blockName:t.blockName||u}}).valueBlock.value})]})}fromSchema(e){n.ze(e,Fo);const t=r.eN(e,e,Mo.schema({names:{blockName:"blockName"}}));m.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new ho({schema:t.result.blockName})):(this.variant=2,this.value=new Ko({schema:new r.T9({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new r.IK}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}Mo.CLASS_NAME="KeyAgreeRecipientIdentifier";const jo="rid",qo="encryptedKey",zo=[jo,qo];class Wo extends f{constructor(e={}){super(),this.rid=n.H$(e,jo,Wo.defaultValues(jo)),this.encryptedKey=n.H$(e,qo,Wo.defaultValues(qo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jo:return new Mo;case qo:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case jo:return-1===t.variant&&"value"in t==!1;case qo:return t.isEqual(Wo.defaultValues(qo));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[Mo.schema(t.rid||{}),new r.fi({name:t.encryptedKey||u})]})}fromSchema(e){n.ze(e,zo);const t=r.eN(e,e,Wo.schema({names:{rid:{names:{blockName:jo}},encryptedKey:qo}}));m.assertSchema(t,this.className),this.rid=new Mo({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new r.T9({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}Wo.CLASS_NAME="RecipientEncryptedKey";const Go="encryptedKeys",Zo="RecipientEncryptedKeys",Yo=[Zo];class Qo extends f{constructor(e={}){super(),this.encryptedKeys=n.H$(e,Go,Qo.defaultValues(Go)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Go?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Go?0===t.length:super.defaultValues(e)}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.RecipientEncryptedKeys||u,value:Wo.schema()})]})}fromSchema(e){n.ze(e,Yo);const t=r.eN(e,e,Qo.schema({names:{RecipientEncryptedKeys:Zo}}));m.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,(e=>new Wo({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.encryptedKeys,(e=>e.toSchema()))})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,(e=>e.toJSON()))}}}Qo.CLASS_NAME="RecipientEncryptedKeys";const Xo="version",el="originator",tl="ukm",sl="keyEncryptionAlgorithm",rl="recipientEncryptedKeys",al="recipientCertificate",nl="recipientPublicKey",il=[Xo,el,tl,sl,rl];class ol extends f{constructor(e={}){super(),this.version=n.H$(e,Xo,ol.defaultValues(Xo)),this.originator=n.H$(e,el,ol.defaultValues(el)),tl in e&&(this.ukm=n.H$(e,tl,ol.defaultValues(tl))),this.keyEncryptionAlgorithm=n.H$(e,sl,ol.defaultValues(sl)),this.recipientEncryptedKeys=n.H$(e,rl,ol.defaultValues(rl)),this.recipientCertificate=n.H$(e,al,ol.defaultValues(al)),this.recipientPublicKey=n.H$(e,nl,ol.defaultValues(nl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xo:return 0;case el:return new xo;case tl:return new r.fi;case sl:return new K;case rl:return new Qo;case al:return new Un;case nl:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Xo:return 0===t;case el:return-1===t.variant&&"value"in t==!1;case tl:return t.isEqual(ol.defaultValues(tl));case sl:return t.algorithmId===u&&"algorithmParams"in t==!1;case rl:return 0===t.encryptedKeys.length;case al:case nl:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[xo.schema(t.originator||{})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.fi({name:t.ukm||u})]}),K.schema(t.keyEncryptionAlgorithm||{}),Qo.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){n.ze(e,il);const t=r.eN(e,e,ol.schema({names:{version:Xo,originator:{names:{blockName:el}},ukm:tl,keyEncryptionAlgorithm:{names:{blockName:sl}},recipientEncryptedKeys:{names:{blockName:rl}}}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new xo({schema:t.result.originator}),tl in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new K({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new Qo({schema:t.result.recipientEncryptedKeys})}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new r.T9({value:e})}toJSON(){const e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}}ol.CLASS_NAME="KeyAgreeRecipientInfo";const ll="keyIdentifier",ul="date",cl="other",hl=[ll,ul,cl];class ml extends f{constructor(e={}){super(),this.keyIdentifier=n.H$(e,ll,ml.defaultValues(ll)),ul in e&&(this.date=n.H$(e,ul,ml.defaultValues(ul))),cl in e&&(this.other=n.H$(e,cl,ml.defaultValues(cl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ll:return new r.fi;case ul:return new r.Yw;case cl:return new Po;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ll:return t.isEqual(ml.defaultValues(ll));case ul:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case cl:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.fi({name:t.keyIdentifier||u}),new r.Yw({optional:!0,name:t.date||u}),Po.schema(t.other||{})]})}fromSchema(e){n.ze(e,hl);const t=r.eN(e,e,ml.schema({names:{keyIdentifier:ll,date:ul,other:{names:{blockName:cl}}}}));m.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,ul in t.result&&(this.date=t.result.date),cl in t.result&&(this.other=new Po({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new r.T9({value:e})}toJSON(){const e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}}ml.CLASS_NAME="KEKIdentifier";const fl="version",dl="kekid",gl="keyEncryptionAlgorithm",pl="encryptedKey",wl="preDefinedKEK",yl=[fl,dl,gl,pl];class vl extends f{constructor(e={}){super(),this.version=n.H$(e,fl,vl.defaultValues(fl)),this.kekid=n.H$(e,dl,vl.defaultValues(dl)),this.keyEncryptionAlgorithm=n.H$(e,gl,vl.defaultValues(gl)),this.encryptedKey=n.H$(e,pl,vl.defaultValues(pl)),this.preDefinedKEK=n.H$(e,wl,vl.defaultValues(wl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fl:return 0;case dl:return new ml;case gl:return new K;case pl:return new r.fi;case wl:return l;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===vl.defaultValues(fl);case dl:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case gl:return t.algorithmId===u&&"algorithmParams"in t==!1;case pl:return t.isEqual(vl.defaultValues(pl));case wl:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),ml.schema(t.kekid||{}),K.schema(t.keyEncryptionAlgorithm||{}),new r.fi({name:t.encryptedKey||u})]})}fromSchema(e){n.ze(e,yl);const t=r.eN(e,e,vl.schema({names:{version:fl,kekid:{names:{blockName:dl}},keyEncryptionAlgorithm:{names:{blockName:gl}},encryptedKey:pl}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new ml({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new K({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new r.T9({value:[new r.z8({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}vl.CLASS_NAME="KEKRecipientInfo";const bl="version",Sl="keyDerivationAlgorithm",Al="keyEncryptionAlgorithm",kl="encryptedKey",Nl="password",Cl=[bl,Sl,Al,kl];class Bl extends f{constructor(e={}){super(),this.version=n.H$(e,bl,Bl.defaultValues(bl)),Sl in e&&(this.keyDerivationAlgorithm=n.H$(e,Sl,Bl.defaultValues(Sl))),this.keyEncryptionAlgorithm=n.H$(e,Al,Bl.defaultValues(Al)),this.encryptedKey=n.H$(e,kl,Bl.defaultValues(kl)),this.password=n.H$(e,Nl,Bl.defaultValues(Nl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case bl:return-1;case Sl:case Al:return new K;case kl:return new r.fi;case Nl:return l;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case bl:return-1===t;case Sl:case Al:return t.algorithmId===u&&"algorithmParams"in t==!1;case kl:return t.isEqual(Bl.defaultValues(kl));case Nl:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.FC({name:t.keyDerivationAlgorithm||u,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:K.schema().valueBlock.value}),K.schema(t.keyEncryptionAlgorithm||{}),new r.fi({name:t.encryptedKey||u})]})}fromSchema(e){n.ze(e,Cl);const t=r.eN(e,e,Bl.schema({names:{version:bl,keyDerivationAlgorithm:Sl,keyEncryptionAlgorithm:{names:{blockName:Al}},encryptedKey:kl}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,Sl in t.result&&(this.keyDerivationAlgorithm=new K({schema:new r.T9({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new K({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),this.keyDerivationAlgorithm&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new r.T9({value:e})}toJSON(){const e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}}Bl.CLASS_NAME="PasswordRecipientInfo";const Vl="oriType",Il="oriValue",El=[Vl,Il];class Hl extends f{constructor(e={}){super(),this.oriType=n.H$(e,Vl,Hl.defaultValues(Vl)),this.oriValue=n.H$(e,Il,Hl.defaultValues(Il)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vl:return u;case Il:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Vl:return t===u;case Il:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.oriType||u}),new r.IK({name:t.oriValue||u})]})}fromSchema(e){n.ze(e,El);const t=r.eN(e,e,Hl.schema({names:{oriType:Vl,oriValue:Il}}));m.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new r.T9({value:[new r.rP({value:this.oriType}),this.oriValue]})}toJSON(){const e={oriType:this.oriType};return Hl.compareWithDefault(Il,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}}Hl.CLASS_NAME="OtherRecipientInfo";const xl="variant",Dl="value",Ol=["blockName"];class Tl extends f{constructor(e={}){super(),this.variant=n.H$(e,xl,Tl.defaultValues(xl)),Dl in e&&(this.value=n.H$(e,Dl,Tl.defaultValues(Dl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xl:return-1;case Dl:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xl:return t===Tl.defaultValues(e);case Dl:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.Lv({value:[ko.schema({names:{blockName:t.blockName||u}}),new r.FC({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:1},value:ol.schema().valueBlock.value}),new r.FC({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:2},value:vl.schema().valueBlock.value}),new r.FC({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:3},value:Bl.schema().valueBlock.value}),new r.FC({name:t.blockName||u,idBlock:{tagClass:3,tagNumber:4},value:Hl.schema().valueBlock.value})]})}fromSchema(e){n.ze(e,Ol);const t=r.eN(e,e,Tl.schema({names:{blockName:"blockName"}}));if(m.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new ko({schema:t.result.blockName});else{const e=new r.T9({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new ol({schema:e});break;case 2:this.variant=3,this.value=new vl({schema:e});break;case 3:this.variant=4,this.value=new Bl({schema:e});break;case 4:this.variant=5,this.value=new Hl({schema:e});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){h.assertEmpty(this.value,"value","RecipientInfo");const e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new r.IK}}toJSON(){const e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}Tl.CLASS_NAME="RecipientInfo";const Pl="hashAlgorithm",Ul="maskGenAlgorithm",$l="pSourceAlgorithm",Ll=[Pl,Ul,$l];class Rl extends f{constructor(e={}){super(),this.hashAlgorithm=n.H$(e,Pl,Rl.defaultValues(Pl)),this.maskGenAlgorithm=n.H$(e,Ul,Rl.defaultValues(Ul)),this.pSourceAlgorithm=n.H$(e,$l,Rl.defaultValues($l)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pl:return new K({algorithmId:"1.3.14.3.2.26",algorithmParams:new r.p2});case Ul:return new K({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new K({algorithmId:"1.3.14.3.2.26",algorithmParams:new r.p2}).toSchema()});case $l:return new K({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new r.fi({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.FC({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[K.schema(t.hashAlgorithm||{})]}),new r.FC({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[K.schema(t.maskGenAlgorithm||{})]}),new r.FC({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[K.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){n.ze(e,Ll);const t=r.eN(e,e,Rl.schema({names:{hashAlgorithm:{names:{blockName:Pl}},maskGenAlgorithm:{names:{blockName:Ul}},pSourceAlgorithm:{names:{blockName:$l}}}}));m.assertSchema(t,this.className),Pl in t.result&&(this.hashAlgorithm=new K({schema:t.result.hashAlgorithm})),Ul in t.result&&(this.maskGenAlgorithm=new K({schema:t.result.maskGenAlgorithm})),$l in t.result&&(this.pSourceAlgorithm=new K({schema:t.result.pSourceAlgorithm}))}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Rl.defaultValues(Pl))||e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Rl.defaultValues(Ul))||e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(Rl.defaultValues($l))||e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new r.T9({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Rl.defaultValues(Pl))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Rl.defaultValues(Ul))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(Rl.defaultValues($l))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}Rl.CLASS_NAME="RSAESOAEPParams";const Kl="keyInfo",Jl="entityUInfo",_l="suppPubInfo",Fl=[Kl,Jl,_l];class Ml extends f{constructor(e={}){super(),this.keyInfo=n.H$(e,Kl,Ml.defaultValues(Kl)),Jl in e&&(this.entityUInfo=n.H$(e,Jl,Ml.defaultValues(Jl))),this.suppPubInfo=n.H$(e,_l,Ml.defaultValues(_l)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Kl:return new K;case Jl:case _l:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Kl:case Jl:case _l:return t.isEqual(Ml.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.keyInfo||{}),new r.FC({name:t.entityUInfo||u,idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new r.fi]}),new r.FC({name:t.suppPubInfo||u,idBlock:{tagClass:3,tagNumber:2},value:[new r.fi]})]})}fromSchema(e){n.ze(e,Fl);const t=r.eN(e,e,Ml.schema({names:{keyInfo:{names:{blockName:Kl}},entityUInfo:Jl,suppPubInfo:_l}}));m.assertSchema(t,this.className),this.keyInfo=new K({schema:t.result.keyInfo}),Jl in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){const e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new r.T9({value:e})}toJSON(){const e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}}Ml.CLASS_NAME="ECCCMSSharedInfo";const jl="version",ql="originatorInfo",zl="recipientInfos",Wl="encryptedContentInfo",Gl="unprotectedAttrs",Zl=[jl,ql,zl,Wl,Gl],Yl={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},Ql={"P-256":256,"P-384":384,"P-521":528};class Xl extends f{constructor(e={}){super(),this.version=n.H$(e,jl,Xl.defaultValues(jl)),ql in e&&(this.originatorInfo=n.H$(e,ql,Xl.defaultValues(ql))),this.recipientInfos=n.H$(e,zl,Xl.defaultValues(zl)),this.encryptedContentInfo=n.H$(e,Wl,Xl.defaultValues(Wl)),Gl in e&&(this.unprotectedAttrs=n.H$(e,Gl,Xl.defaultValues(Gl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jl:return 0;case ql:return new oo;case zl:return[];case Wl:return new zs;case Gl:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case jl:return t===Xl.defaultValues(e);case ql:return 0===t.certs.certificates.length&&0===t.crls.crls.length;case zl:case Gl:return 0===t.length;case Wl:return zs.compareWithDefault("contentType",t.contentType)&&zs.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&zs.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||u}),new r.FC({name:t.originatorInfo||u,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:oo.schema().valueBlock.value}),new r.l4({value:[new r.ZD({name:t.recipientInfos||u,value:Tl.schema()})]}),zs.schema(t.encryptedContentInfo||{}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.ZD({name:t.unprotectedAttrs||u,value:z.schema()})]})]})}fromSchema(e){n.ze(e,Zl);const t=r.eN(e,e,Xl.schema({names:{version:jl,originatorInfo:ql,recipientInfos:zl,encryptedContentInfo:{names:{blockName:Wl}},unprotectedAttrs:Gl}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,ql in t.result&&(this.originatorInfo=new oo({schema:new r.T9({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,(e=>new Tl({schema:e}))),this.encryptedContentInfo=new zs({schema:t.result.encryptedContentInfo}),Gl in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,(e=>new z({schema:e}))))}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),this.originatorInfo&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new r.l4({value:Array.from(this.recipientInfos,(e=>e.toSchema()))})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={version:this.version,recipientInfos:Array.from(this.recipientInfos,(e=>e.toJSON())),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,(e=>e.toJSON()))),e}addRecipientByCertificate(e,t,s,a=pr(!0)){const n=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},Yl,t||{});if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))s=1;else{if(-1===e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);s=2}switch(s){case 1:{let t,s;if(!0===n.useOAEP){t=a.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");const e=a.getOIDByAlgorithm({name:n.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),i=new K({algorithmId:e,algorithmParams:new r.p2});s=new Rl({hashAlgorithm:i,maskGenAlgorithm:new K({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:i.toSchema()})}).toSchema()}else{if(t=a.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"}),t===u)throw new Error("Can not find OID for RSAES-PKCS1-v1_5");s=new r.p2}const i=new ko({version:0,rid:new ho({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new K({algorithmId:t,algorithmParams:s}),recipientCertificate:e});this.recipientInfos.push(new Tl({variant:1,value:i}))}break;case 2:{const t=new Mo({variant:1,value:new ho({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(t,n,{recipientCertificate:e},a)}break;default:throw new Error(`Unknown "variant" value: ${s}`)}return!0}addRecipientByPreDefinedData(e,t={},s,a=pr(!0)){if(c.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw new Error("Pre-defined data could have zero length");if(!t.keyIdentifier){const e=new ArrayBuffer(16),s=new Uint8Array(e);a.getRandomValues(s),t.keyIdentifier=e}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),void 0===t.iterationCount&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new r.p2),s){case 1:{const s=a.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),n=new vl({version:4,kekid:new ml({keyIdentifier:new r.fi({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new K({algorithmId:s,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new Tl({variant:3,value:n}))}break;case 2:{const s=a.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),n=new ArrayBuffer(64),i=new Uint8Array(n);a.getRandomValues(i);const o=a.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),l=new nr({salt:new r.fi({valueHex:n}),iterationCount:t.iterationCount,prf:new K({algorithmId:o,algorithmParams:new r.p2})}),u=a.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),c=new Bl({version:0,keyDerivationAlgorithm:new K({algorithmId:s,algorithmParams:l.toSchema()}),keyEncryptionAlgorithm:new K({algorithmId:u,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new Tl({variant:4,value:c}))}break;default:throw new Error(`Unknown value for "variant": ${s}`)}}addRecipientByKeyIdentifier(e,t,s,a=pr(!0)){const n=Object.assign({},Yl,s||{}),i=new Mo({variant:2,value:new Ko({subjectKeyIdentifier:new r.fi({valueHex:t})})});this._addKeyAgreeRecipientInfo(i,n,{recipientPublicKey:e},a)}_addKeyAgreeRecipientInfo(e,t,s,a=pr(!0)){const n=new Wo({rid:e}),i=a.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),o=new K({algorithmId:i}),l=a.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),u=new ArrayBuffer(64),c=new Uint8Array(u);a.getRandomValues(c);const h={version:3,ukm:new r.fi({valueHex:u}),keyEncryptionAlgorithm:new K({algorithmId:l,algorithmParams:o.toSchema()}),recipientEncryptedKeys:new Qo({encryptedKeys:[n]})},m=new ol(Object.assign(h,s));this.recipientInfos.push(new Tl({variant:2,value:m}))}async encrypt(e,t,s=pr(!0)){const a=new ArrayBuffer(16),n=new Uint8Array(a);s.getRandomValues(n);const i=new Uint8Array(t),o=s.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),l=await s.generateKey(e,!0,["encrypt"]),u=await s.encrypt({name:e.name,iv:n},l,i),c=await s.exportKey("raw",l);this.version=2,this.encryptedContentInfo=new zs({contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new K({algorithmId:o,algorithmParams:new r.fi({valueHex:a})}),encryptedContent:new r.fi({valueHex:u})});const h=async e=>{const t=this.recipientInfos[e].value;let a,n;if(t.recipientPublicKey)a=t.recipientPublicKey.algorithm.namedCurve,n=t.recipientPublicKey;else{if(!t.recipientCertificate)throw new Error("Unsupported RecipientInfo");{const i=t.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(i.constructor.blockName()!==r.rP.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);switch(i.valueBlock.toString()){case"1.2.840.10045.3.1.7":a="P-256";break;case"1.3.132.0.34":a="P-384";break;case"1.3.132.0.35":a="P-521";break;default:throw new Error(`Incorrect curve OID for index ${e}`)}n=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:a},usages:[]}},s)}}const i=Ql[a],o=await s.generateKey({name:"ECDH",namedCurve:a},!0,["deriveBits"]),u=await s.exportKey("spki",o.publicKey),c=await s.deriveBits({name:"ECDH",public:n},o.privateKey,i),h=new K({schema:t.keyEncryptionAlgorithm.algorithmParams}),m=s.getAlgorithmByOID(h.algorithmId,!0,"aesKWAlgorithm");let f=m.length;const d=new ArrayBuffer(4),g=new Uint8Array(d);for(let e=3;e>=0;e--)g[e]=f,f>>=8;const p=new Ml({keyInfo:new K({algorithmId:h.algorithmId}),entityUInfo:t.ukm,suppPubInfo:new r.fi({valueHex:d})}).toSchema().toBER(!1),w=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),y=await yr(w.kdf,c,m.length,p,s),v=await s.importKey("raw",y,{name:"AES-KW"},!0,["wrapKey"]),b=await s.wrapKey("raw",l,v,{name:"AES-KW"}),S=new xo;return S.variant=3,S.value=Vo.fromBER(u),t.originator=S,t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new r.fi({valueHex:b}),{ecdhPrivateKey:o.privateKey}},m=async e=>{const t=this.recipientInfos[e].value,a=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===a.name){const e=t.keyEncryptionAlgorithm.algorithmParams,r=new Rl({schema:e});if(a.hash=s.getAlgorithmByOID(r.hashAlgorithm.algorithmId),"name"in a.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`)}try{const e=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:a,usages:["encrypt","wrapKey"]}},s),n=await s.encrypt(e.algorithm,e,c);t.encryptedKey=new r.fi({valueHex:n})}catch{}},f=async e=>{const t=this.recipientInfos[e].value,a=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),n=await s.importKey("raw",new Uint8Array(t.preDefinedKEK),a,!0,["wrapKey"]),i=await s.wrapKey("raw",l,n,a);t.encryptedKey=new r.fi({valueHex:i})},d=async e=>{const t=this.recipientInfos[e].value;let a;if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{a=new nr({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const n=new Uint8Array(t.password),i=await s.importKey("raw",n,"PBKDF2",!1,["deriveKey"]),o=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm");let u="SHA-1";if(a.prf){u=s.getAlgorithmByOID(a.prf.algorithmId,!0,"prfAlgorithm").hash.name}const c=new Uint8Array(a.salt.valueBlock.valueHex),h=a.iterationCount,m=await s.deriveKey({name:"PBKDF2",hash:{name:u},salt:c,iterations:h},i,o,!0,["wrapKey"]),f=await s.wrapKey("raw",l,m,o);t.encryptedKey=new r.fi({valueHex:f})},g=[];for(let e=0;e<this.recipientInfos.length;e++)switch(this.recipientInfos[e].variant){case 1:g.push(await m(e));break;case 2:g.push(await h(e));break;case 3:g.push(await f(e));break;case 4:g.push(await d(e));break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}return g}async decrypt(e,t,s=pr(!0)){const a=t||{};if(e+1>this.recipientInfos.length)throw new Error('Maximum value for "index" is: '+(this.recipientInfos.length-1));const n=async e=>{const t=this.recipientInfos[e].value;let n,i,o;const l=t.originator;if(a.recipientCertificate){const t=a.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(t.constructor.blockName()!==r.rP.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);n=t.valueBlock.toString()}else{if(!l.value.algorithm.algorithmParams)throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');{const t=l.value.algorithm.algorithmParams;if(t.constructor.blockName()!==r.rP.blockName())throw new Error(`Incorrect originator for index ${e}`);n=t.valueBlock.toString()}}if(!a.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(n){case"1.2.840.10045.3.1.7":i="P-256",o=256;break;case"1.3.132.0.34":i="P-384",o=384;break;case"1.3.132.0.35":i="P-521",o=528;break;default:throw new Error(`Incorrect curve OID for index ${e}`)}const u=await s.importKey("pkcs8",a.recipientPrivateKey,{name:"ECDH",namedCurve:i},!0,["deriveBits"]);"algorithmParams"in l.value.algorithm==!1&&(l.value.algorithm.algorithmParams=new r.rP({value:n}));const c=l.value.toSchema().toBER(!1),h=await s.importKey("spki",c,{name:"ECDH",namedCurve:i},!0,[]),m=await s.deriveBits({name:"ECDH",public:h},u,o);async function f(e){e=e||!1;const a=new K({schema:t.keyEncryptionAlgorithm.algorithmParams}),n=s.getAlgorithmByOID(a.algorithmId,!0,"kwAlgorithm");let i=n.length;const o=new ArrayBuffer(4),l=new Uint8Array(o);for(let e=3;e>=0;e--)l[e]=i,i>>=8;const u={algorithmId:a.algorithmId};e&&(u.algorithmParams=new r.p2);const c=new Ml({keyInfo:new K(u),entityUInfo:t.ukm,suppPubInfo:new r.fi({valueHex:o})}).toSchema().toBER(!1),h=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!h.name)throw new Error(`Incorrect OID for key encryption algorithm: ${t.keyEncryptionAlgorithm.algorithmId}`);return yr(h.kdf,m,n.length,c,s)}const d=await f(),g=async e=>s.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),p=await g(d),w=async e=>{const r=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,a=s.getAlgorithmByOID(r,!0,"contentEncryptionAlgorithm");return s.unwrapKey("raw",t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,e,{name:"AES-KW"},a,!0,["decrypt"])};try{return await w(p)}catch{const e=await f(!0);return w(await g(e))}},i=async e=>{const t=this.recipientInfos[e].value;if(!a.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');const r=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===r.name){const e=t.keyEncryptionAlgorithm.algorithmParams,a=new Rl({schema:e});if(r.hash=s.getAlgorithmByOID(a.hashAlgorithm.algorithmId),"name"in r.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${a.hashAlgorithm.algorithmId}`)}const n=await s.importKey("pkcs8",a.recipientPrivateKey,r,!0,["decrypt"]),i=await s.decrypt(n.algorithm,n,t.encryptedKey.valueBlock.valueHexView),o=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,l=s.getAlgorithmByOID(o,!0,"contentEncryptionAlgorithm");if("name"in l==!1)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${o}`);return s.importKey("raw",i,l,!0,["decrypt"])},o=async e=>{const t=this.recipientInfos[e].value;if(!a.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');const r=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),n=await s.importKey("raw",a.preDefinedData,r,!0,["unwrapKey"]),i=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,o=s.getAlgorithmByOID(i,!0,"contentEncryptionAlgorithm");if(!o.name)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${i}`);return s.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,n,r,o,!0,["decrypt"])},l=async e=>{const t=this.recipientInfos[e].value;let r;if(!a.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{r=new nr({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const n=await s.importKey("raw",a.preDefinedData,"PBKDF2",!1,["deriveKey"]),i=s.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),o=r.prf?s.getAlgorithmByOID(r.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",l=new Uint8Array(r.salt.valueBlock.valueHex),u=r.iterationCount,c=await s.deriveKey({name:"PBKDF2",hash:{name:o},salt:l,iterations:u},n,i,!0,["unwrapKey"]),h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=s.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm");return s.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,c,i,m,!0,["decrypt"])};let u;switch(this.recipientInfos[e].variant){case 1:u=await i(e);break;case 2:u=await n(e);break;case 3:u=await o(e);break;case 4:u=await l(e);break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}const c=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,h=s.getAlgorithmByOID(c,!0,"contentEncryptionAlgorithm"),m=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,f=new Uint8Array(m);if(!this.encryptedContentInfo.encryptedContent)throw new Error("Required property `encryptedContent` is empty");const d=this.encryptedContentInfo.getEncryptedContent();return s.decrypt({name:h.name,iv:f},u,d)}}Xl.CLASS_NAME="EnvelopedData";const eu="safeContents",tu="parsedValue",su="contentInfos";class ru extends f{constructor(e={}){super(),this.safeContents=n.H$(e,eu,ru.defaultValues(eu)),tu in e&&(this.parsedValue=n.H$(e,tu,ru.defaultValues(tu))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eu:return[];case tu:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case eu:return 0===t.length;case tu:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.ZD({name:t.contentInfos||u,value:Xa.schema()})]})}fromSchema(e){n.ze(e,[su]);const t=r.eN(e,e,ru.schema({names:{contentInfos:su}}));m.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,(e=>new Xa({schema:e})))}toSchema(){return new r.T9({value:Array.from(this.safeContents,(e=>e.toSchema()))})}toJSON(){return{safeContents:Array.from(this.safeContents,(e=>e.toJSON()))}}async parseInternalValues(e,t=pr(!0)){if(h.assert(e,eu),c.assert(e.safeContents,eu,"Array"),e.safeContents.length!==this.safeContents.length)throw new c('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');this.parsedValue={safeContents:[]};for(const[s,a]of this.safeContents.entries()){const n=e.safeContents[s],i=`parameters.safeContents[${s}]`;switch(a.contentType){case pe:{c.assert(a.content,"this.safeContents[j].content",r.fi);const e=a.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:_i.fromBER(e)})}break;case ye:{const e=new Xl({schema:a.content});h.assert(i,n,"recipientCertificate","recipientKey");const s=n,r=s.recipientCertificate,o=s.recipientKey,l=await e.decrypt(0,{recipientCertificate:r,recipientPrivateKey:o},t);this.parsedValue.safeContents.push({privacyMode:2,value:_i.fromBER(l)})}break;case ve:{const e=new Ci({schema:a.content});h.assert(i,n,"password");const s=n.password,r=await e.decrypt({password:s},t);this.parsedValue.safeContents.push({privacyMode:1,value:_i.fromBER(r)})}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${a.contentType}`)}}}async makeInternalValues(e,t=pr(!0)){if(!this.parsedValue)throw new Error('Please run "parseValues" first or add "parsedValue" manually');if(c.assert(this.parsedValue,"this.parsedValue","object"),c.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),c.assert(e,"parameters","object"),h.assert(e,"safeContents"),c.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new c('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');this.safeContents=[];for(const[s,a]of this.parsedValue.safeContents.entries())switch(h.assert("content",a,"privacyMode","value"),c.assert(a.value,"content.value",_i),a.privacyMode){case 0:{const e=a.value.toSchema().toBER(!1);this.safeContents.push(new Xa({contentType:"1.2.840.113549.1.7.1",content:new r.fi({valueHex:e})}))}break;case 1:{const t=new Ci,r=e.safeContents[s];r.contentToEncrypt=a.value.toSchema().toBER(!1),await t.encrypt(r),this.safeContents.push(new Xa({contentType:"1.2.840.113549.1.7.6",content:t.toSchema()}))}break;case 2:{const r=new Xl,n=a.value.toSchema().toBER(!1),i=e.safeContents[s];switch(h.assert(`parameters.safeContents[${s}]`,i,"encryptingCertificate","encryptionAlgorithm"),!0){case"aes-cbc"===i.encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===i.encryptionAlgorithm.name.toLowerCase():break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${i.encryptionAlgorithm}`)}switch(!0){case 128===i.encryptionAlgorithm.length:case 192===i.encryptionAlgorithm.length:case 256===i.encryptionAlgorithm.length:break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${i.encryptionAlgorithm.length}`)}const o=i.encryptionAlgorithm;r.addRecipientByCertificate(i.encryptingCertificate,{},void 0,t),await r.encrypt(o,n,t),this.safeContents.push(new Xa({contentType:"1.2.840.113549.1.7.3",content:r.toSchema()}))}break;default:throw new Error(`Incorrect value for "content.privacyMode": ${a.privacyMode}`)}return this}}ru.CLASS_NAME="AuthenticatedSafe";const au="hashAlgorithm",nu="issuerNameHash",iu="issuerKeyHash",ou="serialNumber",lu=[au,nu,iu,ou];class uu extends f{constructor(e={}){super(),this.hashAlgorithm=n.H$(e,au,uu.defaultValues(au)),this.issuerNameHash=n.H$(e,nu,uu.defaultValues(nu)),this.issuerKeyHash=n.H$(e,iu,uu.defaultValues(iu)),this.serialNumber=n.H$(e,ou,uu.defaultValues(ou)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,s=pr(!0)){const r=new uu;return await r.createForCertificate(e,t,s),r}static defaultValues(e){switch(e){case au:return new K;case nu:case iu:return new r.fi;case ou:return new r.z8;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case au:return t.algorithmId===u&&"algorithmParams"in t==!1;case nu:case iu:case ou:return t.isEqual(uu.defaultValues(ou));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||u}}),new r.fi({name:t.issuerNameHash||u}),new r.fi({name:t.issuerKeyHash||u}),new r.z8({name:t.serialNumber||u})]})}fromSchema(e){n.ze(e,lu);const t=r.eN(e,e,uu.schema({names:{hashAlgorithm:au,issuerNameHash:nu,issuerKeyHash:iu,serialNumber:ou}}));m.assertSchema(t,this.className),this.hashAlgorithm=new K({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new r.T9({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return this.hashAlgorithm.algorithmId===e.hashAlgorithm.algorithmId&&(!!a.vJ.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)&&(!!a.vJ.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)&&!!this.serialNumber.isEqual(e.serialNumber)))}async createForCertificate(e,t,s=pr(!0)){h.assert(t,au,"issuerCertificate");const a=s.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new K({algorithmId:a,algorithmParams:new r.p2});const n=t.issuerCertificate;this.serialNumber=e.serialNumber;const i=await s.digest({name:t.hashAlgorithm},n.subject.toSchema().toBER(!1));this.issuerNameHash=new r.fi({valueHex:i});const o=n.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,l=await s.digest({name:t.hashAlgorithm},o);this.issuerKeyHash=new r.fi({valueHex:l})}}uu.CLASS_NAME="CertID";const cu="certID",hu="certStatus",mu="thisUpdate",fu="nextUpdate",du="singleExtensions",gu=[cu,hu,mu,fu,du];class pu extends f{constructor(e={}){super(),this.certID=n.H$(e,cu,pu.defaultValues(cu)),this.certStatus=n.H$(e,hu,pu.defaultValues(hu)),this.thisUpdate=n.H$(e,mu,pu.defaultValues(mu)),fu in e&&(this.nextUpdate=n.H$(e,fu,pu.defaultValues(fu))),du in e&&(this.singleExtensions=n.H$(e,du,pu.defaultValues(du))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cu:return new uu;case hu:return{};case mu:case fu:return new Date(0,0,0);case du:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cu:return uu.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&uu.compareWithDefault("issuerNameHash",t.issuerNameHash)&&uu.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&uu.compareWithDefault("serialNumber",t.serialNumber);case hu:return 0===Object.keys(t).length;case mu:case fu:return t===pu.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[uu.schema(t.certID||{}),new r.Lv({value:[new r.WV({name:t.certStatus||u,idBlock:{tagClass:3,tagNumber:0}}),new r.FC({name:t.certStatus||u,idBlock:{tagClass:3,tagNumber:1},value:[new r.Yw,new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.WC]})]}),new r.WV({name:t.certStatus||u,idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new r.Yw({name:t.thisUpdate||u}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.Yw({name:t.nextUpdate||u})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Gr.schema(t.singleExtensions||{})]})]})}fromSchema(e){n.ze(e,gu);const t=r.eN(e,e,pu.schema({names:{certID:{names:{blockName:cu}},certStatus:hu,thisUpdate:mu,nextUpdate:fu,singleExtensions:{names:{blockName:du}}}}));m.assertSchema(t,this.className),this.certID=new uu({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),fu in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),du in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,(e=>new qr({schema:e}))))}toSchema(){const e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new r.Yw({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.Yw({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new r.T9({value:Array.from(this.singleExtensions,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,(e=>e.toJSON()))),e}}pu.CLASS_NAME="SingleResponse";const wu="tbs",yu="version",vu="responderID",bu="producedAt",Su="responses",Au="responseExtensions",ku="ResponseData",Nu="ResponseData.version",Cu="ResponseData.responderID",Bu="ResponseData.producedAt",Vu="ResponseData.responses",Iu="ResponseData.responseExtensions",Eu=[ku,Nu,Cu,Bu,Vu,Iu];class Hu extends f{constructor(e={}){super(),this.tbsView=new Uint8Array(n.H$(e,wu,Hu.defaultValues(wu))),yu in e&&(this.version=n.H$(e,yu,Hu.defaultValues(yu))),this.responderID=n.H$(e,vu,Hu.defaultValues(vu)),this.producedAt=n.H$(e,bu,Hu.defaultValues(bu)),this.responses=n.H$(e,Su,Hu.defaultValues(Su)),Au in e&&(this.responseExtensions=n.H$(e,Au,Hu.defaultValues(Au))),e.schema&&this.fromSchema(e.schema)}get tbs(){return a.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case yu:return 0;case wu:return l;case vu:return{};case bu:return new Date(0,0,0);case Su:case Au:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case wu:return 0===t.byteLength;case vu:return 0===Object.keys(t).length;case bu:return t===Hu.defaultValues(e);case Su:case Au:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||ku,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({name:t.version||Nu})]}),new r.Lv({value:[new r.FC({name:t.responderID||Cu,idBlock:{tagClass:3,tagNumber:1},value:[b.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new r.FC({name:t.responderID||Cu,idBlock:{tagClass:3,tagNumber:2},value:[new r.fi({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new r.Yw({name:t.producedAt||Bu}),new r.T9({value:[new r.ZD({name:Vu,value:pu.schema(t.response||{})})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Gr.schema(t.extensions||{names:{blockName:Iu}})]})]})}fromSchema(e){n.ze(e,Eu);const t=r.eN(e,e,Hu.schema());m.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,Nu in t.result&&(this.version=t.result[Nu].valueBlock.valueDec),1===t.result[Cu].idBlock.tagNumber?this.responderID=new b({schema:t.result[Cu].valueBlock.value[0]}):this.responderID=t.result[Cu].valueBlock.value[0],this.producedAt=t.result[Bu].toDate(),this.responses=Array.from(t.result[Vu],(e=>new pu({schema:e}))),Iu in t.result&&(this.responseExtensions=Array.from(t.result[Iu].valueBlock.value,(e=>new qr({schema:e}))))}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return Hu.schema();const e=r.sc(this.tbsView);m.assert(e,"TBS Response Data"),t=e.result}else{const e=[];yu in this&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({value:this.version})]})),this.responderID instanceof b?e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new r.Yw({valueDate:this.producedAt})),e.push(new r.T9({value:Array.from(this.responses,(e=>e.toSchema()))})),this.responseExtensions&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[new r.T9({value:Array.from(this.responseExtensions,(e=>e.toSchema()))})]})),t=new r.T9({value:e})}return t}toJSON(){const e={};return yu in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,(e=>e.toJSON()))),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,(e=>e.toJSON()))),e}}Hu.CLASS_NAME="ResponseData";const xu="trustedCerts",Du="certs",Ou="crls",Tu="ocsps",Pu="checkDate",Uu="findOrigin",$u="findIssuer";class Lu{constructor(e={}){this.trustedCerts=n.H$(e,xu,this.defaultValues(xu)),this.certs=n.H$(e,Du,this.defaultValues(Du)),this.crls=n.H$(e,Ou,this.defaultValues(Ou)),this.ocsps=n.H$(e,Tu,this.defaultValues(Tu)),this.checkDate=n.H$(e,Pu,this.defaultValues(Pu)),this.findOrigin=n.H$(e,Uu,this.defaultValues(Uu)),this.findIssuer=n.H$(e,$u,this.defaultValues($u))}static defaultFindOrigin(e,t){0===e.tbsView.byteLength&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER()));for(const s of t.certs)if(0===s.tbsView.byteLength&&(s.tbsView=new Uint8Array(s.encodeTBS().toBER())),a.vJ.isEqual(e.tbsView,s.tbsView))return"Intermediate Certificates";for(const s of t.trustedCerts)if(0===s.tbsView.byteLength&&(s.tbsView=new Uint8Array(s.encodeTBS().toBER())),a.vJ.isEqual(e.tbsView,s.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,s=pr(!0)){const r=[];let n=null,i=null,o=null;if(e.subject.isEqual(e.issuer))try{if(await e.verify(void 0,s))return[e]}catch(e){}if(e.extensions)for(const t of e.extensions)if(t.extnID===me&&t.parsedValue instanceof Ee){t.parsedValue.keyIdentifier?n=t.parsedValue.keyIdentifier:(t.parsedValue.authorityCertIssuer&&(i=t.parsedValue.authorityCertIssuer),t.parsedValue.authorityCertSerialNumber&&(o=t.parsedValue.authorityCertSerialNumber));break}function l(t){if(null!==n&&t.extensions){let e=!1;for(const s of t.extensions)if("2.5.29.14"===s.extnID&&s.parsedValue){e=!0,a.vJ.isEqual(s.parsedValue.valueBlock.valueHex,n.valueBlock.valueHexView)&&r.push(t);break}if(e)return}let s=!1;null!==o&&(s=t.serialNumber.isEqual(o)),null!==i?t.subject.isEqual(i)&&s&&r.push(t):e.issuer.isEqual(t.subject)&&r.push(t)}for(const e of t.trustedCerts)l(e);for(const e of t.certs)l(e);for(let t=0;t<r.length;t++)try{!1===await e.verify(r[t],s)&&r.splice(t,1)}catch(e){r.splice(t,1)}return r}defaultValues(e){switch(e){case xu:case Du:case Ou:case Tu:return[];case Pu:return new Date;case Uu:return Lu.defaultFindOrigin;case $u:return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=pr(!0)){const s=[],r=async e=>{const t=[];function s(e){let t=!0;for(let s=0;s<e.length;s++){for(let r=0;r<e.length;r++)if(r!==s&&e[s]===e[r]){t=!1;break}if(!t)break}return t}const n=await this.findIssuer(e,this);if(0===n.length)throw new Error("No valid certificate paths found");for(let i=0;i<n.length;i++){if(a.vJ.isEqual(n[i].tbsView,e.tbsView)){t.push([n[i]]);continue}const o=await r(n[i]);for(let e=0;e<o.length;e++){const r=o[e].slice();r.splice(0,0,n[i]),s(r)?t.push(r):t.push(o[e])}}return t},n=async e=>{const r=[],a=[],n=[];if(r.push(...s.filter((t=>e.issuer.isEqual(t.subject)))),0===r.length)return{status:1,statusMessage:"No certificate's issuers"};if(a.push(...this.crls.filter((t=>t.issuer.isEqual(e.issuer)))),0===a.length)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<a.length;e++){const s=a[e];if(!(s.nextUpdate&&s.nextUpdate.value<this.checkDate))for(let s=0;s<r.length;s++)try{if(await a[e].verify({issuerCertificate:r[s]},t)){n.push({crl:a[e],certificate:r[s]});break}}catch(e){}}return n.length?{status:0,statusMessage:u,result:n}:{status:3,statusMessage:"No valid CRLs found"}},i=async(e,s)=>{const r=t.getAlgorithmByOID(e.signatureAlgorithm.algorithmId);if(!r.name)return 1;if(!r.hash)return 1;for(let r=0;r<this.ocsps.length;r++){const a=this.ocsps[r],n=await a.getCertificateStatus(e,s,t);if(n.isForCertificate)return 0===n.status?0:1}return 2};async function o(e,t=!1){let s=!1,r=!1,a=!1,n=!1;if(e.extensions){for(let t=0;t<e.extensions.length;t++){const i=e.extensions[t];if(i.critical&&!i.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${i.extnID}`};if("2.5.29.15"===i.extnID){a=!0;const e=new Uint8Array(i.parsedValue.valueBlock.valueHex);4==(4&e[0])&&(r=!0),2==(2&e[0])&&(n=!0)}i.extnID===re&&"cA"in i.parsedValue&&!0===i.parsedValue.cA&&(s=!0)}if(!0===r&&!1===s)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(!0===a&&!0===s&&!1===r)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===s&&!0===a&&t&&!1===n)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===s?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:u}}s.push(...this.trustedCerts),s.push(...this.certs);for(let e=0;e<s.length;e++)for(let t=0;t<s.length;t++)if(e!==t&&a.vJ.isEqual(s[e].tbsView,s[t].tbsView)){s.splice(t,1),e=0;break}let l;const c=[s[s.length-1]];if(l=await r(s[s.length-1]),0===l.length)throw{result:!1,resultCode:60,resultMessage:"Unable to find certificate path"};for(let e=0;e<l.length;e++){let t=!1;for(let s=0;s<l[e].length;s++){const r=l[e][s];for(let e=0;e<this.trustedCerts.length;e++)if(a.vJ.isEqual(r.tbsView,this.trustedCerts[e].tbsView)){t=!0;break}if(t)break}t||(l.splice(e,1),e=0)}if(0===l.length)throw{result:!1,resultCode:97,resultMessage:"No valid certificate paths found"};let h=l[0].length,m=0;for(let e=0;e<l.length;e++)l[e].length<h&&(h=l[e].length,m=e);for(let e=0;e<l[m].length;e++)c.push(l[m][e]);if(l=await(async(t,s)=>{for(let e=0;e<t.length;e++)if(t[e].notBefore.value>s||t[e].notAfter.value<s)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(t.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let e=t.length-2;e>=0;e--)if(!1===t[e].issuer.isEqual(t[e].subject)&&!1===t[e].issuer.isEqual(t[e+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==this.crls.length||0!==this.ocsps.length)for(let s=0;s<t.length-1;s++){let r=2,a={status:0,statusMessage:u};if(0!==this.ocsps.length)switch(r=await i(t[s],t[s+1]),r){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==this.crls.length){if(a=await n(t[s]),0===a.status&&a.result)for(let e=0;e<a.result.length;e++){if(a.result[e].crl.isCertificateRevoked(t[s]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if(!1===(await o(a.result[e].certificate,!0)).result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(!1===e)throw{result:!1,resultCode:11,resultMessage:`No revocation values found for one of certificates: ${a.statusMessage}`}}else if(2===r)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(2===r&&2===a.status&&e){const e=t[s+1];let r=!1;if(e.extensions)for(const t of e.extensions)switch(t.extnID){case oe:case le:case de:r=!0}if(r)throw{result:!1,resultCode:11,resultMessage:`No revocation values found for one of certificates: ${a.statusMessage}`}}}for(const[e,s]of t.entries()){if(!e)continue;if(!(await o(s)).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}})(c,this.checkDate),!1===l.result)throw l;return c}async verify(e={},t=pr(!0)){function s(e,t){const s=d(e),r=d(t),a=s.split("."),n=r.split("."),i=a.length,o=n.length;if(0===i||0===o||i<o)return!1;for(let e=0;e<i;e++)if(0===a[e].length)return!1;for(let e=0;e<o;e++)if(0===n[e].length){if(0===e){if(1===o)return!1;continue}return!1}for(let e=0;e<o;e++)if(0!==n[o-1-e].length&&0!==a[i-1-e].localeCompare(n[o-1-e]))return!1;return!0}function r(e,t){const r=d(e),a=d(t),n=r.split("@"),i=a.split("@");if(0===n.length||0===i.length||n.length<i.length)return!1;if(1===i.length){if(s(n[1],i[0])){const e=n[1].split("."),t=i[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===r.localeCompare(a)}function a(e,t){let r=d(e);const a=d(t),n=r.split("/");if(a.split("/").length>1)return!1;if(n.length>1)for(let e=0;e<n.length;e++)if(n[e].length>0&&":"!==n[e].charAt(n[e].length-1)){r=n[e].split(":")[0];break}if(s(r,a)){const e=r.split("."),t=a.split(".");return 0===t[0].length||e.length===t.length}return!1}function n(e,t){const s=e.valueBlock.valueHexView,r=t.valueBlock.valueHexView;if(4===s.length&&8===r.length){for(let e=0;e<4;e++)if((s[e]^r[e])&r[e+4])return!1;return!0}if(16===s.length&&32===r.length){for(let e=0;e<16;e++)if((s[e]^r[e])&r[e+16])return!1;return!0}return!1}function i(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let s=!0,r=0;for(let a=0;a<t.typesAndValues.length;a++){let n=!1;for(let i=r;i<e.typesAndValues.length;i++)if(n=e.typesAndValues[i].isEqual(t.typesAndValues[a]),e.typesAndValues[i].type===t.typesAndValues[a].type&&(s=s&&n),!0===n){if(0===r||r===i){r=i+1;break}return!1}if(!1===n)return!1}return 0!==r&&s}try{if(0===this.certs.length)throw new Error("Empty certificate array");const o=e.passedWhenNotRevValues||!1,l=e.initialPolicySet||[ce],c=e.initialExplicitPolicy||!1,h=e.initialPolicyMappingInhibit||!1,m=e.initialInhibitPolicy||!1,f=e.initialPermittedSubtreesSet||[],d=e.initialExcludedSubtreesSet||[],g=e.initialRequiredNameForms||[];let p=c,w=h,y=m;const v=[!1,!1,!1];let b=0,S=0,A=0,k=f,N=d;const C=g;let B=1;this.certs=await this.sort(o,t);const V=[];V.push(ce);const I=[],E=new Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)E[e]=!0;I.push(E);const H=new Array(this.certs.length-1),x=new Array(this.certs.length-1);let D=p?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,B++){const t=this.certs[e];if(t.extensions){for(let s=0;s<t.extensions.length;s++){const r=t.extensions[s];if(r.extnID===ue){x[e]=r.parsedValue;for(let t=0;t<V.length;t++)if(V[t]===ce){delete I[t][e];break}for(let t=0;t<r.parsedValue.certificatePolicies.length;t++){let s=-1;const a=r.parsedValue.certificatePolicies[t].policyIdentifier;for(let e=0;e<V.length;e++)if(a===V[e]){s=e;break}if(-1===s){V.push(a);const t=new Array(this.certs.length-1);t[e]=!0,I.push(t)}else I[s][e]=!0}}if(r.extnID===he){if(w)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};H[e]=r.parsedValue}r.extnID===fe&&!1===p&&(0===r.parsedValue.requireExplicitPolicy?(p=!0,D=e):!1===v[0]?(v[0]=!0,b=r.parsedValue.requireExplicitPolicy):b=b>r.parsedValue.requireExplicitPolicy?r.parsedValue.requireExplicitPolicy:b,0===r.parsedValue.inhibitPolicyMapping?w=!0:!1===v[1]?(v[1]=!0,S=r.parsedValue.inhibitPolicyMapping+1):S=S>r.parsedValue.inhibitPolicyMapping+1?r.parsedValue.inhibitPolicyMapping+1:S),"2.5.29.54"===r.extnID&&!1===y&&(0===r.parsedValue.valueBlock.valueDec?y=!0:!1===v[2]?(v[2]=!0,A=r.parsedValue.valueBlock.valueDec):A=A>r.parsedValue.valueBlock.valueDec?r.parsedValue.valueBlock.valueDec:A)}if(!0===y){let t=-1;for(let e=0;e<V.length;e++)if(V[e]===ce){t=e;break}-1!==t&&delete I[0][e]}!1===p&&!0===v[0]&&(b--,0===b&&(p=!0,D=e,v[0]=!1)),!1===w&&!0===v[1]&&(S--,0===S&&(w=!0,v[1]=!1)),!1===y&&!0===v[2]&&(A--,0===A&&(y=!0,v[2]=!1))}}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==H[e+1])for(let t=0;t<H[e+1].mappings.length;t++){if(H[e+1].mappings[t].issuerDomainPolicy===ce||H[e+1].mappings[t].subjectDomainPolicy===ce)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let s=-1,r=-1;for(let a=0;a<V.length;a++)V[a]===H[e+1].mappings[t].issuerDomainPolicy&&(s=a),V[a]===H[e+1].mappings[t].subjectDomainPolicy&&(r=a);void 0!==I[s][e]&&delete I[s][e];for(let a=0;a<x[e].certificatePolicies.length;a++)if(H[e+1].mappings[t].subjectDomainPolicy===x[e].certificatePolicies[a].policyIdentifier&&-1!==s&&-1!==r)for(let t=0;t<=e;t++)void 0!==I[r][t]&&(I[s][t]=!0,delete I[r][t])}for(let e=0;e<V.length;e++)if(V[e]===ce)for(let t=0;t<D;t++)delete I[e][t];const O=[];for(let e=0;e<I.length;e++){let t=!0;for(let s=0;s<this.certs.length-1;s++){let r=!1;if(s<D&&V[e]===ce&&V.length>1){t=!1;break}if(void 0===I[e][s]){if(s>=D)for(let e=0;e<V.length;e++)if(V[e]===ce){!0===I[e][s]&&(r=!0);break}if(!r){t=!1;break}}}!0===t&&O.push(V[e])}let T=[];if(1===l.length&&l[0]===ce&&!1===p)T=l;else if(1===O.length&&O[0]===ce)T=l;else for(let e=0;e<O.length;e++)for(let t=0;t<l.length;t++)if(l[t]===O[e]||l[t]===ce){T.push(O[e]);break}const P={result:T.length>0,resultCode:0,resultMessage:T.length>0?u:'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:O,userConstrPolicies:T,explicitPolicyIndicator:p,policyMappings:H,certificatePath:this.certs};if(0===T.length)return P;if(!1===P.result)return P;B=1;for(let e=this.certs.length-2;e>=0;e--,B++){const t=this.certs[e];let o=[],l=[],u=[];if(t.extensions)for(let e=0;e<t.extensions.length;e++){const s=t.extensions[e];s.extnID===ie&&("permittedSubtrees"in s.parsedValue&&(l=l.concat(s.parsedValue.permittedSubtrees)),"excludedSubtrees"in s.parsedValue&&(u=u.concat(s.parsedValue.excludedSubtrees))),s.extnID===te&&(o=o.concat(s.parsedValue.altNames))}let c=C.length<=0;for(let e=0;e<C.length;e++)switch(C[e].base.type){case 4:if(C[e].base.value.typesAndValues.length!==t.subject.typesAndValues.length)continue;c=!0;for(let s=0;s<t.subject.typesAndValues.length;s++)if(t.subject.typesAndValues[s].type!==C[e].base.value.typesAndValues[s].type){c=!1;break}if(!0===c)break}if(!1===c)throw P.result=!1,P.resultCode=21,P.resultMessage="No necessary name form found",P;const h=[[],[],[],[],[]];for(let e=0;e<k.length;e++)switch(k[e].base.type){case 1:h[0].push(k[e]);break;case 2:h[1].push(k[e]);break;case 4:h[2].push(k[e]);break;case 6:h[3].push(k[e]);break;case 7:h[4].push(k[e])}for(let e=0;e<5;e++){let l=!1,u=!1;const c=h[e];for(let h=0;h<c.length;h++){switch(e){case 0:if(o.length>0)for(let e=0;e<o.length;e++)1===o[e].type&&(u=!0,l=l||r(o[e].value,c[h].base.value));else for(let e=0;e<t.subject.typesAndValues.length;e++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[e].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[e].type||(u=!0,l=l||r(t.subject.typesAndValues[e].value.valueBlock.value,c[h].base.value));break;case 1:if(o.length>0)for(let e=0;e<o.length;e++)2===o[e].type&&(u=!0,l=l||s(o[e].value,c[h].base.value));break;case 2:u=!0,l=i(t.subject,c[h].base.value);break;case 3:if(o.length>0)for(let e=0;e<o.length;e++)6===o[e].type&&(u=!0,l=l||a(o[e].value,c[h].base.value));break;case 4:if(o.length>0)for(let e=0;e<o.length;e++)7===o[e].type&&(u=!0,l=l||n(o[e].value,c[h].base.value))}if(l)break}if(!1===l&&c.length>0&&u)throw P.result=!1,P.resultCode=41,P.resultMessage='Failed to meet "permitted sub-trees" name constraint',P}let m=!1;for(let e=0;e<N.length;e++){switch(N[e].base.type){case 1:if(o.length>=0)for(let t=0;t<o.length;t++)1===o[t].type&&(m=m||r(o[t].value,N[e].base.value));else for(let s=0;s<t.subject.typesAndValues.length;s++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[s].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[s].type||(m=m||r(t.subject.typesAndValues[s].value.valueBlock.value,N[e].base.value));break;case 2:if(o.length>0)for(let t=0;t<o.length;t++)2===o[t].type&&(m=m||s(o[t].value,N[e].base.value));break;case 4:m=m||i(t.subject,N[e].base.value);break;case 6:if(o.length>0)for(let t=0;t<o.length;t++)6===o[t].type&&(m=m||a(o[t].value,N[e].base.value));break;case 7:if(o.length>0)for(let t=0;t<o.length;t++)7===o[t].type&&(m=m||n(o[t].value,N[e].base.value))}if(m)break}if(!0===m)throw P.result=!1,P.resultCode=42,P.resultMessage='Failed to meet "excluded sub-trees" name constraint',P;k=k.concat(l),N=N.concat(u)}return P}catch(e){if(e instanceof Object){if("resultMessage"in e)return e;if("message"in e)return{result:!1,resultCode:-1,resultMessage:e.message}}return{result:!1,resultCode:-1,resultMessage:e}}}}const Ru="tbsResponseData",Ku="signatureAlgorithm",Ju="signature",_u="certs",Fu="BasicOCSPResponse",Mu="BasicOCSPResponse.tbsResponseData",ju="BasicOCSPResponse.signatureAlgorithm",qu="BasicOCSPResponse.signature",zu="BasicOCSPResponse.certs",Wu=[Mu,ju,qu,zu];class Gu extends f{constructor(e={}){super(),this.tbsResponseData=n.H$(e,Ru,Gu.defaultValues(Ru)),this.signatureAlgorithm=n.H$(e,Ku,Gu.defaultValues(Ku)),this.signature=n.H$(e,Ju,Gu.defaultValues(Ju)),_u in e&&(this.certs=n.H$(e,_u,Gu.defaultValues(_u))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ru:return new Hu;case Ku:return new K;case Ju:return new r._K;case _u:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let e=Hu.compareWithDefault("tbs",t.tbs)&&Hu.compareWithDefault("responderID",t.responderID)&&Hu.compareWithDefault("producedAt",t.producedAt)&&Hu.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&Hu.compareWithDefault("responseExtensions",t.responseExtensions)),e}case Ku:return t.algorithmId===u&&"algorithmParams"in t==!1;case Ju:return t.isEqual(Gu.defaultValues(e));case _u:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||Fu,value:[Hu.schema(t.tbsResponseData||{names:{blockName:Mu}}),K.schema(t.signatureAlgorithm||{names:{blockName:ju}}),new r._K({name:t.signature||qu}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.T9({value:[new r.ZD({name:zu,value:Un.schema(t.certs||{})})]})]})]})}fromSchema(e){n.ze(e,Wu);const t=r.eN(e,e,Gu.schema());m.assertSchema(t,this.className),this.tbsResponseData=new Hu({schema:t.result["BasicOCSPResponse.tbsResponseData"]}),this.signatureAlgorithm=new K({schema:t.result["BasicOCSPResponse.signatureAlgorithm"]}),this.signature=t.result[qu],zu in t.result&&(this.certs=Array.from(t.result[zu],(e=>new Un({schema:e}))))}toSchema(){const e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.T9({value:Array.from(this.certs,(e=>e.toSchema()))})]})),new r.T9({value:e})}toJSON(){const e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,(e=>e.toJSON()))),e}async getCertificateStatus(e,t,s=pr(!0)){const r={isForCertificate:!1,status:2},a={},n=[];for(const r of this.tbsResponseData.responses){const i=s.getAlgorithmByOID(r.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!a[i.name]){a[i.name]=1;const r=new uu;n.push(r),await r.createForCertificate(e,{hashAlgorithm:i.name,issuerCertificate:t},s)}}for(const e of this.tbsResponseData.responses)for(const t of n)if(e.certID.isEqual(t)){r.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(r.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:r.status=0;break;case 2:r.status=2}}}catch(e){}return r}return r}async sign(e,t="SHA-1",s=pr(!0)){if(!e)throw new Error("Need to provide a private key for signing");const a=await s.getSignatureParameters(e,t),n=a.parameters.algorithm;if(!("name"in n))throw new Error("Empty algorithm");this.signatureAlgorithm=a.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());const i=await s.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:n});this.signature=new r._K({valueHex:i})}async verify(e={},t=pr(!0)){let s=null,a=-1;const i=e.trustedCerts||[];if(!this.certs)throw new Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof b:for(const[e,t]of this.certs.entries())if(t.subject.isEqual(this.tbsResponseData.responderID)){a=e;break}break;case this.tbsResponseData.responderID instanceof r.fi:for(const[e,s]of this.certs.entries()){const r=await t.digest({name:"sha-1"},s.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(n.dN(r,this.tbsResponseData.responderID.valueBlock.valueHex)){a=e;break}}break;default:throw new Error("Wrong value for responderID")}if(-1===a)throw new Error("Correct certificate was not found in OCSP response");s=this.certs[a];const o=[s];for(const e of this.certs){const t=await $n(e,s);t&&o.push(t)}const l=new Lu({certs:o,trustedCerts:i});if(!(await l.verify({},t)).result)throw new Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[a].subjectPublicKeyInfo,this.signatureAlgorithm)}}Gu.CLASS_NAME="BasicOCSPResponse";const Zu="tbs",Yu="version",Qu="subject",Xu="subjectPublicKeyInfo",ec="attributes",tc="signatureAlgorithm",sc="signatureValue",rc="CertificationRequestInfo",ac=`${rc}.version`,nc=`${rc}.subject`,ic=`${rc}.subjectPublicKeyInfo`,oc=`${rc}.attributes`,lc=[rc,ac,nc,ic,oc,tc,sc];function uc(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.CertificationRequestInfo||rc,value:[new r.z8({name:t.CertificationRequestInfoVersion||ac}),b.schema(t.subject||{names:{blockName:nc}}),ms.schema({names:{blockName:ic}}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({optional:!0,name:t.CertificationRequestInfoAttributes||oc,value:z.schema(t.attributes||{})})]})]})}class cc extends f{constructor(e={}){super(),this.tbsView=new Uint8Array(n.H$(e,Zu,cc.defaultValues(Zu))),this.version=n.H$(e,Yu,cc.defaultValues(Yu)),this.subject=n.H$(e,Qu,cc.defaultValues(Qu)),this.subjectPublicKeyInfo=n.H$(e,Xu,cc.defaultValues(Xu)),ec in e&&(this.attributes=n.H$(e,ec,cc.defaultValues(ec))),this.signatureAlgorithm=n.H$(e,tc,cc.defaultValues(tc)),this.signatureValue=n.H$(e,sc,cc.defaultValues(sc)),e.schema&&this.fromSchema(e.schema)}get tbs(){return a.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case Zu:return l;case Yu:return 0;case Qu:return new b;case Xu:return new ms;case ec:return[];case tc:return new K;case sc:return new r._K;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({value:[uc(t.certificationRequestInfo||{}),new r.T9({name:t.signatureAlgorithm||tc,value:[new r.rP,new r.IK({optional:!0})]}),new r._K({name:t.signatureValue||sc})]})}fromSchema(e){n.ze(e,lc);const t=r.eN(e,e,cc.schema());m.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[ac].valueBlock.valueDec,this.subject=new b({schema:t.result[nc]}),this.subjectPublicKeyInfo=new ms({schema:t.result[ic]}),oc in t.result&&(this.attributes=Array.from(t.result[oc],(e=>new z({schema:e})))),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new r.z8({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return ec in this&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],(e=>e.toSchema()))})),new r.T9({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return cc.schema();const e=r.sc(this.tbsView);m.assert(e,"PKCS#10 Certificate Request"),t=e.result}else t=this.encodeTBS();return new r.T9({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:a.ep.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return ec in this&&(e.attributes=Array.from(this.attributes||[],(e=>e.toJSON()))),e}async sign(e,t="SHA-1",s=pr(!0)){if(!e)throw new Error("Need to provide a private key for signing");const a=await s.getSignatureParameters(e,t),n=a.parameters;this.signatureAlgorithm=a.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await s.signWithPrivateKey(this.tbsView,e,n);this.signatureValue=new r._K({valueHex:i})}async verify(e=pr(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=pr(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}cc.CLASS_NAME="CertificationRequest";const hc="digestAlgorithm",mc="digest",fc=[hc,mc];class dc extends f{constructor(e={}){super(),this.digestAlgorithm=n.H$(e,hc,dc.defaultValues(hc)),this.digest=n.H$(e,mc,dc.defaultValues(mc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case hc:return new K;case mc:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case hc:return K.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case mc:return t.isEqual(dc.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.digestAlgorithm||{names:{blockName:hc}}),new r.fi({name:t.digest||mc})]})}fromSchema(e){n.ze(e,fc);const t=r.eN(e,e,dc.schema({names:{digestAlgorithm:{names:{blockName:hc}},digest:mc}}));m.assertSchema(t,this.className),this.digestAlgorithm=new K({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new r.T9({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}dc.CLASS_NAME="DigestInfo";const gc="eContentType",pc="eContent",wc=[gc,pc];class yc extends f{constructor(e={}){if(super(),this.eContentType=n.H$(e,gc,yc.defaultValues(gc)),pc in e&&(this.eContent=n.H$(e,pc,yc.defaultValues(pc)),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){const e=new r.fi({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const s=this.eContent.valueBlock.valueHexView.slice().buffer;let a=s.byteLength;for(;a>0;){const n=new Uint8Array(s,t,t+65536>s.byteLength?s.byteLength-t:65536),i=new ArrayBuffer(n.length),o=new Uint8Array(i);for(let e=0;e<o.length;e++)o[e]=n[e];e.valueBlock.value.push(new r.fi({valueHex:i})),a-=n.length,t+=n.length}this.eContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gc:return u;case pc:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case gc:return t===u;case pc:return 1===t.idBlock.tagClass&&4===t.idBlock.tagNumber&&t.isEqual(yc.defaultValues(pc));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.eContentType||u}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.IK({name:t.eContent||u})]})]})}fromSchema(e){n.ze(e,wc);const t=r.eN(e,e,yc.schema({names:{eContentType:gc,eContent:pc}}));m.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),pc in t.result&&(this.eContent=t.result.eContent)}toSchema(){const e=[];return e.push(new r.rP({value:this.eContentType})),this.eContent&&!1===yc.compareWithDefault(pc,this.eContent)&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new r.T9({value:e})}toJSON(){const e={eContentType:this.eContentType};return this.eContent&&!1===yc.compareWithDefault(pc,this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}yc.CLASS_NAME="EncapsulatedContentInfo";const vc="mac",bc="macSalt",Sc="iterations",Ac=[vc,bc,Sc];class kc extends f{constructor(e={}){super(),this.mac=n.H$(e,vc,kc.defaultValues(vc)),this.macSalt=n.H$(e,bc,kc.defaultValues(bc)),Sc in e&&(this.iterations=n.H$(e,Sc,kc.defaultValues(Sc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vc:return new dc;case bc:return new r.fi;case Sc:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case vc:return dc.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&dc.compareWithDefault("digest",t.digest);case bc:return t.isEqual(kc.defaultValues(e));case Sc:return t===kc.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,optional:t.optional||!0,value:[dc.schema(t.mac||{names:{blockName:vc}}),new r.fi({name:t.macSalt||bc}),new r.z8({optional:!0,name:t.iterations||Sc})]})}fromSchema(e){n.ze(e,Ac);const t=r.eN(e,e,kc.schema({names:{mac:{names:{blockName:vc}},macSalt:bc,iterations:Sc}}));m.assertSchema(t,this.className),this.mac=new dc({schema:t.result.mac}),this.macSalt=t.result.macSalt,Sc in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){const e=[this.mac.toSchema(),this.macSalt];return void 0!==this.iterations&&e.push(new r.z8({value:this.iterations})),new r.T9({value:e})}toJSON(){const e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return void 0!==this.iterations&&(e.iterations=this.iterations),e}}kc.CLASS_NAME="MacData";const Nc="hashAlgorithm",Cc="hashedMessage",Bc=[Nc,Cc];class Vc extends f{constructor(e={}){super(),this.hashAlgorithm=n.H$(e,Nc,Vc.defaultValues(Nc)),this.hashedMessage=n.H$(e,Cc,Vc.defaultValues(Cc)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,s=pr(!0)){const a=s.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),n=await s.digest(e,t);return new Vc({hashAlgorithm:new K({algorithmId:a,algorithmParams:new r.p2}),hashedMessage:new r.fi({valueHex:n})})}static defaultValues(e){switch(e){case Nc:return new K;case Cc:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Nc:return t.algorithmId===u&&"algorithmParams"in t==!1;case Cc:return 0===t.isEqual(Vc.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.hashAlgorithm||{}),new r.fi({name:t.hashedMessage||u})]})}fromSchema(e){n.ze(e,Bc);const t=r.eN(e,e,Vc.schema({names:{hashAlgorithm:{names:{blockName:Nc}},hashedMessage:Cc}}));m.assertSchema(t,this.className),this.hashAlgorithm=new K({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new r.T9({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}Vc.CLASS_NAME="MessageImprint";const Ic="reqCert",Ec="singleRequestExtensions",Hc=[Ic,Ec];class xc extends f{constructor(e={}){super(),this.reqCert=n.H$(e,Ic,xc.defaultValues(Ic)),Ec in e&&(this.singleRequestExtensions=n.H$(e,Ec,xc.defaultValues(Ec))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ic:return new uu;case Ec:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ic:return t.isEqual(xc.defaultValues(e));case Ec:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[uu.schema(t.reqCert||{}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[qr.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||u}})]})]})}fromSchema(e){n.ze(e,Hc);const t=r.eN(e,e,xc.schema({names:{reqCert:{names:{blockName:Ic}},extensions:{names:{blockName:Ec}}}}));m.assertSchema(t,this.className),this.reqCert=new uu({schema:t.result.reqCert}),Ec in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,(e=>new qr({schema:e}))))}toSchema(){const e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.T9({value:Array.from(this.singleRequestExtensions,(e=>e.toSchema()))})]})),new r.T9({value:e})}toJSON(){const e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,(e=>e.toJSON()))),e}}xc.CLASS_NAME="Request";const Dc="tbs",Oc="version",Tc="requestorName",Pc="requestList",Uc="requestExtensions",$c="TBSRequest",Lc="TBSRequest.version",Rc="TBSRequest.requestorName",Kc="TBSRequest.requests",Jc="TBSRequest.requestExtensions",_c=[$c,Lc,Rc,Kc,Jc];class Fc extends f{constructor(e={}){super(),this.tbsView=new Uint8Array(n.H$(e,Dc,Fc.defaultValues(Dc))),Oc in e&&(this.version=n.H$(e,Oc,Fc.defaultValues(Oc))),Tc in e&&(this.requestorName=n.H$(e,Tc,Fc.defaultValues(Tc))),this.requestList=n.H$(e,Pc,Fc.defaultValues(Pc)),Uc in e&&(this.requestExtensions=n.H$(e,Uc,Fc.defaultValues(Uc))),e.schema&&this.fromSchema(e.schema)}get tbs(){return a.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case Dc:return l;case Oc:return 0;case Tc:return new B;case Pc:case Uc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Dc:return 0===t.byteLength;case Oc:return t===Fc.defaultValues(e);case Tc:return t.type===B.defaultValues("type")&&0===Object.keys(t.value).length;case Pc:case Uc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||$c,value:[new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({name:t.TBSRequestVersion||Lc})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[B.schema(t.requestorName||{names:{blockName:Rc}})]}),new r.T9({name:t.requestList||"TBSRequest.requestList",value:[new r.ZD({name:t.requests||Kc,value:xc.schema(t.requestNames||{})})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[Gr.schema(t.extensions||{names:{blockName:t.requestExtensions||Jc}})]})]})}fromSchema(e){n.ze(e,_c);const t=r.eN(e,e,Fc.schema());m.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,Lc in t.result&&(this.version=t.result[Lc].valueBlock.valueDec),Rc in t.result&&(this.requestorName=new B({schema:t.result[Rc]})),this.requestList=Array.from(t.result[Kc],(e=>new xc({schema:e}))),Jc in t.result&&(this.requestExtensions=Array.from(t.result[Jc].valueBlock.value,(e=>new qr({schema:e}))))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return Fc.schema();const e=r.sc(this.tbsView);if(m.assert(e,"TBS Request"),!(e.result instanceof r.T9))throw new Error("ASN.1 result should be SEQUENCE");t=e.result}else{const e=[];void 0!==this.version&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[new r.z8({value:this.version})]})),this.requestorName&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),e.push(new r.T9({value:Array.from(this.requestList,(e=>e.toSchema()))})),this.requestExtensions&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:2},value:[new r.T9({value:Array.from(this.requestExtensions,(e=>e.toSchema()))})]})),t=new r.T9({value:e})}return t}toJSON(){const e={};return null!=this.version&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,(e=>e.toJSON())),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,(e=>e.toJSON()))),e}}Fc.CLASS_NAME="TBSRequest";const Mc="signatureAlgorithm",jc="signature",qc="certs";class zc extends f{constructor(e={}){super(),this.signatureAlgorithm=n.H$(e,Mc,zc.defaultValues(Mc)),this.signature=n.H$(e,jc,zc.defaultValues(jc)),qc in e&&(this.certs=n.H$(e,qc,zc.defaultValues(qc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mc:return new K;case jc:return new r._K;case qc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Mc:return t.algorithmId===u&&"algorithmParams"in t==!1;case jc:return t.isEqual(zc.defaultValues(e));case qc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[K.schema(t.signatureAlgorithm||{}),new r._K({name:t.signature||u}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.T9({value:[new r.ZD({name:t.certs||u,value:Un.schema({})})]})]})]})}fromSchema(e){n.ze(e,[Mc,jc,qc]);const t=r.eN(e,e,zc.schema({names:{signatureAlgorithm:{names:{blockName:Mc}},signature:jc,certs:qc}}));m.assertSchema(t,this.className),this.signatureAlgorithm=new K({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,qc in t.result&&(this.certs=Array.from(t.result.certs,(e=>new Un({schema:e}))))}toSchema(){const e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.T9({value:Array.from(this.certs,(e=>e.toSchema()))})]})),new r.T9({value:e})}toJSON(){const e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,(e=>e.toJSON()))),e}}zc.CLASS_NAME="Signature";const Wc="tbsRequest",Gc="optionalSignature",Zc=[Wc,Gc];class Yc extends f{constructor(e={}){super(),this.tbsRequest=n.H$(e,Wc,Yc.defaultValues(Wc)),Gc in e&&(this.optionalSignature=n.H$(e,Gc,Yc.defaultValues(Gc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wc:return new Fc;case Gc:return new zc;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Wc:return Fc.compareWithDefault("tbs",t.tbs)&&Fc.compareWithDefault("version",t.version)&&Fc.compareWithDefault("requestorName",t.requestorName)&&Fc.compareWithDefault("requestList",t.requestList)&&Fc.compareWithDefault("requestExtensions",t.requestExtensions);case Gc:return zc.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&zc.compareWithDefault("signature",t.signature)&&zc.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||"OCSPRequest",value:[Fc.schema(t.tbsRequest||{names:{blockName:Wc}}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[zc.schema(t.optionalSignature||{names:{blockName:Gc}})]})]})}fromSchema(e){n.ze(e,Zc);const t=r.eN(e,e,Yc.schema());m.assertSchema(t,this.className),this.tbsRequest=new Fc({schema:t.result.tbsRequest}),Gc in t.result&&(this.optionalSignature=new zc({schema:t.result.optionalSignature}))}toSchema(e=!1){const t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new r.T9({value:t})}toJSON(){const e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,s=pr(!0)){const r=new uu;await r.createForCertificate(e,t,s),this.tbsRequest.requestList.push(new xc({reqCert:r}))}async sign(e,t="SHA-1",s=pr(!0)){if(h.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw new Error('Need to create "optionalSignature" field before signing');const a=await s.getSignatureParameters(e,t),n=a.parameters;this.optionalSignature.signatureAlgorithm=a.signatureAlgorithm;const i=this.tbsRequest.toSchema(!0).toBER(!1),o=await s.signWithPrivateKey(i,e,n);this.optionalSignature.signature=new r._K({valueHex:o})}verify(){}}Yc.CLASS_NAME="OCSPRequest";const Qc="responseType",Xc="response",eh=[Qc,Xc];class th extends f{constructor(e={}){super(),this.responseType=n.H$(e,Qc,th.defaultValues(Qc)),this.response=n.H$(e,Xc,th.defaultValues(Xc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qc:return u;case Xc:return new r.fi;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Qc:return t===u;case Xc:return t.isEqual(th.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.rP({name:t.responseType||u}),new r.fi({name:t.response||u})]})}fromSchema(e){n.ze(e,eh);const t=r.eN(e,e,th.schema({names:{responseType:Qc,response:Xc}}));m.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new r.T9({value:[new r.rP({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}}th.CLASS_NAME="ResponseBytes";const sh="responseStatus",rh="responseBytes";class ah extends f{constructor(e={}){super(),this.responseStatus=n.H$(e,sh,ah.defaultValues(sh)),rh in e&&(this.responseBytes=n.H$(e,rh,ah.defaultValues(rh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sh:return new r.WC;case rh:return new th;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case sh:return t.isEqual(ah.defaultValues(e));case rh:return th.compareWithDefault("responseType",t.responseType)&&th.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||"OCSPResponse",value:[new r.WC({name:t.responseStatus||sh}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[th.schema(t.responseBytes||{names:{blockName:rh}})]})]})}fromSchema(e){n.ze(e,[sh,rh]);const t=r.eN(e,e,ah.schema());m.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,rh in t.result&&(this.responseBytes=new th({schema:t.result.responseBytes}))}toSchema(){const e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new r.T9({value:e})}toJSON(){const e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,s=pr(!0)){let a;const n={isForCertificate:!1,status:2};if(!this.responseBytes)return n;if(this.responseBytes.responseType!==Ne)return n;try{const e=r.sc(this.responseBytes.response.valueBlock.valueHexView);m.assert(e,"Basic OCSP response"),a=new Gu({schema:e.result})}catch(e){return n}return a.getCertificateStatus(e,t,s)}async sign(e,t,s=pr(!0)){var r;if(this.responseBytes&&this.responseBytes.responseType===Ne){return Gu.fromBER(this.responseBytes.response.valueBlock.valueHexView).sign(e,t,s)}throw new Error(`Unknown ResponseBytes type: ${(null===(r=this.responseBytes)||void 0===r?void 0:r.responseType)||"Unknown"}`)}async verify(e=null,t=pr(!0)){var s;if(rh in this==!1)throw new Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===Ne){const s=Gu.fromBER(this.responseBytes.response.valueBlock.valueHexView);return null!==e&&(s.certs||(s.certs=[]),s.certs.push(e)),s.verify({},t)}throw new Error(`Unknown ResponseBytes type: ${(null===(s=this.responseBytes)||void 0===s?void 0:s.responseType)||"Unknown"}`)}}ah.CLASS_NAME="OCSPResponse";const nh="type",ih="attributes",oh="encodedValue",lh=[ih];class uh extends f{constructor(e={}){super(),this.type=n.H$(e,nh,uh.defaultValues(nh)),this.attributes=n.H$(e,ih,uh.defaultValues(ih)),this.encodedValue=n.H$(e,oh,uh.defaultValues(oh)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nh:return-1;case ih:return[];case oh:return l;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nh:return t===uh.defaultValues(nh);case ih:return 0===t.length;case oh:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.FC({name:t.blockName||u,optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new r.ZD({name:t.attributes||u,value:z.schema()})]})}fromSchema(e){n.ze(e,lh);const t=r.eN(e,e,uh.schema({names:{tagNumber:this.type,attributes:ih}}));m.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=a.vJ.toArrayBuffer(t.result.valueBeforeDecodeView);if(new Uint8Array(this.encodedValue)[0]=49,ih in t.result!=!1)this.attributes=Array.from(t.result.attributes,(e=>new z({schema:e})));else if(0===this.type)throw new Error("Wrong structure of SignedUnsignedAttributes")}toSchema(){if(uh.compareWithDefault(nh,this.type)||uh.compareWithDefault(ih,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,(e=>e.toSchema()))})}toJSON(){if(uh.compareWithDefault(nh,this.type)||uh.compareWithDefault(ih,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,(e=>e.toJSON()))}}}uh.CLASS_NAME="SignedAndUnsignedAttributes";const ch="version",hh="sid",mh="digestAlgorithm",fh="signedAttrs",dh="signatureAlgorithm",gh="signature",ph="unsignedAttrs",wh="SignerInfo",yh="SignerInfo.version",vh="SignerInfo.sid",bh="SignerInfo.digestAlgorithm",Sh="SignerInfo.signedAttrs",Ah="SignerInfo.signatureAlgorithm",kh="SignerInfo.signature",Nh="SignerInfo.unsignedAttrs",Ch=[yh,vh,bh,Sh,Ah,kh,Nh];class Bh extends f{constructor(e={}){super(),this.version=n.H$(e,ch,Bh.defaultValues(ch)),this.sid=n.H$(e,hh,Bh.defaultValues(hh)),this.digestAlgorithm=n.H$(e,mh,Bh.defaultValues(mh)),fh in e&&(this.signedAttrs=n.H$(e,fh,Bh.defaultValues(fh))),this.signatureAlgorithm=n.H$(e,dh,Bh.defaultValues(dh)),this.signature=n.H$(e,gh,Bh.defaultValues(gh)),ph in e&&(this.unsignedAttrs=n.H$(e,ph,Bh.defaultValues(ph))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ch:return 0;case hh:return new r.IK;case mh:return new K;case fh:return new uh({type:0});case dh:return new K;case gh:return new r.fi;case ph:return new uh({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ch:return Bh.defaultValues(ch)===t;case hh:return t instanceof r.IK;case mh:return t instanceof K!=!1&&t.isEqual(Bh.defaultValues(mh));case fh:return uh.compareWithDefault("type",t.type)&&uh.compareWithDefault("attributes",t.attributes)&&uh.compareWithDefault("encodedValue",t.encodedValue);case dh:return t instanceof K!=!1&&t.isEqual(Bh.defaultValues(dh));case gh:case ph:return uh.compareWithDefault("type",t.type)&&uh.compareWithDefault("attributes",t.attributes)&&uh.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:wh,value:[new r.z8({name:t.version||yh}),new r.Lv({value:[ho.schema(t.sidSchema||{names:{blockName:vh}}),new r.Lv({value:[new r.FC({optional:!0,name:t.sid||vh,idBlock:{tagClass:3,tagNumber:0},value:[new r.fi]}),new r.WV({optional:!0,name:t.sid||vh,idBlock:{tagClass:3,tagNumber:0}})]})]}),K.schema(t.digestAlgorithm||{names:{blockName:bh}}),uh.schema(t.signedAttrs||{names:{blockName:Sh,tagNumber:0}}),K.schema(t.signatureAlgorithm||{names:{blockName:Ah}}),new r.fi({name:t.signature||kh}),uh.schema(t.unsignedAttrs||{names:{blockName:Nh,tagNumber:1}})]})}fromSchema(e){n.ze(e,Ch);const t=r.eN(e,e,Bh.schema());m.assertSchema(t,this.className),this.version=t.result[yh].valueBlock.valueDec;const s=t.result[vh];1===s.idBlock.tagClass?this.sid=new ho({schema:s}):this.sid=s,this.digestAlgorithm=new K({schema:t.result[bh]}),Sh in t.result&&(this.signedAttrs=new uh({type:0,schema:t.result[Sh]})),this.signatureAlgorithm=new K({schema:t.result[Ah]}),this.signature=t.result[kh],Nh in t.result&&(this.unsignedAttrs=new uh({type:1,schema:t.result[Nh]}))}toSchema(){if(Bh.compareWithDefault(hh,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e=[];return e.push(new r.z8({value:this.version})),this.sid instanceof ho?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&!1===Bh.compareWithDefault(fh,this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&!1===Bh.compareWithDefault(ph,this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new r.T9({value:e})}toJSON(){if(Bh.compareWithDefault(hh,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof r.IK||(e.sid=this.sid.toJSON()),this.signedAttrs&&!1===Bh.compareWithDefault(fh,this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&!1===Bh.compareWithDefault(ph,this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}Bh.CLASS_NAME="SignerInfo";const Vh="version",Ih="policy",Eh="messageImprint",Hh="serialNumber",xh="genTime",Dh="ordering",Oh="nonce",Th="accuracy",Ph="tsa",Uh="extensions",$h="TSTInfo",Lh="TSTInfo.version",Rh="TSTInfo.policy",Kh="TSTInfo.messageImprint",Jh="TSTInfo.serialNumber",_h="TSTInfo.genTime",Fh="TSTInfo.accuracy",Mh="TSTInfo.ordering",jh="TSTInfo.nonce",qh="TSTInfo.tsa",zh="TSTInfo.extensions",Wh=[Lh,Rh,Kh,Jh,_h,Fh,Mh,jh,qh,zh];class Gh extends f{constructor(e={}){super(),this.version=n.H$(e,Vh,Gh.defaultValues(Vh)),this.policy=n.H$(e,Ih,Gh.defaultValues(Ih)),this.messageImprint=n.H$(e,Eh,Gh.defaultValues(Eh)),this.serialNumber=n.H$(e,Hh,Gh.defaultValues(Hh)),this.genTime=n.H$(e,xh,Gh.defaultValues(xh)),Th in e&&(this.accuracy=n.H$(e,Th,Gh.defaultValues(Th))),Dh in e&&(this.ordering=n.H$(e,Dh,Gh.defaultValues(Dh))),Oh in e&&(this.nonce=n.H$(e,Oh,Gh.defaultValues(Oh))),Ph in e&&(this.tsa=n.H$(e,Ph,Gh.defaultValues(Ph))),Uh in e&&(this.extensions=n.H$(e,Uh,Gh.defaultValues(Uh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vh:return 0;case Ih:return u;case Eh:return new Vc;case Hh:return new r.z8;case xh:return new Date(0,0,0);case Th:return new T;case Dh:return!1;case Oh:return new r.z8;case Ph:return new B;case Uh:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Vh:case Ih:case xh:case Dh:return t===Gh.defaultValues(Dh);case Eh:return Vc.compareWithDefault(Nc,t.hashAlgorithm)&&Vc.compareWithDefault(Cc,t.hashedMessage);case Hh:case Oh:return t.isEqual(Gh.defaultValues(Oh));case Th:return T.compareWithDefault(x,t.seconds)&&T.compareWithDefault(D,t.millis)&&T.compareWithDefault(O,t.micros);case Ph:return B.compareWithDefault(S,t.type)&&B.compareWithDefault(A,t.value);case Uh:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||$h,value:[new r.z8({name:t.version||Lh}),new r.rP({name:t.policy||Rh}),Vc.schema(t.messageImprint||{names:{blockName:Kh}}),new r.z8({name:t.serialNumber||Jh}),new r.Yw({name:t.genTime||_h}),T.schema(t.accuracy||{names:{blockName:Fh}}),new r.ge({name:t.ordering||Mh,optional:!0}),new r.z8({name:t.nonce||jh,optional:!0}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[B.schema(t.tsa||{names:{blockName:qh}})]}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new r.ZD({name:t.extensions||zh,value:qr.schema(t.extension||{})})]})]})}fromSchema(e){n.ze(e,Wh);const t=r.eN(e,e,Gh.schema());m.assertSchema(t,this.className),this.version=t.result[Lh].valueBlock.valueDec,this.policy=t.result[Rh].valueBlock.toString(),this.messageImprint=new Vc({schema:t.result[Kh]}),this.serialNumber=t.result[Jh],this.genTime=t.result[_h].toDate(),Fh in t.result&&(this.accuracy=new T({schema:t.result[Fh]})),Mh in t.result&&(this.ordering=t.result[Mh].valueBlock.value),jh in t.result&&(this.nonce=t.result[jh]),qh in t.result&&(this.tsa=new B({schema:t.result[qh]})),zh in t.result&&(this.extensions=Array.from(t.result[zh],(e=>new qr({schema:e}))))}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),e.push(new r.rP({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new r.Yw({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),void 0!==this.ordering&&e.push(new r.ge({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),void 0!==this.ordering&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,(e=>e.toJSON()))),e}async verify(e,t=pr(!0)){if(!e.data)throw new Error('"data" is a mandatory attribute for TST_INFO verification');const s=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw new Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw new Error("Generation time for TSTInfo object is more than notAfter value");const r=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),n=await t.digest(r.name,new Uint8Array(s));return a.vJ.isEqual(n,this.messageImprint.hashedMessage.valueBlock.valueHexView)}}Gh.CLASS_NAME="TSTInfo";const Zh="version",Yh="digestAlgorithms",Qh="encapContentInfo",Xh="certificates",em="crls",tm="signerInfos",sm="ocsps",rm="SignedData",am="SignedData.version",nm="SignedData.digestAlgorithms",im="SignedData.encapContentInfo",om="SignedData.certificates",lm="SignedData.crls",um="SignedData.signerInfos",cm=[am,nm,im,om,lm,um];class hm extends Error{constructor({message:e,code:t=0,date:s=new Date,signatureVerified:r=null,signerCertificate:a=null,signerCertificateVerified:n=null,timestampSerial:i=null}){super(e),this.name="SignedDataVerifyError",this.date=s,this.code=t,this.timestampSerial=i,this.signatureVerified=r,this.signerCertificate=a,this.signerCertificateVerified=n}}class mm extends f{constructor(e={}){super(),this.version=n.H$(e,Zh,mm.defaultValues(Zh)),this.digestAlgorithms=n.H$(e,Yh,mm.defaultValues(Yh)),this.encapContentInfo=n.H$(e,Qh,mm.defaultValues(Qh)),Xh in e&&(this.certificates=n.H$(e,Xh,mm.defaultValues(Xh))),em in e&&(this.crls=n.H$(e,em,mm.defaultValues(em))),sm in e&&(this.ocsps=n.H$(e,sm,mm.defaultValues(sm))),this.signerInfos=n.H$(e,tm,mm.defaultValues(tm)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zh:return 0;case Yh:return[];case Qh:return new yc;case Xh:case em:case sm:case tm:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Zh:return t===mm.defaultValues(Zh);case Qh:return yc.compareWithDefault("eContentType",t.eContentType)&&yc.compareWithDefault("eContent",t.eContent);case Yh:case Xh:case em:case sm:case tm:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return void 0===t.optional&&(t.optional=!1),new r.T9({name:t.blockName||rm,optional:t.optional,value:[new r.z8({name:t.version||am}),new r.l4({value:[new r.ZD({name:t.digestAlgorithms||nm,value:K.schema()})]}),yc.schema(t.encapContentInfo||{names:{blockName:im}}),new r.FC({name:t.certificates||om,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Gi.schema().valueBlock.value}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:ro.schema(t.crls||{names:{crls:lm}}).valueBlock.value}),new r.l4({value:[new r.ZD({name:t.signerInfos||um,value:Bh.schema()})]})]})}fromSchema(e){n.ze(e,cm);const t=r.eN(e,e,mm.schema());if(m.assertSchema(t,this.className),this.version=t.result[am].valueBlock.valueDec,nm in t.result&&(this.digestAlgorithms=Array.from(t.result[nm],(e=>new K({schema:e})))),this.encapContentInfo=new yc({schema:t.result["SignedData.encapContentInfo"]}),om in t.result){const e=new Gi({schema:new r.l4({value:t.result[om].valueBlock.value})});this.certificates=e.certificates.slice(0)}lm in t.result&&(this.crls=Array.from(t.result[lm],(e=>1===e.idBlock.tagClass?new gi({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new Xi({schema:e}))))),um in t.result&&(this.signerInfos=Array.from(t.result[um],(e=>new Bh({schema:e}))))}toSchema(e=!1){const t=[];if(this.certificates&&this.certificates.length&&this.certificates.some((e=>e instanceof qi))||this.crls&&this.crls.length&&this.crls.some((e=>e instanceof Xi))?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some((e=>e instanceof Ga))?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some((e=>e instanceof wa))||this.signerInfos.some((e=>3===e.version))||this.encapContentInfo.eContentType!==mm.ID_DATA?this.version=3:this.version=1,t.push(new r.z8({value:this.version})),t.push(new r.l4({value:Array.from(this.digestAlgorithms,(e=>e.toSchema()))})),t.push(this.encapContentInfo.toSchema()),this.certificates){const e=new Gi({certificates:this.certificates}).toSchema();t.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:e.valueBlock.value}))}return this.crls&&t.push(new r.FC({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,(t=>{if(t instanceof Xi){const e=t.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}return t.toSchema(e)}))})),t.push(new r.l4({value:Array.from(this.signerInfos,(e=>e.toSchema()))})),new r.T9({value:t})}toJSON(){const e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,(e=>e.toJSON())),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,(e=>e.toJSON()))};return this.certificates&&(e.certificates=Array.from(this.certificates,(e=>e.toJSON()))),this.crls&&(e.crls=Array.from(this.crls,(e=>e.toJSON()))),e}async verify({signer:e=-1,data:t=l,trustedCerts:s=[],checkDate:r=new Date,checkChain:a=!1,passedWhenNotRevValues:i=!1,extendedMode:o=!1,findOrigin:c=null,findIssuer:h=null}={},m=pr(!0)){let f=null,d=null;try{let g=l,p=u,w=[];const y=this.signerInfos[e];if(!y)throw new hm({date:r,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new hm({date:r,code:2,message:"No certificates attached to this signed data"});if(y.sid instanceof ho){for(const e of this.certificates)if(e instanceof Un&&e.issuer.isEqual(y.sid.issuer)&&e.serialNumber.isEqual(y.sid.serialNumber)){f=e;break}}else{const e=y.sid,t=e.idBlock.isConstructed?e.valueBlock.value[0].valueBlock.valueHex:e.valueBlock.valueHex;for(const e of this.certificates){if(!(e instanceof Un))continue;const s=await m.digest({name:"sha-1"},e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(n.dN(s,t)){f=e;break}}}if(!f)throw new hm({date:r,code:3,message:"Unable to find signer certificate"});if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){if(!this.encapContentInfo.eContent)throw new hm({date:r,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0});let e;try{e=Gh.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(e){throw new hm({date:r,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0})}if(r=e.genTime,d=e.serialNumber.valueBlock.valueHexView.slice(),0===t.byteLength)throw new hm({date:r,code:4,message:"Missed detached data input array"});if(!await e.verify({data:t},m))throw new hm({date:r,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:null,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0})}if(a){const e=this.certificates.filter((e=>e instanceof Un&&!!$n(e,f))),t={checkDate:r,certs:e,trustedCerts:s};h&&(t.findIssuer=h),c&&(t.findOrigin=c);const a=new Lu(t);if(a.certs.push(f),this.crls)for(const e of this.crls)"thisUpdate"in e?a.crls.push(e):e.otherRevInfoFormat===Ne&&a.ocsps.push(new Gu({schema:e.otherRevInfo}));this.ocsps&&a.ocsps.push(...this.ocsps);const n=await a.verify({passedWhenNotRevValues:i},m).catch((e=>{throw new hm({date:r,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signerCertificate:f,signerCertificateVerified:!1})}));if(n.certificatePath&&(w=n.certificatePath),!n.result)throw new hm({date:r,code:5,message:`Validation of signer's certificate failed: ${n.resultMessage}`,signerCertificate:f,signerCertificateVerified:!1})}const v=m.getAlgorithmByOID(y.digestAlgorithm.algorithmId);if(!("name"in v))throw new hm({date:r,code:7,message:`Unsupported signature algorithm: ${y.digestAlgorithm.algorithmId}`,signerCertificate:f,signerCertificateVerified:!0});p=v.name;const b=this.encapContentInfo.eContent;if(b)t=1===b.idBlock.tagClass&&4===b.idBlock.tagNumber?b.getValue():b.valueBlock.valueBeforeDecodeView;else if(0===t.byteLength)throw new hm({date:r,code:8,message:"Missed detached data input array",signerCertificate:f,signerCertificateVerified:!0});if(y.signedAttrs){let e=!1,t=!1;for(const s of y.signedAttrs.attributes)if("1.2.840.113549.1.9.3"===s.type&&(e=!0),"1.2.840.113549.1.9.4"===s.type&&(t=!0,g=s.values[0].valueBlock.valueHex),e&&t)break;if(!1===e)throw new hm({date:r,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:f,signerCertificateVerified:!0});if(!1===t)throw new hm({date:r,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:f,signerCertificateVerified:!0})}if(y.signedAttrs){const e=await m.digest(p,new Uint8Array(t));if(!n.dN(e,g))throw new hm({date:r,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0});t=y.signedAttrs.encodedValue}const S=await m.verifyWithPublicKey(t,y.signature,f.subjectPublicKeyInfo,f.signatureAlgorithm,p);return o?{date:r,code:14,message:u,signatureVerified:S,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0,certificatePath:w}:S}catch(e){if(e instanceof hm)throw e;throw new hm({date:r,code:15,message:`Error during verification: ${e instanceof Error?e.message:e}`,signatureVerified:null,signerCertificate:f,timestampSerial:d,signerCertificateVerified:!0})}}async sign(e,t,s="SHA-1",n=l,i=pr(!0)){if(!e)throw new Error("Need to provide a private key for signing");const o=i.getOIDByAlgorithm({name:s},!0,"hashAlgorithm");0===this.digestAlgorithms.filter((e=>e.algorithmId===o)).length&&this.digestAlgorithms.push(new K({algorithmId:o,algorithmParams:new r.p2}));const u=this.signerInfos[t];if(!u)throw new RangeError("SignerInfo index is out of range");u.digestAlgorithm=new K({algorithmId:o,algorithmParams:new r.p2});const c=await i.getSignatureParameters(e,s),h=c.parameters;if(u.signatureAlgorithm=c.signatureAlgorithm,u.signedAttrs)if(0!==u.signedAttrs.encodedValue.byteLength)n=u.signedAttrs.encodedValue;else{n=u.signedAttrs.toSchema().toBER();a.vJ.toUint8Array(n)[0]=49}else{const e=this.encapContentInfo.eContent;if(e)n=1===e.idBlock.tagClass&&4===e.idBlock.tagNumber?e.getValue():e.valueBlock.valueBeforeDecodeView;else if(0===n.byteLength)throw new Error("Missed detached data input array")}const m=await i.signWithPrivateKey(n,e,h);u.signature=new r.fi({valueHex:m})}}mm.CLASS_NAME="SignedData",mm.ID_DATA=pe;const fm="version",dm="authSafe",gm="macData",pm="parsedValue",wm=[fm,dm,gm];class ym extends f{constructor(e={}){super(),this.version=n.H$(e,fm,ym.defaultValues(fm)),this.authSafe=n.H$(e,dm,ym.defaultValues(dm)),gm in e&&(this.macData=n.H$(e,gm,ym.defaultValues(gm))),pm in e&&(this.parsedValue=n.H$(e,pm,ym.defaultValues(pm))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fm:return 3;case dm:return new Xa;case gm:return new kc;case pm:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fm:return t===ym.defaultValues(e);case dm:return Xa.compareWithDefault("contentType",t.contentType)&&Xa.compareWithDefault("content",t.content);case gm:return kc.compareWithDefault("mac",t.mac)&&kc.compareWithDefault("macSalt",t.macSalt)&&kc.compareWithDefault("iterations",t.iterations);case pm:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.version||fm}),Xa.schema(t.authSafe||{names:{blockName:dm}}),kc.schema(t.macData||{names:{blockName:gm,optional:!0}})]})}fromSchema(e){n.ze(e,wm);const t=r.eN(e,e,ym.schema({names:{version:fm,authSafe:{names:{blockName:dm}},macData:{names:{blockName:gm}}}}));m.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new Xa({schema:t.result.authSafe}),gm in t.result&&(this.macData=new kc({schema:t.result.macData}))}toSchema(){const e=[new r.z8({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new r.T9({value:e})}toJSON(){const e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=pr(!0)){if(c.assert(e,"parameters","object"),!this.parsedValue)throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(h.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),h.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new h("iterations");h.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),h.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),h.assertEmpty(e.password,"password");const s=new ArrayBuffer(64),a=new Uint8Array(s);t.getRandomValues(a);const n=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new Xa({contentType:Xa.DATA,content:new r.fi({valueHex:n})});const i=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:s,iterationCount:e.iterations,contentToStamp:n});this.macData=new kc({mac:new dc({digestAlgorithm:new K({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new r.fi({valueHex:i})}),macSalt:new r.fi({valueHex:s}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new h("signingCertificate");h.assertEmpty(e.privateKey,"privateKey"),h.assertEmpty(e.hashAlgorithm,"hashAlgorithm");const s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),a=new mm({version:1,encapContentInfo:new yc({eContentType:"1.2.840.113549.1.7.1",eContent:new r.fi({valueHex:s})}),certificates:[e.signingCertificate]}),n=await t.digest({name:e.hashAlgorithm},new Uint8Array(s)),i=[];i.push(new z({type:"1.2.840.113549.1.9.3",values:[new r.rP({value:"1.2.840.113549.1.7.1"})]})),i.push(new z({type:"1.2.840.113549.1.9.5",values:[new r.BD({valueDate:new Date})]})),i.push(new z({type:"1.2.840.113549.1.9.4",values:[new r.fi({valueHex:n})]})),a.signerInfos.push(new Bh({version:1,sid:new ho({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new uh({type:0,attributes:i})})),await a.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new Xa({contentType:"1.2.840.113549.1.7.2",content:a.toSchema(!0)})}break;default:throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=pr(!0)){switch(c.assert(e,"parameters","object"),void 0===e.checkIntegrity&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case Xa.DATA:{h.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,c.assert(this.authSafe.content,"authSafe.content",r.fi);const s=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=ru.fromBER(s),e.checkIntegrity){if(!this.macData)throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');const r=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm");if(!await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:r.name,salt:a.vJ.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||0,contentToVerify:s,signatureToVerify:a.vJ.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)}))throw new Error("Integrity for the PKCS#12 data is broken!")}}break;case Xa.SIGNED_DATA:{this.parsedValue.integrityMode=1;const e=new mm({schema:this.authSafe.content}),s=e.encapContentInfo.eContent;h.assert(s,"eContent","cmsSigned.encapContentInfo"),c.assert(s,"eContent",r.fi);const a=s.getValue();this.parsedValue.authenticatedSafe=ru.fromBER(a);if(!await e.verify({signer:0,checkChain:!1},t))throw new Error("Integrity for the PKCS#12 data is broken!")}break;default:throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}}ym.CLASS_NAME="PFX";const vm="status",bm="statusStrings",Sm="failInfo",Am=[vm,bm,Sm];var km;!function(e){e[e.granted=0]="granted",e[e.grantedWithMods=1]="grantedWithMods",e[e.rejection=2]="rejection",e[e.waiting=3]="waiting",e[e.revocationWarning=4]="revocationWarning",e[e.revocationNotification=5]="revocationNotification"}(km||(km={}));class Nm extends f{constructor(e={}){super(),this.status=n.H$(e,vm,Nm.defaultValues(vm)),bm in e&&(this.statusStrings=n.H$(e,bm,Nm.defaultValues(bm))),Sm in e&&(this.failInfo=n.H$(e,Sm,Nm.defaultValues(Sm))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vm:return 2;case bm:return[];case Sm:return new r._K;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case vm:return t===Nm.defaultValues(e);case bm:return 0===t.length;case Sm:return t.isEqual(Nm.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||u,value:[new r.z8({name:t.status||u}),new r.T9({optional:!0,value:[new r.ZD({name:t.statusStrings||u,value:new r.qU})]}),new r._K({name:t.failInfo||u,optional:!0})]})}fromSchema(e){n.ze(e,Am);const t=r.eN(e,e,Nm.schema({names:{status:vm,statusStrings:bm,failInfo:Sm}}));m.assertSchema(t,this.className);const s=t.result.status;if(!0===s.valueBlock.isHexOnly||s.valueBlock.valueDec<0||s.valueBlock.valueDec>5)throw new Error('PKIStatusInfo "status" has invalid value');this.status=s.valueBlock.valueDec,bm in t.result&&(this.statusStrings=t.result.statusStrings),Sm in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){const e=[];return e.push(new r.z8({value:this.status})),this.statusStrings&&e.push(new r.T9({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new r.T9({value:e})}toJSON(){const e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,(e=>e.toJSON()))),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}}Nm.CLASS_NAME="PKIStatusInfo";const Cm="version",Bm="messageImprint",Vm="reqPolicy",Im="nonce",Em="certReq",Hm="extensions",xm="TimeStampReq",Dm="TimeStampReq.version",Om="TimeStampReq.messageImprint",Tm="TimeStampReq.reqPolicy",Pm="TimeStampReq.nonce",Um="TimeStampReq.certReq",$m="TimeStampReq.extensions",Lm=[Dm,Om,Tm,Pm,Um,$m];class Rm extends f{constructor(e={}){super(),this.version=n.H$(e,Cm,Rm.defaultValues(Cm)),this.messageImprint=n.H$(e,Bm,Rm.defaultValues(Bm)),Vm in e&&(this.reqPolicy=n.H$(e,Vm,Rm.defaultValues(Vm))),Im in e&&(this.nonce=n.H$(e,Im,Rm.defaultValues(Im))),Em in e&&(this.certReq=n.H$(e,Em,Rm.defaultValues(Em))),Hm in e&&(this.extensions=n.H$(e,Hm,Rm.defaultValues(Hm))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cm:return 0;case Bm:return new Vc;case Vm:return u;case Im:return new r.z8;case Em:return!1;case Hm:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Cm:case Vm:case Em:return t===Rm.defaultValues(e);case Bm:return Vc.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&Vc.compareWithDefault("hashedMessage",t.hashedMessage);case Im:return t.isEqual(Rm.defaultValues(e));case Hm:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||xm,value:[new r.z8({name:t.version||Dm}),Vc.schema(t.messageImprint||{names:{blockName:Om}}),new r.rP({name:t.reqPolicy||Tm,optional:!0}),new r.z8({name:t.nonce||Pm,optional:!0}),new r.ge({name:t.certReq||Um,optional:!0}),new r.FC({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r.ZD({name:t.extensions||$m,value:qr.schema()})]})]})}fromSchema(e){n.ze(e,Lm);const t=r.eN(e,e,Rm.schema());m.assertSchema(t,this.className),this.version=t.result[Dm].valueBlock.valueDec,this.messageImprint=new Vc({schema:t.result["TimeStampReq.messageImprint"]}),Tm in t.result&&(this.reqPolicy=t.result[Tm].valueBlock.toString()),Pm in t.result&&(this.nonce=t.result[Pm]),Um in t.result&&(this.certReq=t.result["TimeStampReq.certReq"].valueBlock.value),$m in t.result&&(this.extensions=Array.from(t.result[$m],(e=>new qr({schema:e}))))}toSchema(){const e=[];return e.push(new r.z8({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new r.rP({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),Em in this&&!1===Rm.compareWithDefault(Em,this.certReq)&&e.push(new r.ge({value:this.certReq})),this.extensions&&e.push(new r.FC({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,(e=>e.toSchema()))})),new r.T9({value:e})}toJSON(){const e={version:this.version,messageImprint:this.messageImprint.toJSON()};return void 0!==this.reqPolicy&&(e.reqPolicy=this.reqPolicy),void 0!==this.nonce&&(e.nonce=this.nonce.toJSON()),void 0!==this.certReq&&!1===Rm.compareWithDefault(Em,this.certReq)&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,(e=>e.toJSON()))),e}}Rm.CLASS_NAME="TimeStampReq";const Km="status",Jm="timeStampToken",_m="TimeStampResp",Fm="TimeStampResp.status",Mm="TimeStampResp.timeStampToken",jm=[Fm,Mm];class qm extends f{constructor(e={}){super(),this.status=n.H$(e,Km,qm.defaultValues(Km)),Jm in e&&(this.timeStampToken=n.H$(e,Jm,qm.defaultValues(Jm))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Km:return new Nm;case Jm:return new Xa;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Km:return Nm.compareWithDefault(Km,t.status)&&"statusStrings"in t==!1&&"failInfo"in t==!1;case Jm:return t.contentType===u&&t.content instanceof r.IK;default:return super.defaultValues(e)}}static schema(e={}){const t=n.H$(e,"names",{});return new r.T9({name:t.blockName||_m,value:[Nm.schema(t.status||{names:{blockName:Fm}}),Xa.schema(t.timeStampToken||{names:{blockName:Mm,optional:!0}})]})}fromSchema(e){n.ze(e,jm);const t=r.eN(e,e,qm.schema());m.assertSchema(t,this.className),this.status=new Nm({schema:t.result[Fm]}),Mm in t.result&&(this.timeStampToken=new Xa({schema:t.result[Mm]}))}toSchema(){const e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new r.T9({value:e})}toJSON(){const e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,s=pr(!0)){this.assertContentType();return new mm({schema:this.timeStampToken.content}).sign(e,0,t,void 0,s)}async verify(e={signer:0,trustedCerts:[],data:l},t=pr(!0)){this.assertContentType();return new mm({schema:this.timeStampToken.content}).verify(e,t)}assertContentType(){if(!this.timeStampToken)throw new Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==we)throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}}qm.CLASS_NAME="TimeStampResp",function(){if("undefined"!=typeof self){if("crypto"in self){let e="webcrypto";"webkitSubtle"in self.crypto&&(e="safari"),gr(e,new mr({name:e,crypto}))}}else if("undefined"!=typeof crypto&&"webcrypto"in crypto){const e="NodeJS ^15",t=crypto.webcrypto;gr(e,new mr({name:e,crypto:t}))}}()},656:(e,t)=>{"use strict";class s{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e).slice().buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=s.toUint8Array(e),a=s.toUint8Array(t);if(r.length!==a.byteLength)return!1;for(let e=0;e<r.length;e++)if(r[e]!==a[e])return!1;return!0}static concat(...e){if(Array.isArray(e[0])){const t=e[0];let s=0;for(const e of t)s+=e.byteLength;const r=new Uint8Array(s);let a=0;for(const e of t){const t=this.toUint8Array(e);r.set(t,a),a+=t.length}return e[1]?this.toView(r,e[1]):r.buffer}return this.concat(e)}}class r{static fromString(e){const t=unescape(encodeURIComponent(e)),s=new Uint8Array(t.length);for(let e=0;e<t.length;e++)s[e]=t.charCodeAt(e);return s.buffer}static toString(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return decodeURIComponent(escape(r))}}class a{static toString(e,t=!1){const r=s.toArrayBuffer(e),a=new DataView(r);let n="";for(let e=0;e<r.byteLength;e+=2){const s=a.getUint16(e,t);n+=String.fromCharCode(s)}return n}static fromString(e,t=!1){const s=new ArrayBuffer(2*e.length),r=new DataView(s);for(let s=0;s<e.length;s++)r.setUint16(2*s,e.charCodeAt(s),t);return s}}class n{static isHex(e){return"string"==typeof e&&/^[a-z0-9]+$/i.test(e)}static isBase64(e){return"string"==typeof e&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}static isBase64Url(e){return"string"==typeof e&&/^[a-zA-Z0-9-_]+$/i.test(e)}static ToString(e,t="utf8"){const r=s.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return a.toString(r,!0);case"utf16":case"utf16be":return a.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return a.fromString(e,!0);case"utf16":case"utf16be":return a.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=s.toUint8Array(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=n.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return r.fromString(e);case"utf16":case"utf16be":return a.fromString(e);case"utf16le":case"usc2":return a.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=n.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return r.toString(e);case"utf16":case"utf16be":return a.toString(e);case"utf16le":case"usc2":return a.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,s=new Uint8Array(t);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return s.buffer}static ToBinary(e){const t=s.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=s.toUint8Array(e),r=[],a=t.length;for(let e=0;e<a;e++){const s=t[e].toString(16).padStart(2,"0");r.push(s)}return r.join("")}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!n.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const s=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const r=t.slice(e,e+2);s[e/2]=parseInt(r,16)}return s.buffer}static ToUtf16String(e,t=!1){return a.toString(e,t)}static FromUtf16String(e,t=!1){return a.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let s=0;s<t;s++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}n.DEFAULT_UTF8_ENCODING="utf8",t.vJ=s,t.ep=n},422:(e,t,s)=>{"use strict";function r(e,t,s){var r;return e instanceof Object==!1?s:null!==(r=e[t])&&void 0!==r?r:s}function a(e,t=0,s=e.byteLength-t,r=!1){let a="";for(const n of new Uint8Array(e,t,s)){const e=n.toString(16).toUpperCase();1===e.length&&(a+="0"),a+=e,r&&(a+=" ")}return a.trim()}function n(e,t){let s=0;if(1===e.length)return e[0];for(let r=e.length-1;r>=0;r--)s+=e[e.length-1-r]*Math.pow(2,t*r);return s}function i(e,t,s=-1){const r=s;let a=e,n=0,i=Math.pow(2,t);for(let s=1;s<8;s++){if(e<i){let e;if(r<0)e=new ArrayBuffer(s),n=s;else{if(r<s)return new ArrayBuffer(0);e=new ArrayBuffer(r),n=r}const i=new Uint8Array(e);for(let e=s-1;e>=0;e--){const s=Math.pow(2,e*t);i[n-e-1]=Math.floor(a/s),a-=i[n-e-1]*s}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function o(...e){let t=0,s=0;for(const s of e)t+=s.byteLength;const r=new ArrayBuffer(t),a=new Uint8Array(r);for(const t of e)a.set(new Uint8Array(t),s),s+=t.byteLength;return r}function l(...e){let t=0,s=0;for(const s of e)t+=s.length;const r=new ArrayBuffer(t),a=new Uint8Array(r);for(const t of e)a.set(t,s),s+=t.length;return a}function u(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],s=0===e[0]&&0==(128&e[1]);(t||s)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)s[e]=0;s[0]=128&e[0];const r=n(s,8),a=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(a);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];i[0]&=127;return n(i,8)-r}function c(e){const t=e<0?-1*e:e;let s=128;for(let r=1;r<8;r++){if(t<=s){if(e<0){const e=i(s-t,8,r);return new Uint8Array(e)[0]|=128,e}let a=i(t,8,r),n=new Uint8Array(a);if(128&n[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),n=new Uint8Array(a);for(let s=0;s<e.byteLength;s++)n[s+1]=t[s];n[0]=0}return a}s*=Math.pow(2,8)}return new ArrayBuffer(0)}function h(e,t){if(e.byteLength!==t.byteLength)return!1;const s=new Uint8Array(e),r=new Uint8Array(t);for(let e=0;e<s.length;e++)if(s[e]!==r[e])return!1;return!0}function m(e,t){const s=e.toString(10);if(t<s.length)return"";const r=t-s.length,a=new Array(r);for(let e=0;e<r;e++)a[e]="0";return a.join("").concat(s)}s.d(t,{Gc:()=>u,Gh:()=>p,H$:()=>r,Ir:()=>l,J$:()=>b,RH:()=>a,dN:()=>h,gG:()=>y,hk:()=>o,lE:()=>w,lL:()=>i,qE:()=>c,r9:()=>n,s3:()=>g,vX:()=>m,ze:()=>S});const f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function g(e,t=!1,s=!1,r=!1){let a=0,n=0,i=0,o="";const l=t?d:f;if(r){let t=0;for(let s=0;s<e.length;s++)if(0!==e.charCodeAt(s)){t=s;break}e=e.slice(t)}for(;a<e.length;){const t=e.charCodeAt(a++);a>=e.length&&(n=1);const r=e.charCodeAt(a++);a>=e.length&&(i=1);const u=e.charCodeAt(a++),c=t>>2,h=(3&t)<<4|r>>4;let m=(15&r)<<2|u>>6,f=63&u;1===n?m=f=64:1===i&&(f=64),o+=s?64===m?`${l.charAt(c)}${l.charAt(h)}`:64===f?`${l.charAt(c)}${l.charAt(h)}${l.charAt(m)}`:`${l.charAt(c)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(c)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`}return o}function p(e,t=!1,s=!1){const r=t?d:f;function a(e){for(let t=0;t<64;t++)if(r.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=a(e.charAt(i++)),s=i>=e.length?0:a(e.charAt(i++)),r=i>=e.length?0:a(e.charAt(i++)),l=i>=e.length?0:a(e.charAt(i++)),u=n(t)<<2|n(s)>>4,c=(15&n(s))<<4|n(r)>>2,h=(3&n(r))<<6|n(l);o+=String.fromCharCode(u),64!==r&&(o+=String.fromCharCode(c)),64!==l&&(o+=String.fromCharCode(h))}if(s){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}o=-1!==e?o.slice(0,e+1):""}return o}function w(e){let t="";const s=new Uint8Array(e);for(const e of s)t+=String.fromCharCode(e);return t}function y(e){const t=e.length,s=new ArrayBuffer(t),r=new Uint8Array(s);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return s}const v=Math.log(2);function b(e){const t=Math.log(e)/v,s=Math.floor(t),r=Math.round(t);return s===r?s:r}function S(e,t){for(const s of t)delete e[s]}},475:(e,t)=>{"use strict";function s(e,t){var s=e.length;e.push(t);e:for(;0<s;){var r=s-1>>>1,a=e[r];if(!(0<n(a,t)))break e;e[r]=t,e[s]=a,s=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],s=e.pop();if(s!==t){e[0]=s;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>n(l,s))u<a&&0>n(c,l)?(e[r]=c,e[u]=s,r=u):(e[r]=l,e[o]=s,r=o);else{if(!(u<a&&0>n(c,s)))break e;e[r]=c,e[u]=s,r=u}}}return t}function n(e,t){var s=e.sortIndex-t.sortIndex;return 0!==s?s:e.id-t.id}if("object"==typeof performance&&"function"==typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],h=1,m=null,f=3,d=!1,g=!1,p=!1,w="function"==typeof setTimeout?setTimeout:null,y="function"==typeof clearTimeout?clearTimeout:null,v="undefined"!=typeof setImmediate?setImmediate:null;function b(e){for(var t=r(c);null!==t;){if(null===t.callback)a(c);else{if(!(t.startTime<=e))break;a(c),t.sortIndex=t.expirationTime,s(u,t)}t=r(c)}}function S(e){if(p=!1,b(e),!g)if(null!==r(u))g=!0,O(A);else{var t=r(c);null!==t&&T(S,t.startTime-e)}}function A(e,s){g=!1,p&&(p=!1,y(B),B=-1),d=!0;var n=f;try{for(b(s),m=r(u);null!==m&&(!(m.expirationTime>s)||e&&!E());){var i=m.callback;if("function"==typeof i){m.callback=null,f=m.priorityLevel;var o=i(m.expirationTime<=s);s=t.unstable_now(),"function"==typeof o?m.callback=o:m===r(u)&&a(u),b(s)}else a(u);m=r(u)}if(null!==m)var l=!0;else{var h=r(c);null!==h&&T(S,h.startTime-s),l=!1}return l}finally{m=null,f=n,d=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var k,N=!1,C=null,B=-1,V=5,I=-1;function E(){return!(t.unstable_now()-I<V)}function H(){if(null!==C){var e=t.unstable_now();I=e;var s=!0;try{s=C(!0,e)}finally{s?k():(N=!1,C=null)}}else N=!1}if("function"==typeof v)k=function(){v(H)};else if("undefined"!=typeof MessageChannel){var x=new MessageChannel,D=x.port2;x.port1.onmessage=H,k=function(){D.postMessage(null)}}else k=function(){w(H,0)};function O(e){C=e,N||(N=!0,k())}function T(e,s){B=w((function(){e(t.unstable_now())}),s)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){g||d||(g=!0,O(A))},t.unstable_forceFrameRate=function(e){0>e||125<e||(V=0<e?Math.floor(1e3/e):5)},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(f){case 1:case 2:case 3:var t=3;break;default:t=f}var s=f;f=t;try{return e()}finally{f=s}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var s=f;f=e;try{return t()}finally{f=s}},t.unstable_scheduleCallback=function(e,a,n){var i=t.unstable_now();switch("object"==typeof n&&null!==n?n="number"==typeof(n=n.delay)&&0<n?i+n:i:n=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:a,priorityLevel:e,startTime:n,expirationTime:o=n+o,sortIndex:-1},n>i?(e.sortIndex=n,s(c,e),null===r(u)&&e===r(c)&&(p?(y(B),B=-1):p=!0,T(S,n-i))):(e.sortIndex=o,s(u,e),g||d||(g=!0,O(A))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=f;return function(){var s=f;f=t;try{return e.apply(this,arguments)}finally{f=s}}}},616:(e,t,s)=>{"use strict";e.exports=s(475)},926:(e,t,s)=>{"use strict";function r(e,t){(null==t||t>e.length)&&(t=e.length);for(var s=0,r=new Array(t);s<t;s++)r[s]=e[s];return r}s.d(t,{Z:()=>r})},753:(e,t,s)=>{"use strict";function r(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}s.d(t,{Z:()=>r})},795:(e,t,s)=>{"use strict";function r(e,t,s,r,a,n,i){try{var o=e[n](i),l=o.value}catch(e){return void s(e)}o.done?t(l):Promise.resolve(l).then(r,a)}function a(e){return function(){var t=this,s=arguments;return new Promise((function(a,n){var i=e.apply(t,s);function o(e){r(i,a,n,o,l,"next",e)}function l(e){r(i,a,n,o,l,"throw",e)}o(void 0)}))}}s.d(t,{Z:()=>a})},249:(e,t,s)=>{"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}s.d(t,{Z:()=>r})},371:(e,t,s)=>{"use strict";function r(e,t){for(var s=0;s<t.length;s++){var r=t[s];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function a(e,t,s){return t&&r(e.prototype,t),s&&r(e,s),Object.defineProperty(e,"prototype",{writable:!1}),e}s.d(t,{Z:()=>a})},666:(e,t,s)=>{"use strict";function r(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}s.d(t,{Z:()=>r})},58:(e,t,s)=>{"use strict";function r(e){return r=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},r(e)}s.d(t,{Z:()=>r})},754:(e,t,s)=>{"use strict";s.d(t,{Z:()=>a});var r=s(960);function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&(0,r.Z)(e,t)}},987:(e,t,s)=>{"use strict";s.d(t,{Z:()=>n});var r=s(522),a=s(753);function n(e,t){if(t&&("object"===(0,r.Z)(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return(0,a.Z)(e)}},960:(e,t,s)=>{"use strict";function r(e,t){return r=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},r(e,t)}s.d(t,{Z:()=>r})},867:(e,t,s)=>{"use strict";s.d(t,{Z:()=>a});var r=s(147);function a(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var s=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=s){var r,a,n=[],i=!0,o=!1;try{for(s=s.call(e);!(i=(r=s.next()).done)&&(n.push(r.value),!t||n.length!==t);i=!0);}catch(e){o=!0,a=e}finally{try{i||null==s.return||s.return()}finally{if(o)throw a}}return n}}(e,t)||(0,r.Z)(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},777:(e,t,s)=>{"use strict";s.d(t,{Z:()=>n});var r=s(926);var a=s(147);function n(e){return function(e){if(Array.isArray(e))return(0,r.Z)(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||(0,a.Z)(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},522:(e,t,s)=>{"use strict";function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}s.d(t,{Z:()=>r})},147:(e,t,s)=>{"use strict";s.d(t,{Z:()=>a});var r=s(926);function a(e,t){if(e){if("string"==typeof e)return(0,r.Z)(e,t);var s=Object.prototype.toString.call(e).slice(8,-1);return"Object"===s&&e.constructor&&(s=e.constructor.name),"Map"===s||"Set"===s?Array.from(e):"Arguments"===s||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)?(0,r.Z)(e,t):void 0}}},501:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});var r=s(58),a=s(960);function n(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function i(e,t,s){return i=n()?Reflect.construct:function(e,t,s){var r=[null];r.push.apply(r,t);var n=new(Function.bind.apply(e,r));return s&&(0,a.Z)(n,s.prototype),n},i.apply(null,arguments)}function o(e){var t="function"==typeof Map?new Map:void 0;return o=function(e){if(null===e||(s=e,-1===Function.toString.call(s).indexOf("[native code]")))return e;var s;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return i(e,arguments,(0,r.Z)(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),(0,a.Z)(n,e)},o(e)}}}]);